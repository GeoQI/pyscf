

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>10.18. mcscf — Multi-configurational self-consistent field &mdash; PySCF 1.7.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="10.19. mp — MP2" href="mp.html" />
    <link rel="prev" title="10.17. lo — Orbital localization and analysis tools" href="lo.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../version.html">2. Version history</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code-rule.html">4. Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmark.html">5. Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">6. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory.html">7. Theoretical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced.html">8. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interface.html">9. Interfaces</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../modules.html">10. Main modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="adc.html">10.1. <code class="xref py py-mod docutils literal notranslate"><span class="pre">adc</span></code> — Algebraic diagrammatic construction (ADC) scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="ao2mo.html">10.2. <code class="xref py py-mod docutils literal notranslate"><span class="pre">ao2mo</span></code> — Integral transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="cc.html">10.3. <code class="xref py py-mod docutils literal notranslate"><span class="pre">cc</span></code> — Coupled cluster</a></li>
<li class="toctree-l2"><a class="reference internal" href="ccn.html">10.4. <code class="xref py py-mod docutils literal notranslate"><span class="pre">ccn</span></code> — Auto-generated coupled cluster of arbitrary order</a></li>
<li class="toctree-l2"><a class="reference internal" href="ci.html">10.5. <code class="xref py py-mod docutils literal notranslate"><span class="pre">ci</span></code> — Configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html">10.6. <code class="xref py py-mod docutils literal notranslate"><span class="pre">data</span></code> — Data for constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="df.html">10.7. <code class="xref py py-mod docutils literal notranslate"><span class="pre">df</span></code> — Density fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="dft.html">10.8. <code class="xref py py-mod docutils literal notranslate"><span class="pre">dft</span></code> — Density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="doci.html">10.9. <code class="xref py py-mod docutils literal notranslate"><span class="pre">doci</span></code> — Doubly occupied configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="fci.html">10.10. <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code> — Full configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="grad.html">10.11. <code class="xref py py-mod docutils literal notranslate"><span class="pre">grad</span></code> — Analytical nuclear gradients</a></li>
<li class="toctree-l2"><a class="reference internal" href="gto.html">10.12. <code class="xref py py-mod docutils literal notranslate"><span class="pre">gto</span></code> — Molecular structure and GTO basis</a></li>
<li class="toctree-l2"><a class="reference internal" href="gw.html">10.13. <code class="xref py py-mod docutils literal notranslate"><span class="pre">gw</span></code> — Molecular G0W0</a></li>
<li class="toctree-l2"><a class="reference internal" href="hci.html">10.14. <code class="xref py py-mod docutils literal notranslate"><span class="pre">hci</span></code> — Heat-bath selected CI</a></li>
<li class="toctree-l2"><a class="reference internal" href="hessian.html">10.15. <code class="xref py py-mod docutils literal notranslate"><span class="pre">hessian</span></code> — Analytical nuclear Hessian</a></li>
<li class="toctree-l2"><a class="reference internal" href="lib.html">10.16. <code class="xref py py-mod docutils literal notranslate"><span class="pre">lib</span></code> — Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="lo.html">10.17. <code class="xref py py-mod docutils literal notranslate"><span class="pre">lo</span></code> — Orbital localization and analysis tools</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">10.18. <code class="xref py py-mod docutils literal notranslate"><span class="pre">mcscf</span></code> — Multi-configurational self-consistent field</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#examples">10.18.1. Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#casscf-active-space-solver">10.18.2. CASSCF active space solver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dmrg-solver">10.18.2.1. DMRG solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fciqmc-solver">10.18.2.2. FCIQMC solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#state-average-fci-solver">10.18.2.3. State-average FCI solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#state-average-with-mixed-solver">10.18.2.4. State-average with mixed solver</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#symmetry-broken">10.18.3. Symmetry broken</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initial-guess">10.18.4. Initial guess</a></li>
<li class="toctree-l3"><a class="reference internal" href="#canonical-orbitals">10.18.5. Canonical orbitals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#program-reference">10.18.6. Program reference</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.mcscf.casci">10.18.6.1. CASCI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.mcscf.mc1step">10.18.6.2. CASSCF</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.mcscf.addons">10.18.6.3. addons</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="mp.html">10.19. <code class="xref py py-mod docutils literal notranslate"><span class="pre">mp</span></code> — MP2</a></li>
<li class="toctree-l2"><a class="reference internal" href="mrpt.html">10.20. <code class="xref py py-mod docutils literal notranslate"><span class="pre">mrpt</span></code> — Multi-reference perturbation theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="pbc.html">10.21. <code class="xref py py-mod docutils literal notranslate"><span class="pre">pbc</span></code> — Periodic boundary conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="prop.html">10.22. <code class="xref py py-mod docutils literal notranslate"><span class="pre">prop</span></code> — Molecular properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="qmmm.html">10.23. <code class="xref py py-mod docutils literal notranslate"><span class="pre">qmmm</span></code> — QM/MM interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rt.html">10.24. <code class="xref py py-mod docutils literal notranslate"><span class="pre">rt</span></code> — Real-time time-dependent density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="scf.html">10.25. <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf</span></code> — Self-consistent field methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="semiempirical.html">10.26. <code class="xref py py-mod docutils literal notranslate"><span class="pre">semiempirical</span></code> — Semiempirical methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="sgx.html">10.27. <code class="xref py py-mod docutils literal notranslate"><span class="pre">sgx</span></code> — Pseudo-spectral methods (COSX, PS, SN-K)</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvent.html">10.28. <code class="xref py py-mod docutils literal notranslate"><span class="pre">solvent</span></code> — Solvent methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="soscf.html">10.29. <code class="xref py py-mod docutils literal notranslate"><span class="pre">soscf</span></code> — Second order SCF solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="symm.html">10.30. <code class="xref py py-mod docutils literal notranslate"><span class="pre">symm</span></code> – Point group symmetry and spin symmetry</a></li>
<li class="toctree-l2"><a class="reference internal" href="tdscf.html">10.31. <code class="xref py py-mod docutils literal notranslate"><span class="pre">tdscf</span></code> — TDHF and TDDFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">10.32. <code class="xref py py-mod docutils literal notranslate"><span class="pre">tools</span></code> — Useful tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="x2c.html">10.33. <code class="xref py py-mod docutils literal notranslate"><span class="pre">x2c</span></code> — exact-two-component approach</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PySCF</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../modules.html"><span class="section-number">10. </span>Main modules</a> &raquo;</li>
        
      <li><span class="section-number">10.18. </span><code class="xref py py-mod docutils literal notranslate"><span class="pre">mcscf</span></code> — Multi-configurational self-consistent field</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/modules/mcscf.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mcscf-multi-configurational-self-consistent-field">
<span id="mcscf"></span><h1><span class="section-number">10.18. </span><code class="xref py py-mod docutils literal notranslate"><span class="pre">mcscf</span></code> — Multi-configurational self-consistent field<a class="headerlink" href="#mcscf-multi-configurational-self-consistent-field" title="Permalink to this headline">¶</a></h1>
<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">mcscf</span></code> implements orbital optimization for
MCSCF and CASSCF. 1-step (combined orbital and wavefunction
optimization) and 2-step algorithms (alternating orbital and wavefunction
optimization) are available. Different kinds of active space solvers can
be used with this module.</p>
<p>For example, a simple CASCI calculation can be run as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyscf</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">pyscf</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;O 0 0 0; O 0 0 1.2&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span>
    <span class="n">spin</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">myhf</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">RHF</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="c1"># 6 orbitals, 8 electrons</span>
<span class="n">mycas</span> <span class="o">=</span> <span class="n">myhf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>and a simple CASSCF can be run as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyscf</span>

 <span class="n">mol</span> <span class="o">=</span> <span class="n">pyscf</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
     <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;O 0 0 0; O 0 0 1.2&#39;</span><span class="p">,</span>
     <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span>
     <span class="n">spin</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

 <span class="n">myhf</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">RHF</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

 <span class="c1"># 6 orbitals, 8 electrons</span>
 <span class="n">mycas</span> <span class="o">=</span> <span class="n">myhf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>The CASSCF orbital optimization is general and can be combined
with many different solvers, such as DMRG and selected CI solvers.
Optimized orbitals are stored in the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">mycas.mo_coeff</span></code>.</p>
<div class="section" id="examples">
<h2><span class="section-number">10.18.1. </span>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>Relevant examples
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/00-simple_casci.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/00-simple_casscf.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/01-for_expensive_fci.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/03-natural_orbital.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/04-density_matrix.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/10-define_cas_space.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/11-casscf_with_uhf_uks.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/12-c2_triplet_from_singlet_hf.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/13-load_chkfile.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/13-restart.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/14-project_init_guess.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/15-state_average.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/15-state_specific.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/15-transition_dm.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/16-density_fitting.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/17-approx_orbital_hessian.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/18-o2_spatial_spin_symmetry.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/18-spatial_spin_symmetry.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/19-frozen_core.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/20-change_symmetry.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/21-active_space_symmetry.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/21-nosymhf_then_symcasscf.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/22-x2c.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/23-local_spin.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/33-make_init_guess</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/34-init_guess_localization.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/40-customizing_hamiltonian.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/41-mcscf_custom_df_hamiltonian.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/41-state_average.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/42-compare_cas_space.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/43-avas.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/43-dmet_cas.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/44-mcscf_active_space_hamiltonian.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/50-casscf_then_dmrgscf.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/50-casscf_with_selected_ci.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/50-cornell_shci_casscf.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/50-dmrgscf_with_block.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/51-o2_triplet_by_various_fci.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/60-uhf_based_ucasscf.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/61-rcas_vs_ucas</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/70-casscf_hot_tuning.py</span></code>
<code class="file docutils literal notranslate"><span class="pre">examples/mcscf/70-casscf_optimize_scheduler.py</span></code></p>
<span class="target" id="module-pyscf.mcscf"></span><p>CASCI and CASSCF</p>
<p>When using results of this code for publications, please cite the following paper:
“A general second order complete active space self-consistent-field solver for large-scale systems”, Q. Sun, J. Yang, and G. K.-L. Chan, Chem. Phys. Lett. 683, 291 (2017).</p>
<p>Simple usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401882238134</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cas_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="c1"># pick orbitals for CAS space, 1-based indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">sort_mo</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">cas_list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mo</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.007378939813691</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">mcscf.CASSCF()</span></code> or <code class="xref py py-func docutils literal notranslate"><span class="pre">mcscf.CASCI()</span></code> returns a proper instance of CASSCF/CASCI class.
There are some parameters to control the CASSCF/CASCI method.</p>
<blockquote>
<div><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code>.</p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code>.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Active space size.</p>
</dd>
<dt>nelecas<span class="classifier">tuple of int</span></dt><dd><p>Active (nelec_alpha, nelec_beta)</p>
</dd>
<dt>ncore<span class="classifier">int or tuple of int</span></dt><dd><p>Core electron number.  In UHF-CASSCF, it’s a tuple to indicate the different core eletron numbers.</p>
</dd>
<dt>natorb<span class="classifier">bool</span></dt><dd><p>Whether to restore the natural orbital during CASSCF optimization. Default is not.</p>
</dd>
<dt>canonicalization<span class="classifier">bool</span></dt><dd><p>Whether to canonicalize orbitals.  Default is True.</p>
</dd>
<dt>fcisolver<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">FCISolver</span></code></span></dt><dd><p>The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal notranslate"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p>For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code>.</p>
<p>By replacing this fcisolver, you can easily use the CASCI/CASSCF solver
with other FCI replacements,  such as DMRG, QMC.  See <code class="xref py py-mod docutils literal notranslate"><span class="pre">dmrgscf</span></code> and
<code class="xref py py-mod docutils literal notranslate"><span class="pre">fciqmcscf</span></code>.</p>
</dd>
</dl>
</div></blockquote>
<p>The Following attributes are used for CASSCF</p>
<blockquote>
<div><dl>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Converge threshold.  Default is 1e-7</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>Converge threshold for CI gradients and orbital rotation gradients.
Default is 1e-4</p>
</dd>
<dt>max_stepsize<span class="classifier">float</span></dt><dd><p>The step size for orbital rotation.  Small step size is prefered.
Default is 0.03.  
(NOTE although the default step size is small enough for many systems,
it happens that the orbital optimizor crosses the barriar of local
minimum and converge to the neighbour solution, e.g. the CAS(4,4) for
C2H4 in the test files.  In these systems, adjusting max_stepsize,
max_ci_stepsize and max_cycle_micro, max_cycle_micro_inner and
ah_start_tol may be helpful)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">max_stepsize</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">max_cycle_micro</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">max_cycle_macro</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">max_cycle_micro_inner</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_start_tol</span> <span class="o">=</span> <span class="mf">1e-6</span>
</pre></div>
</div>
</dd>
<dt>max_ci_stepsize<span class="classifier">float</span></dt><dd><p>The max size for approximate CI updates.  The approximate updates are
used in 1-step algorithm, to estimate the change of CI wavefunction wrt
the orbital rotation.  Small step size is prefered.  Default is 0.01.</p>
</dd>
<dt>max_cycle_macro<span class="classifier">int</span></dt><dd><p>Max number of macro iterations.  Default is 50.</p>
</dd>
<dt>max_cycle_micro<span class="classifier">int</span></dt><dd><p>Max number of micro iterations in each macro iteration.  Depending on
systems, increasing this value might reduce the total macro
iterations.  Generally, 2 - 3 steps should be enough.  Default is 2.</p>
</dd>
<dt>max_cycle_micro_inner<span class="classifier">int</span></dt><dd><p>Max number of steps for the orbital rotations allowed for the augmented
hessian solver.  It can affect the actual size of orbital rotation.
Even with a small max_stepsize, a few max_cycle_micro_inner can
accumulate the rotation and leads to a significant change of the CAS
space.  Depending on systems, increasing this value migh reduce the
total number of macro iterations.  The value between 2 - 8 is preferred.
Default is 4.</p>
</dd>
<dt>frozen<span class="classifier">int or list</span></dt><dd><p>If integer is given, the inner-most orbitals are excluded from optimization.
Given the orbital indices (0-based) in a list, any doubly occupied core
orbitals, active orbitals and external orbitals can be frozen.</p>
</dd>
<dt>ah_level_shift<span class="classifier">float, for AH solver.</span></dt><dd><p>Level shift for the Davidson diagonalization in AH solver.  Default is 0.</p>
</dd>
<dt>ah_conv_tol<span class="classifier">float, for AH solver.</span></dt><dd><p>converge threshold for Davidson diagonalization in AH solver.  Default is 1e-8.</p>
</dd>
<dt>ah_max_cycle<span class="classifier">float, for AH solver.</span></dt><dd><p>Max number of iterations allowd in AH solver.  Default is 20.</p>
</dd>
<dt>ah_lindep<span class="classifier">float, for AH solver.</span></dt><dd><p>Linear dependence threshold for AH solver.  Default is 1e-16.</p>
</dd>
<dt>ah_start_tol<span class="classifier">flat, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 1e-4.</p>
</dd>
<dt>ah_start_cycle<span class="classifier">int, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 3.</p>
<p><code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_max_cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_start_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_start_cycle</span></code>
can affect the accuracy and performance of CASSCF solver.  Lower
<code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code> can improve the accuracy of CASSCF
optimization, but slow down the performance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-109.044401898486001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-109.044401887945668</span>
</pre></div>
</div>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>Checkpoint file to save the intermediate orbitals during the CASSCF optimization.
Default is the checkpoint file of mean field object.</p>
</dd>
</dl>
</div></blockquote>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>converged<span class="classifier">bool, for CASSCF only</span></dt><dd><p>It indicates CASSCF optimization converged or not.</p>
</dd>
<dt>mo_energy: ndarray,</dt><dd><p>Diagonal elements of general Fock matrix</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray, for CASSCF only</span></dt><dd><p>Optimized CASSCF orbitals coefficients
Note the orbitals are NOT natural orbitals by default.  There are two
inbuilt methods to convert the mo_coeff to natural orbitals.
1. Set .natorb attribute.  It can be used before calculation.
2. call .cas_natorb_ method after the calculation to in-place convert the orbitals</p>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="casscf-active-space-solver">
<h2><span class="section-number">10.18.2. </span>CASSCF active space solver<a class="headerlink" href="#casscf-active-space-solver" title="Permalink to this headline">¶</a></h2>
<div class="section" id="dmrg-solver">
<h3><span class="section-number">10.18.2.1. </span>DMRG solver<a class="headerlink" href="#dmrg-solver" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="fciqmc-solver">
<h3><span class="section-number">10.18.2.2. </span>FCIQMC solver<a class="headerlink" href="#fciqmc-solver" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="state-average-fci-solver">
<h3><span class="section-number">10.18.2.3. </span>State-average FCI solver<a class="headerlink" href="#state-average-fci-solver" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="state-average-with-mixed-solver">
<h3><span class="section-number">10.18.2.4. </span>State-average with mixed solver<a class="headerlink" href="#state-average-with-mixed-solver" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="symmetry-broken">
<h2><span class="section-number">10.18.3. </span>Symmetry broken<a class="headerlink" href="#symmetry-broken" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="initial-guess">
<h2><span class="section-number">10.18.4. </span>Initial guess<a class="headerlink" href="#initial-guess" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="canonical-orbitals">
<h2><span class="section-number">10.18.5. </span>Canonical orbitals<a class="headerlink" href="#canonical-orbitals" title="Permalink to this headline">¶</a></h2>
<p>Orbital canonicalization are controlled by parameters <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.canonicalization</span></code>
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.natorb</span></code> (assuming the MCSCF object is <code class="docutils literal notranslate"><span class="pre">mc</span></code>). The order of
orbitals are affected by the parameter <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.sorting_mo_energy</span></code>.</p>
<ul class="simple">
<li><p>canonicalization:
This flag canonicalizes orbitals in core and external space using general Fock matrix.</p></li>
<li><p>natorb:
Transforms active orbitals using 1-particle density matrices.</p></li>
<li><p>sorting_mo_energy:
Sort orbitals based on the diagonal elements of the general Fock matrix.</p></li>
<li><p>Enabling natorb or sorting_mo_energy may slightly change the total energy
of DMRG solver or selected CI solver.</p></li>
</ul>
<p>General Fock matrix is defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{F} &amp;= \mathbf{h}_{core} + \mathbf{J} - \mathbf{K} \\
J_{pq} &amp;= \sum_{rs} (pq|rs) \gamma_{sr} \\
K_{pq} &amp;= \sum_{qr} (pq|rs) \gamma_{qr} \\\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\gamma\)</span> is the total density matrix which includes the doubly occupied
core density matrix and correlated density matrix in active space.</p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.canonicalization</span></code> is enabled, CASCI/CASSCF will call
the <code class="xref py py-func docutils literal notranslate"><span class="pre">mc.canonicalize()</span></code> function to diagonalize orbitals in
<strong>core space and external space</strong>. Orbitals in active space are not changed if
merely setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.canonicalization</span></code>. In the attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.mo_energy</span></code>, eigenvalues of general Fock matrix for core and external
subspaces are stored in the corresponding sub-sectors. The sector of active
space in <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.mo_energy</span></code> stores the expectation value of general Fock
<span class="math notranslate nohighlight">\(\langle \phi|F|\phi\rangle\)</span>.
By default, <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.canonicalization</span></code> is enabled because the canonicalized
MCSCF orbitals can simplify the implementations of MRPT (NEVPT2) methods.</p>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.natorb</span></code> controls whether the CASCI/CASSCF active space orbitals are
transformed to natural orbitals w.r.t. the correlated density matrix.  When this
parameter is enabled, the natural orbitals will be stored in the active part of
the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.mo_coeff</span></code> and the CI coefficients <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.ci</span></code> (if
applicable) will be transformed accordingly.
By default <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.natorb</span></code> is disabled because natural orbitals may not be
favored by total energy for an arbitrary CI solver. We make this default value
to ensure that a CASCI calculation followed by a CASSCF calculation (e.g.
DMRG-CASSCF then DMRG-CASCI) produces results same to the CASSCF results.
The CASCI calculation may produce different
The value of <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.natorb</span></code> does not affect (the default) FCI solver. But
this is not true for external large active space solvers such
as DMRG, selected CI methods. It is recommended to disable <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.natorb</span></code> in
these calculations.</p>
<p>Following presents what the <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.mo_coeff</span></code> would be like for different
combinations of <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.canonicalization</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.natorb</span></code> in a
CASCI calculation:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mc.canonicalization</span> <span class="pre">=</span> <span class="pre">False</span></code> and <code class="docutils literal notranslate"><span class="pre">mc.natorb</span> <span class="pre">=</span> <span class="pre">False</span></code>:</p></li>
</ul>
<p>The resultant orbitals <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.mo_coeff</span></code> are identical to the input orbitals.
If the CASCI was initialized with a RHF calculation,  <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.mo_coeff</span></code> points
to RHF orbitals.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mc.canonicalization</span> <span class="pre">=</span> <span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">mc.natorb</span> <span class="pre">=</span> <span class="pre">False</span></code>:</p></li>
</ul>
<p>Core part and external part of <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.mo_coeff</span></code> are canonicalized orbitals,
which diagonalize the core and external blocks of general Fock matrix.  The
orbitals in active space are identical to the active orbitals in the input.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mc.canonicalization</span> <span class="pre">=</span> <span class="pre">False</span></code> and <code class="docutils literal notranslate"><span class="pre">mc.natorb</span> <span class="pre">=</span> <span class="pre">True</span></code></p></li>
</ul>
<p>Core and external part of <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.mo_coeff</span></code> are identical to the core and
external part of the input orbitals.  Active space orbitals are transformed to
the natural orbitals of the correlated density matrix.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mc.canonicalization</span> <span class="pre">=</span> <span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">mc.natorb</span> <span class="pre">=</span> <span class="pre">True</span></code></p></li>
</ul>
<p><code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.mo_coeff</span></code> are completely different to the input orbitals.</p>
<p>Please note that elements of <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.mo_energy</span></code> may not be sorted ascendantly.
Parameter <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.sorting_mo_energy</span></code> can affect the ordering of MCSCF orbitals
<strong>when :attr:`mc.canonicalization` or :attr:`mc.natorb` is enabled</strong>.</p>
<p>By default, canonical orbitals in the core and external space
are sorted by the orbital energies (from low to high) and the natural orbitals
in the active space are sorted by natural occupations (from large to small).
If point group symmetry is enabled in the calculation, canonical orbitals are
sorted within each symmetry sector only (rather than the entire core or external
space). Irreducible representation labels (can be accessed via
<code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.mo_coeff.orbsym</span></code>) are assigned to orbitals in the initial
guess and they will not be changed in the MCSCF optimization and the subsequent
canonicalization procedure.  Setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.sorting_mo_energy</span></code> (though not
recommended) can force the orbitals to be sorted against energy (or occupations
in active space) regardless whether the point group symmetry is used.</p>
<p>In certain scenario, you may want to enable both <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.natorb</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.sorting_mo_energy</span></code>.
<code class="docutils literal notranslate"><span class="pre">examples/dmrg/31-cr2_scan/cr2-scan.py</span></code> provides one example that needs both
parameters. In that example, the dissociation curve of Cr dimer
was scanned using heat-bath selected-CI method in which the active space of
selected-CI-CASSCF was gradually enlarged in a series of CASSCF calculations.
Since the selected-CI algorithm depends on the initial single determinant, the
orbital ordering does matter to the final CASSCF results.
<code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.natorb</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">mc.sorting_mo_energy</span></code> have to be enabled to make
sure that the each selected-CI starts from the similar initial reference at
each point on the dissociation curve. Without these settings, the differences
in the orbital ordering can lead to discontinuous potential energy curve.</p>
</div>
<div class="section" id="program-reference">
<h2><span class="section-number">10.18.6. </span>Program reference<a class="headerlink" href="#program-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-pyscf.mcscf.casci">
<span id="casci"></span><h3><span class="section-number">10.18.6.1. </span>CASCI<a class="headerlink" href="#module-pyscf.mcscf.casci" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyscf.mcscf.casci.CASCI">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.mcscf.casci.</code><code class="sig-name descname">CASCI</code><span class="sig-paren">(</span><em class="sig-param">mf_or_mol</em>, <em class="sig-param">ncas</em>, <em class="sig-param">nelecas</em>, <em class="sig-param">ncore=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>mf_or_mol<span class="classifier">SCF object or Mole object</span></dt><dd><p>SCF or Mole to define the problem size.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Number of active orbitals.</p>
</dd>
<dt>nelecas<span class="classifier">int or a pair of int</span></dt><dd><p>Number of electrons in active space.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>ncore<span class="classifier">int</span></dt><dd><p>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</p>
</dd>
</dl>
</dd>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code>.</p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code>.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Active space size.</p>
</dd>
<dt>nelecas<span class="classifier">tuple of int</span></dt><dd><p>Active (nelec_alpha, nelec_beta)</p>
</dd>
<dt>ncore<span class="classifier">int or tuple of int</span></dt><dd><p>Core electron number.  In UHF-CASSCF, it’s a tuple to indicate the different core eletron numbers.</p>
</dd>
<dt>natorb<span class="classifier">bool</span></dt><dd><p>Whether to transform natural orbital in active space.  Be cautious
of this parameter when CASCI/CASSCF are combined with DMRG solver
or selected CI solver because DMRG and selected CI are not invariant
to the rotation in active space.
False by default.</p>
</dd>
<dt>canonicalization<span class="classifier">bool</span></dt><dd><p>Whether to canonicalize orbitals. Note that canonicalization does
not change the orbitals in active space by default. It only
diagonalizes core and external space of the general Fock matirx.
To get the natural orbitals in active space, attribute natorb
need to be enabled.
True by default.</p>
</dd>
<dt>sorting_mo_energy<span class="classifier">bool</span></dt><dd><p>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</p>
</dd>
<dt>fcisolver<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">FCISolver</span></code></span></dt><dd><p>The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal notranslate"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p>For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitls.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
<dt>mo_occ<span class="classifier">ndarray</span></dt><dd><p>Occupation numbers of natural orbitals if natorb is specified.</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.Gradients">
<code class="sig-name descname">Gradients</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.Gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-relativistic restricted Hartree-Fock gradients</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.ao2mo">
<code class="sig-name descname">ao2mo</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.ao2mo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.ao2mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the active space two-particle Hamiltonian.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.as_scanner">
<code class="sig-name descname">as_scanner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner for CASCI PES.</p>
<p>The returned solver is a function. This function requires one argument
“mol” as input and returns total CASCI energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters of MCSCF object
are automatically applied in the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, …) during calculation.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc_scanner</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.5&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.canonicalize">
<code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">eris=None</em>, <em class="sig-param">sort=False</em>, <em class="sig-param">cas_natorb=False</em>, <em class="sig-param">casdm1=None</em>, <em class="sig-param">verbose=3</em>, <em class="sig-param">with_meta_lowdin=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalized CASCI/CASSCF orbitals of effecitive Fock matrix and
update CI coefficients accordingly.</p>
<p>Effective Fock matrix is built with one-particle density matrix (see
also <code class="xref py py-func docutils literal notranslate"><span class="pre">mcscf.casci.get_fock()</span></code>). For state-average CASCI/CASSCF object,
the canonicalized orbitals are based on the state-average density matrix.
To obtain canonicalized orbitals for an individual state, you need to pass
“casdm1” of the specific state to this function.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc: a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_coeff (ndarray): orbitals that span the core, active and external</dt><dd><p>space.</p>
</dd>
<dt>ci (ndarray): CI coefficients (or objects to represent the CI</dt><dd><p>wavefunctions in DMRG/QMC-MCSCF calculations).</p>
</dd>
<dt>eris: Integrals for the MCSCF object. Input this object to reduce the</dt><dd><p>overhead of computing integrals. It can be generated by
<code class="xref py py-func docutils literal notranslate"><span class="pre">mc.ao2mo()</span></code> method.</p>
</dd>
<dt>sort (bool): Whether the canonicalized orbitals are sorted based on</dt><dd><p>the orbital energy (diagonal part of the effective Fock matrix)
within each subspace (core, active, external). If point group
symmetry is not available in the system, orbitals are always
sorted. When point group symmetry is available, sort=False will
preserve the symmetry label of input orbitals and only sort the
orbitals in each symmetry sector. sort=True will reorder all
orbitals over all symmetry sectors in each subspace and the
symmetry labels may be changed.</p>
</dd>
<dt>cas_natorb (bool): Whether to transform active orbitals to natual</dt><dd><p>orbitals. If enabled, the output orbitals in active space are
transformed to natural orbitals and CI coefficients are updated
accordingly.</p>
</dd>
<dt>casdm1 (ndarray): 1-particle density matrix in active space. This</dt><dd><p>density matrix is used to build effective fock matrix. Without
input casdm1, the density matrix is computed with the input ci
coefficients/object. If neither ci nor casdm1 were given, density
matrix is computed by <code class="xref py py-func docutils literal notranslate"><span class="pre">mc.fcisolver.make_rdm1()</span></code> method. For
state-average CASCI/CASCF calculation, this results in a set of
canonicalized orbitals of state-average effective Fock matrix.
To canonicalize the orbitals for one particular state, you can
assign the density matrix of that state to the kwarg casdm1.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple, (natural orbitals, CI coefficients, orbital energies)
The orbital energies are the diagonal terms of effective Fock matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.canonicalize_">
<code class="sig-name descname">canonicalize_</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">eris=None</em>, <em class="sig-param">sort=False</em>, <em class="sig-param">cas_natorb=False</em>, <em class="sig-param">casdm1=None</em>, <em class="sig-param">verbose=None</em>, <em class="sig-param">with_meta_lowdin=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.canonicalize_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.canonicalize_" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalized CASCI/CASSCF orbitals of effecitive Fock matrix and
update CI coefficients accordingly.</p>
<p>Effective Fock matrix is built with one-particle density matrix (see
also <code class="xref py py-func docutils literal notranslate"><span class="pre">mcscf.casci.get_fock()</span></code>). For state-average CASCI/CASSCF object,
the canonicalized orbitals are based on the state-average density matrix.
To obtain canonicalized orbitals for an individual state, you need to pass
“casdm1” of the specific state to this function.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc: a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_coeff (ndarray): orbitals that span the core, active and external</dt><dd><p>space.</p>
</dd>
<dt>ci (ndarray): CI coefficients (or objects to represent the CI</dt><dd><p>wavefunctions in DMRG/QMC-MCSCF calculations).</p>
</dd>
<dt>eris: Integrals for the MCSCF object. Input this object to reduce the</dt><dd><p>overhead of computing integrals. It can be generated by
<code class="xref py py-func docutils literal notranslate"><span class="pre">mc.ao2mo()</span></code> method.</p>
</dd>
<dt>sort (bool): Whether the canonicalized orbitals are sorted based on</dt><dd><p>the orbital energy (diagonal part of the effective Fock matrix)
within each subspace (core, active, external). If point group
symmetry is not available in the system, orbitals are always
sorted. When point group symmetry is available, sort=False will
preserve the symmetry label of input orbitals and only sort the
orbitals in each symmetry sector. sort=True will reorder all
orbitals over all symmetry sectors in each subspace and the
symmetry labels may be changed.</p>
</dd>
<dt>cas_natorb (bool): Whether to transform active orbitals to natual</dt><dd><p>orbitals. If enabled, the output orbitals in active space are
transformed to natural orbitals and CI coefficients are updated
accordingly.</p>
</dd>
<dt>casdm1 (ndarray): 1-particle density matrix in active space. This</dt><dd><p>density matrix is used to build effective fock matrix. Without
input casdm1, the density matrix is computed with the input ci
coefficients/object. If neither ci nor casdm1 were given, density
matrix is computed by <code class="xref py py-func docutils literal notranslate"><span class="pre">mc.fcisolver.make_rdm1()</span></code> method. For
state-average CASCI/CASCF calculation, this results in a set of
canonicalized orbitals of state-average effective Fock matrix.
To canonicalize the orbitals for one particular state, you can
assign the density matrix of that state to the kwarg casdm1.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple, (natural orbitals, CI coefficients, orbital energies)
The orbital energies are the diagonal terms of effective Fock matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.cas_natorb">
<code class="sig-name descname">cas_natorb</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">eris=None</em>, <em class="sig-param">sort=False</em>, <em class="sig-param">casdm1=None</em>, <em class="sig-param">verbose=None</em>, <em class="sig-param">with_meta_lowdin=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.cas_natorb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.cas_natorb" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform active orbitals to natrual orbitals, and update the CI wfn
accordingly</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc : a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>sort<span class="classifier">bool</span></dt><dd><p>Sort natural orbitals wrt the occupancy.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple, the first item is natural orbitals, the second is updated CI
coefficients, the third is the natural occupancy associated to the
natural orbitals.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.cas_natorb_">
<code class="sig-name descname">cas_natorb_</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">eris=None</em>, <em class="sig-param">sort=False</em>, <em class="sig-param">casdm1=None</em>, <em class="sig-param">verbose=None</em>, <em class="sig-param">with_meta_lowdin=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.cas_natorb_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.cas_natorb_" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform active orbitals to natrual orbitals, and update the CI wfn
accordingly</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc : a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>sort<span class="classifier">bool</span></dt><dd><p>Sort natural orbitals wrt the occupancy.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple, the first item is natural orbitals, the second is updated CI
coefficients, the third is the natural occupancy associated to the
natural orbitals.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.fix_spin">
<code class="sig-name descname">fix_spin</code><span class="sig-paren">(</span><em class="sig-param">shift=0.2</em>, <em class="sig-param">ss=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.fix_spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Use level shift to control FCI solver spin.</p>
<div class="math notranslate nohighlight">
\[(H + shift*S^2) |\Psi\rangle = E |\Psi\rangle\]</div>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shift<span class="classifier">float</span></dt><dd><p>Energy penalty for states which have wrong spin</p>
</dd>
<dt>ss<span class="classifier">number</span></dt><dd><p>S^2 expection value == s*(s+1)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.fix_spin_">
<code class="sig-name descname">fix_spin_</code><span class="sig-paren">(</span><em class="sig-param">shift=0.2</em>, <em class="sig-param">ss=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.fix_spin_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.fix_spin_" title="Permalink to this definition">¶</a></dt>
<dd><p>Use level shift to control FCI solver spin.</p>
<div class="math notranslate nohighlight">
\[(H + shift*S^2) |\Psi\rangle = E |\Psi\rangle\]</div>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shift<span class="classifier">float</span></dt><dd><p>Energy penalty for states which have wrong spin</p>
</dd>
<dt>ss<span class="classifier">number</span></dt><dd><p>S^2 expection value == s*(s+1)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.get_h1cas">
<code class="sig-name descname">get_h1cas</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ncas=None</em>, <em class="sig-param">ncore=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.get_h1cas" title="Permalink to this definition">¶</a></dt>
<dd><p>CAS sapce one-electron hamiltonian</p>
<dl class="simple">
<dt>Args:</dt><dd><p>casci : a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Returns:</dt><dd><p>A tuple, the first is the effective one-electron hamiltonian defined in CAS space,
the second is the electronic energy from core.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.get_h1eff">
<code class="sig-name descname">get_h1eff</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ncas=None</em>, <em class="sig-param">ncore=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.get_h1eff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.get_h1eff" title="Permalink to this definition">¶</a></dt>
<dd><p>CAS sapce one-electron hamiltonian</p>
<dl class="simple">
<dt>Args:</dt><dd><p>casci : a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Returns:</dt><dd><p>A tuple, the first is the effective one-electron hamiltonian defined in CAS space,
the second is the electronic energy from core.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.get_h2cas">
<code class="sig-name descname">get_h2cas</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.get_h2cas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.get_h2cas" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the active space two-particle Hamiltonian.</p>
<p>Note It is different to get_h2eff when df.approx_hessian is applied,
in which get_h2eff function returns the DF integrals while get_h2cas
returns the regular 2-electron integrals.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.get_h2eff">
<code class="sig-name descname">get_h2eff</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.get_h2eff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.get_h2eff" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the active space two-particle Hamiltonian.</p>
<p>Note It is different to get_h2cas when df.approx_hessian is applied.
in which get_h2eff function returns the DF integrals while get_h2cas
returns the regular 2-electron integrals.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.get_jk">
<code class="sig-name descname">get_jk</code><span class="sig-paren">(</span><em class="sig-param">mol</em>, <em class="sig-param">dm</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">with_j=True</em>, <em class="sig-param">with_k=True</em>, <em class="sig-param">omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
<dt>with_j<span class="classifier">boolean</span></dt><dd><p>Whether to compute J matrices</p>
</dd>
<dt>with_k<span class="classifier">boolean</span></dt><dd><p>Whether to compute K matrices</p>
</dd>
<dt>omega<span class="classifier">float</span></dt><dd><p>Parameter of range-seperated Coulomb operator: erf( omega * r12 ) / r12.
If specified, integration are evaluated based on the long-range
part of the range-seperated Coulomb operator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">hermi=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>dm_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</p>
</dd>
<dt>vhf_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The reference HF potential matrix.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf0</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">dm_last</span><span class="o">=</span><span class="n">dm0</span><span class="p">,</span> <span class="n">vhf_last</span><span class="o">=</span><span class="n">vhf0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vhf1</span><span class="p">,</span> <span class="n">vhf2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.h1e_for_cas">
<code class="sig-name descname">h1e_for_cas</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ncas=None</em>, <em class="sig-param">ncore=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.h1e_for_cas" title="Permalink to this definition">¶</a></dt>
<dd><p>CAS sapce one-electron hamiltonian</p>
<dl class="simple">
<dt>Args:</dt><dd><p>casci : a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Returns:</dt><dd><p>A tuple, the first is the effective one-electron hamiltonian defined in CAS space,
the second is the electronic energy from core.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci0=None</em>, <em class="sig-param">verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.kernel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns:</dt><dd><p>Five elements, they are
total energy,
active space CI energy,
the active space FCI wavefunction coefficients or DMRG wavefunction ID,
the MCSCF canonical orbital coefficients,
the MCSCF canonical orbital coefficients.</p>
</dd>
</dl>
<p>They are attributes of mcscf object, which can be accessed by
.e_tot, .e_cas, .ci, .mo_coeff, .mo_energy</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">ncas=None</em>, <em class="sig-param">nelecas=None</em>, <em class="sig-param">ncore=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix in AO representation</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.make_rdm1s">
<code class="sig-name descname">make_rdm1s</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">ncas=None</em>, <em class="sig-param">nelecas=None</em>, <em class="sig-param">ncore=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.make_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.make_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrices for alpha and beta spin on AO basis</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.sort_mo">
<code class="sig-name descname">sort_mo</code><span class="sig-paren">(</span><em class="sig-param">caslst</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">base=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.sort_mo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.sort_mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick orbitals for CAS space</p>
<dl>
<dt>Args:</dt><dd><p>casscf : an <code class="xref py py-class docutils literal notranslate"><span class="pre">CASSCF</span></code> or <a class="reference internal" href="#pyscf.mcscf.casci.CASCI" title="pyscf.mcscf.casci.CASCI"><code class="xref py py-class docutils literal notranslate"><span class="pre">CASCI</span></code></a> object</p>
<dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray or a list of ndarray</span></dt><dd><p>Orbitals for CASSCF initial guess.  In the UHF-CASSCF, it’s a list
of two orbitals, for alpha and beta spin.</p>
</dd>
<dt>caslst<span class="classifier">list of int or nested list of int</span></dt><dd><p>A list of orbital indices to represent the CAS space.  In the UHF-CASSCF,
it’s consist of two lists, for alpha and beta spin.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>base<span class="classifier">int</span></dt><dd><p>0-based (C-style) or 1-based (Fortran-style) caslst</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>An reoreded mo_coeff, which put the orbitals given by caslst in the CAS space</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cas_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="c1"># pi orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">sort_mo</span><span class="p">(</span><span class="n">cas_list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mo</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.007378939813691</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.state_average">
<code class="sig-name descname">state_average</code><span class="sig-paren">(</span><em class="sig-param">weights=(0.5</em>, <em class="sig-param">0.5)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.state_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.state_average" title="Permalink to this definition">¶</a></dt>
<dd><p>State average over the energy.  The energy funcitonal is
E = w1&lt;psi1|H|psi1&gt; + w2&lt;psi2|H|psi2&gt; + …</p>
<p>Note we may need change the FCI solver to</p>
<p>mc.fcisolver = fci.solver(mol, False)</p>
<p>before calling state_average_(mc), to mix the singlet and triplet states</p>
<p>MRH, 04/08/2019: Instead of turning casscf._finalize into an instance attribute
that points to the previous casscf object, I’m going to make a whole new child class.
This will have the added benefit of making state_average and <a href="#id1"><span class="problematic" id="id2">state_average_</span></a>
actually behave differently for the first time (until now they <em>both</em> modified the
casscf object inplace). I’m also going to assign the weights argument as a member
of the mc child class because an accurate second-order CASSCF algorithm for state-averaged
calculations requires that the gradient and Hessian be computed for CI vectors of each root
individually and then multiplied by that root’s weight. The second derivatives computed
by newton_casscf.py need to be extended to state-averaged calculations in order to be
used as intermediates for calculations of the gradient of a single root in the context
of the SA-CASSCF method; see: Mol. Phys. 99, 103 (2001).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.state_average_">
<code class="sig-name descname">state_average_</code><span class="sig-paren">(</span><em class="sig-param">weights=(0.5</em>, <em class="sig-param">0.5)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.state_average_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.state_average_" title="Permalink to this definition">¶</a></dt>
<dd><p>State average over the energy.  The energy funcitonal is
E = w1&lt;psi1|H|psi1&gt; + w2&lt;psi2|H|psi2&gt; + …</p>
<p>Note we may need change the FCI solver to</p>
<p>mc.fcisolver = fci.solver(mol, False)</p>
<p>before calling state_average_(mc), to mix the singlet and triplet states</p>
<p>MRH, 04/08/2019: Instead of turning casscf._finalize into an instance attribute
that points to the previous casscf object, I’m going to make a whole new child class.
This will have the added benefit of making state_average and <a href="#id3"><span class="problematic" id="id4">state_average_</span></a>
actually behave differently for the first time (until now they <em>both</em> modified the
casscf object inplace). I’m also going to assign the weights argument as a member
of the mc child class because an accurate second-order CASSCF algorithm for state-averaged
calculations requires that the gradient and Hessian be computed for CI vectors of each root
individually and then multiplied by that root’s weight. The second derivatives computed
by newton_casscf.py need to be extended to state-averaged calculations in order to be
used as intermediates for calculations of the gradient of a single root in the context
of the SA-CASSCF method; see: Mol. Phys. 99, 103 (2001).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci.CASCI.state_specific_">
<code class="sig-name descname">state_specific_</code><span class="sig-paren">(</span><em class="sig-param">state=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#CASCI.state_specific_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.CASCI.state_specific_" title="Permalink to this definition">¶</a></dt>
<dd><p>For excited state</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>state : int
0 for ground state; 1 for first excited state.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.casci.as_scanner">
<code class="sig-prename descclassname">pyscf.mcscf.casci.</code><code class="sig-name descname">as_scanner</code><span class="sig-paren">(</span><em class="sig-param">mc</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#as_scanner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner for CASCI PES.</p>
<p>The returned solver is a function. This function requires one argument
“mol” as input and returns total CASCI energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters of MCSCF object
are automatically applied in the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, …) during calculation.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc_scanner</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.5&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.casci.canonicalize">
<code class="sig-prename descclassname">pyscf.mcscf.casci.</code><code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param">mc</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">eris=None</em>, <em class="sig-param">sort=False</em>, <em class="sig-param">cas_natorb=False</em>, <em class="sig-param">casdm1=None</em>, <em class="sig-param">verbose=3</em>, <em class="sig-param">with_meta_lowdin=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#canonicalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalized CASCI/CASSCF orbitals of effecitive Fock matrix and
update CI coefficients accordingly.</p>
<p>Effective Fock matrix is built with one-particle density matrix (see
also <code class="xref py py-func docutils literal notranslate"><span class="pre">mcscf.casci.get_fock()</span></code>). For state-average CASCI/CASSCF object,
the canonicalized orbitals are based on the state-average density matrix.
To obtain canonicalized orbitals for an individual state, you need to pass
“casdm1” of the specific state to this function.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc: a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_coeff (ndarray): orbitals that span the core, active and external</dt><dd><p>space.</p>
</dd>
<dt>ci (ndarray): CI coefficients (or objects to represent the CI</dt><dd><p>wavefunctions in DMRG/QMC-MCSCF calculations).</p>
</dd>
<dt>eris: Integrals for the MCSCF object. Input this object to reduce the</dt><dd><p>overhead of computing integrals. It can be generated by
<code class="xref py py-func docutils literal notranslate"><span class="pre">mc.ao2mo()</span></code> method.</p>
</dd>
<dt>sort (bool): Whether the canonicalized orbitals are sorted based on</dt><dd><p>the orbital energy (diagonal part of the effective Fock matrix)
within each subspace (core, active, external). If point group
symmetry is not available in the system, orbitals are always
sorted. When point group symmetry is available, sort=False will
preserve the symmetry label of input orbitals and only sort the
orbitals in each symmetry sector. sort=True will reorder all
orbitals over all symmetry sectors in each subspace and the
symmetry labels may be changed.</p>
</dd>
<dt>cas_natorb (bool): Whether to transform active orbitals to natual</dt><dd><p>orbitals. If enabled, the output orbitals in active space are
transformed to natural orbitals and CI coefficients are updated
accordingly.</p>
</dd>
<dt>casdm1 (ndarray): 1-particle density matrix in active space. This</dt><dd><p>density matrix is used to build effective fock matrix. Without
input casdm1, the density matrix is computed with the input ci
coefficients/object. If neither ci nor casdm1 were given, density
matrix is computed by <code class="xref py py-func docutils literal notranslate"><span class="pre">mc.fcisolver.make_rdm1()</span></code> method. For
state-average CASCI/CASCF calculation, this results in a set of
canonicalized orbitals of state-average effective Fock matrix.
To canonicalize the orbitals for one particular state, you can
assign the density matrix of that state to the kwarg casdm1.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple, (natural orbitals, CI coefficients, orbital energies)
The orbital energies are the diagonal terms of effective Fock matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.casci.cas_natorb">
<code class="sig-prename descclassname">pyscf.mcscf.casci.</code><code class="sig-name descname">cas_natorb</code><span class="sig-paren">(</span><em class="sig-param">mc</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">eris=None</em>, <em class="sig-param">sort=False</em>, <em class="sig-param">casdm1=None</em>, <em class="sig-param">verbose=None</em>, <em class="sig-param">with_meta_lowdin=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#cas_natorb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.cas_natorb" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform active orbitals to natrual orbitals, and update the CI wfn
accordingly</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc : a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>sort<span class="classifier">bool</span></dt><dd><p>Sort natural orbitals wrt the occupancy.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple, the first item is natural orbitals, the second is updated CI
coefficients, the third is the natural occupancy associated to the
natural orbitals.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.casci.get_fock">
<code class="sig-prename descclassname">pyscf.mcscf.casci.</code><code class="sig-name descname">get_fock</code><span class="sig-paren">(</span><em class="sig-param">mc</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">eris=None</em>, <em class="sig-param">casdm1=None</em>, <em class="sig-param">verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#get_fock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.get_fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Effective one-electron Fock matrix in AO representation
f = sum_{pq} E_{pq} F_{pq}
F_{pq} = h_{pq} + sum_{rs} [(pq|rs)-(ps|rq)] DM_{sr}</p>
<p>Ref.
Theor. Chim. Acta., 91, 31
Chem. Phys. 48, 157</p>
<p>For state-average CASCI/CASSCF object, the effective fock matrix is based
on the state-average density matrix.  To obtain Fock matrix of a specific
state in the state-average calculations, you can pass “casdm1” of the
specific state to this function.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc: a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_coeff (ndarray): orbitals that span the core, active and external</dt><dd><p>space.</p>
</dd>
<dt>ci (ndarray): CI coefficients (or objects to represent the CI</dt><dd><p>wavefunctions in DMRG/QMC-MCSCF calculations).</p>
</dd>
<dt>eris: Integrals for the MCSCF object. Input this object to reduce the</dt><dd><p>overhead of computing integrals. It can be generated by
<code class="xref py py-func docutils literal notranslate"><span class="pre">mc.ao2mo()</span></code> method.</p>
</dd>
<dt>casdm1 (ndarray): 1-particle density matrix in active space. Without</dt><dd><p>input casdm1, the density matrix is computed with the input ci
coefficients/object. If neither ci nor casdm1 were given, density
matrix is computed by <code class="xref py py-func docutils literal notranslate"><span class="pre">mc.fcisolver.make_rdm1()</span></code> method. For
state-average CASCI/CASCF calculation, this results in the
effective Fock matrix based on the state-average density matrix.
To obtain the effective Fock matrix for one particular state, you
can assign the density matrix of that state to the kwarg casdm1.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Fock matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.casci.h1e_for_cas">
<code class="sig-prename descclassname">pyscf.mcscf.casci.</code><code class="sig-name descname">h1e_for_cas</code><span class="sig-paren">(</span><em class="sig-param">casci</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ncas=None</em>, <em class="sig-param">ncore=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#h1e_for_cas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.h1e_for_cas" title="Permalink to this definition">¶</a></dt>
<dd><p>CAS sapce one-electron hamiltonian</p>
<dl class="simple">
<dt>Args:</dt><dd><p>casci : a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Returns:</dt><dd><p>A tuple, the first is the effective one-electron hamiltonian defined in CAS space,
the second is the electronic energy from core.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.casci.kernel">
<code class="sig-prename descclassname">pyscf.mcscf.casci.</code><code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">casci</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci0=None</em>, <em class="sig-param">verbose=3</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci.html#kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>CASCI solver</p>
</dd></dl>

<span class="target" id="module-pyscf.mcscf.casci_symm"></span><dl class="attribute">
<dt id="pyscf.mcscf.casci_symm.CASCI">
<code class="sig-prename descclassname">pyscf.mcscf.casci_symm.</code><code class="sig-name descname">CASCI</code><a class="headerlink" href="#pyscf.mcscf.casci_symm.CASCI" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.mcscf.casci_symm.SymAdaptedCASCI" title="pyscf.mcscf.casci_symm.SymAdaptedCASCI"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.mcscf.casci_symm.SymAdaptedCASCI</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pyscf.mcscf.casci_symm.SymAdaptedCASCI">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.mcscf.casci_symm.</code><code class="sig-name descname">SymAdaptedCASCI</code><span class="sig-paren">(</span><em class="sig-param">mf_or_mol</em>, <em class="sig-param">ncas</em>, <em class="sig-param">nelecas</em>, <em class="sig-param">ncore=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci_symm.html#SymAdaptedCASCI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci_symm.SymAdaptedCASCI" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyscf.mcscf.casci_symm.SymAdaptedCASCI.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci0=None</em>, <em class="sig-param">verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci_symm.html#SymAdaptedCASCI.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci_symm.SymAdaptedCASCI.kernel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns:</dt><dd><p>Five elements, they are
total energy,
active space CI energy,
the active space FCI wavefunction coefficients or DMRG wavefunction ID,
the MCSCF canonical orbital coefficients,
the MCSCF canonical orbital coefficients.</p>
</dd>
</dl>
<p>They are attributes of mcscf object, which can be accessed by
.e_tot, .e_cas, .ci, .mo_coeff, .mo_energy</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.casci_symm.SymAdaptedCASCI.sort_mo_by_irrep">
<code class="sig-name descname">sort_mo_by_irrep</code><span class="sig-paren">(</span><em class="sig-param">cas_irrep_nocc</em>, <em class="sig-param">cas_irrep_ncore=None</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/casci_symm.html#SymAdaptedCASCI.sort_mo_by_irrep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.casci_symm.SymAdaptedCASCI.sort_mo_by_irrep" title="Permalink to this definition">¶</a></dt>
<dd><p>Select active space based on symmetry information.
See also <a class="reference internal" href="#pyscf.mcscf.addons.sort_mo_by_irrep" title="pyscf.mcscf.addons.sort_mo_by_irrep"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyscf.mcscf.addons.sort_mo_by_irrep()</span></code></a></p>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyscf.mcscf.ucasci"></span><p>UCASCI (CASCI with non-degenerated alpha and beta orbitals, typically UHF
orbitals)</p>
<dl class="attribute">
<dt id="pyscf.mcscf.ucasci.CASCI">
<code class="sig-prename descclassname">pyscf.mcscf.ucasci.</code><code class="sig-name descname">CASCI</code><a class="headerlink" href="#pyscf.mcscf.ucasci.CASCI" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.mcscf.ucasci.UCASCI" title="pyscf.mcscf.ucasci.UCASCI"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.mcscf.ucasci.UCASCI</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pyscf.mcscf.ucasci.UCASCI">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.mcscf.ucasci.</code><code class="sig-name descname">UCASCI</code><span class="sig-paren">(</span><em class="sig-param">mf_or_mol</em>, <em class="sig-param">ncas</em>, <em class="sig-param">nelecas</em>, <em class="sig-param">ncore=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#UCASCI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.ao2mo">
<code class="sig-name descname">ao2mo</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#UCASCI.ao2mo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.ao2mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the active space two-particle Hamiltonian.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.cas_natorb">
<code class="sig-name descname">cas_natorb</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci0=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#UCASCI.cas_natorb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.cas_natorb" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform active orbitals to natrual orbitals, and update the CI wfn
accordingly</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc : a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>sort<span class="classifier">bool</span></dt><dd><p>Sort natural orbitals wrt the occupancy.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple, the first item is natural orbitals, the second is updated CI
coefficients, the third is the natural occupancy associated to the
natural orbitals.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.cas_natorb_">
<code class="sig-name descname">cas_natorb_</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci0=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#UCASCI.cas_natorb_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.cas_natorb_" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform active orbitals to natrual orbitals, and update the CI wfn
accordingly</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc : a CASSCF/CASCI object or RHF object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>sort<span class="classifier">bool</span></dt><dd><p>Sort natural orbitals wrt the occupancy.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple, the first item is natural orbitals, the second is updated CI
coefficients, the third is the natural occupancy associated to the
natural orbitals.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.get_h1cas">
<code class="sig-name descname">get_h1cas</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ncas=None</em>, <em class="sig-param">ncore=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.get_h1cas" title="Permalink to this definition">¶</a></dt>
<dd><p>CAS sapce one-electron hamiltonian for UHF-CASCI or UHF-CASSCF</p>
<dl class="simple">
<dt>Args:</dt><dd><p>casci : a U-CASSCF/U-CASCI object or UHF object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.get_h1eff">
<code class="sig-name descname">get_h1eff</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ncas=None</em>, <em class="sig-param">ncore=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#UCASCI.get_h1eff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.get_h1eff" title="Permalink to this definition">¶</a></dt>
<dd><p>CAS sapce one-electron hamiltonian for UHF-CASCI or UHF-CASSCF</p>
<dl class="simple">
<dt>Args:</dt><dd><p>casci : a U-CASSCF/U-CASCI object or UHF object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.get_h2cas">
<code class="sig-name descname">get_h2cas</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#UCASCI.get_h2cas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.get_h2cas" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the active space two-particle Hamiltonian.</p>
<p>Note It is different to get_h2eff when df.approx_hessian is applied,
in which get_h2eff function returns the DF integrals while get_h2cas
returns the regular 2-electron integrals.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.get_h2eff">
<code class="sig-name descname">get_h2eff</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#UCASCI.get_h2eff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.get_h2eff" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the active space two-particle Hamiltonian.</p>
<p>Note It is different to get_h2cas when df.approx_hessian is applied.
in which get_h2eff function returns the DF integrals while get_h2cas
returns the regular 2-electron integrals.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">hermi=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#UCASCI.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>dm_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</p>
</dd>
<dt>vhf_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The reference HF potential matrix.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf0</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">dm_last</span><span class="o">=</span><span class="n">dm0</span><span class="p">,</span> <span class="n">vhf_last</span><span class="o">=</span><span class="n">vhf0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vhf1</span><span class="p">,</span> <span class="n">vhf2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.h1e_for_cas">
<code class="sig-name descname">h1e_for_cas</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ncas=None</em>, <em class="sig-param">ncore=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.h1e_for_cas" title="Permalink to this definition">¶</a></dt>
<dd><p>CAS sapce one-electron hamiltonian for UHF-CASCI or UHF-CASSCF</p>
<dl class="simple">
<dt>Args:</dt><dd><p>casci : a U-CASSCF/U-CASCI object or UHF object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci0=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#UCASCI.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.kernel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns:</dt><dd><p>Five elements, they are
total energy,
active space CI energy,
the active space FCI wavefunction coefficients or DMRG wavefunction ID,
the MCSCF canonical orbital coefficients,
the MCSCF canonical orbital coefficients.</p>
</dd>
</dl>
<p>They are attributes of mcscf object, which can be accessed by
.e_tot, .e_cas, .ci, .mo_coeff, .mo_energy</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">ncas=None</em>, <em class="sig-param">nelecas=None</em>, <em class="sig-param">ncore=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#UCASCI.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix in AO representation</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.make_rdm1s">
<code class="sig-name descname">make_rdm1s</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">ncas=None</em>, <em class="sig-param">nelecas=None</em>, <em class="sig-param">ncore=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#UCASCI.make_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.make_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrices for alpha and beta spin on AO basis</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.ucasci.UCASCI.sort_mo">
<code class="sig-name descname">sort_mo</code><span class="sig-paren">(</span><em class="sig-param">caslst</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">base=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#UCASCI.sort_mo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.UCASCI.sort_mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick orbitals for CAS space</p>
<dl>
<dt>Args:</dt><dd><p>casscf : an <code class="xref py py-class docutils literal notranslate"><span class="pre">CASSCF</span></code> or <a class="reference internal" href="#pyscf.mcscf.ucasci.CASCI" title="pyscf.mcscf.ucasci.CASCI"><code class="xref py py-class docutils literal notranslate"><span class="pre">CASCI</span></code></a> object</p>
<dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray or a list of ndarray</span></dt><dd><p>Orbitals for CASSCF initial guess.  In the UHF-CASSCF, it’s a list
of two orbitals, for alpha and beta spin.</p>
</dd>
<dt>caslst<span class="classifier">list of int or nested list of int</span></dt><dd><p>A list of orbital indices to represent the CAS space.  In the UHF-CASSCF,
it’s consist of two lists, for alpha and beta spin.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>base<span class="classifier">int</span></dt><dd><p>0-based (C-style) or 1-based (Fortran-style) caslst</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>An reoreded mo_coeff, which put the orbitals given by caslst in the CAS space</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cas_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="c1"># pi orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">sort_mo</span><span class="p">(</span><span class="n">cas_list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mo</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.007378939813691</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.ucasci.h1e_for_cas">
<code class="sig-prename descclassname">pyscf.mcscf.ucasci.</code><code class="sig-name descname">h1e_for_cas</code><span class="sig-paren">(</span><em class="sig-param">casci</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ncas=None</em>, <em class="sig-param">ncore=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#h1e_for_cas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.h1e_for_cas" title="Permalink to this definition">¶</a></dt>
<dd><p>CAS sapce one-electron hamiltonian for UHF-CASCI or UHF-CASSCF</p>
<dl class="simple">
<dt>Args:</dt><dd><p>casci : a U-CASSCF/U-CASCI object or UHF object</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.ucasci.kernel">
<code class="sig-prename descclassname">pyscf.mcscf.ucasci.</code><code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">casci</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci0=None</em>, <em class="sig-param">verbose=3</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/ucasci.html#kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.ucasci.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>UHF-CASCI solver</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.mcscf.mc1step">
<span id="casscf"></span><h3><span class="section-number">10.18.6.2. </span>CASSCF<a class="headerlink" href="#module-pyscf.mcscf.mc1step" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyscf.mcscf.mc1step.CASSCF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.mcscf.mc1step.</code><code class="sig-name descname">CASSCF</code><span class="sig-paren">(</span><em class="sig-param">mf_or_mol</em>, <em class="sig-param">ncas</em>, <em class="sig-param">nelecas</em>, <em class="sig-param">ncore=None</em>, <em class="sig-param">frozen=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step.html#CASSCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step.CASSCF" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>mf_or_mol<span class="classifier">SCF object or Mole object</span></dt><dd><p>SCF or Mole to define the problem size.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Number of active orbitals.</p>
</dd>
<dt>nelecas<span class="classifier">int or a pair of int</span></dt><dd><p>Number of electrons in active space.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>ncore<span class="classifier">int</span></dt><dd><p>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</p>
</dd>
</dl>
</dd>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code>.</p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code>.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Active space size.</p>
</dd>
<dt>nelecas<span class="classifier">tuple of int</span></dt><dd><p>Active (nelec_alpha, nelec_beta)</p>
</dd>
<dt>ncore<span class="classifier">int or tuple of int</span></dt><dd><p>Core electron number.  In UHF-CASSCF, it’s a tuple to indicate the different core eletron numbers.</p>
</dd>
<dt>natorb<span class="classifier">bool</span></dt><dd><p>Whether to transform natural orbital in active space.  Be cautious
of this parameter when CASCI/CASSCF are combined with DMRG solver
or selected CI solver because DMRG and selected CI are not invariant
to the rotation in active space.
False by default.</p>
</dd>
<dt>canonicalization<span class="classifier">bool</span></dt><dd><p>Whether to canonicalize orbitals. Note that canonicalization does
not change the orbitals in active space by default. It only
diagonalizes core and external space of the general Fock matirx.
To get the natural orbitals in active space, attribute natorb
need to be enabled.
True by default.</p>
</dd>
<dt>sorting_mo_energy<span class="classifier">bool</span></dt><dd><p>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</p>
</dd>
<dt>fcisolver<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">FCISolver</span></code></span></dt><dd><p>The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal notranslate"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p>For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitls.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
<dt>mo_occ<span class="classifier">ndarray</span></dt><dd><p>Occupation numbers of natural orbitals if natorb is specified.</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
<span class="go">CASSCF</span>
</pre></div>
</div>
<p>Extra attributes for CASSCF:</p>
<blockquote>
<div><dl>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Converge threshold.  Default is 1e-7</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>Converge threshold for CI gradients and orbital rotation gradients.
Default is 1e-4</p>
</dd>
<dt>max_stepsize<span class="classifier">float</span></dt><dd><p>The step size for orbital rotation.  Small step (0.005 - 0.05) is prefered.
Default is 0.03.</p>
</dd>
<dt>max_cycle_macro<span class="classifier">int</span></dt><dd><p>Max number of macro iterations.  Default is 50.</p>
</dd>
<dt>max_cycle_micro<span class="classifier">int</span></dt><dd><p>Max number of micro iterations in each macro iteration.  Depending on
systems, increasing this value might reduce the total macro
iterations.  Generally, 2 - 5 steps should be enough.  Default is 3.</p>
</dd>
<dt>ah_level_shift<span class="classifier">float, for AH solver.</span></dt><dd><p>Level shift for the Davidson diagonalization in AH solver.  Default is 1e-8.</p>
</dd>
<dt>ah_conv_tol<span class="classifier">float, for AH solver.</span></dt><dd><p>converge threshold for AH solver.  Default is 1e-12.</p>
</dd>
<dt>ah_max_cycle<span class="classifier">float, for AH solver.</span></dt><dd><p>Max number of iterations allowd in AH solver.  Default is 30.</p>
</dd>
<dt>ah_lindep<span class="classifier">float, for AH solver.</span></dt><dd><p>Linear dependence threshold for AH solver.  Default is 1e-14.</p>
</dd>
<dt>ah_start_tol<span class="classifier">flat, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 0.2.</p>
</dd>
<dt>ah_start_cycle<span class="classifier">int, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 2.</p>
<p><code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_max_cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_start_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_start_cycle</span></code>
can affect the accuracy and performance of CASSCF solver.  Lower
<code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code> might improve the accuracy of CASSCF
optimization, but decrease the performance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401898486001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401887945668</span>
</pre></div>
</div>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>Checkpoint file to save the intermediate orbitals during the CASSCF optimization.
Default is the checkpoint file of mean field object.</p>
</dd>
<dt>ci_response_space<span class="classifier">int</span></dt><dd><p>subspace size to solve the CI vector response.  Default is 3.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</p>
</dd>
<dt>scale_restoration<span class="classifier">float</span></dt><dd><p>When a step of orbital rotation moves out of trust region, the
orbital optimization will be restored to previous state and the
step size of the orbital rotation needs to be reduced.
scale_restoration controls how much to scale down the step size.</p>
</dd>
</dl>
</div></blockquote>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>Optimized CASSCF orbitals coefficients. When canonicalization is
specified, the returned orbitals make the general Fock matrix
(Fock operator on top of MCSCF 1-particle density matrix)
diagonalized within each subspace (core, active, external).
If natorb (natural orbitals in active space) is specified,
the active segment of the mo_coeff is natural orbitls.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401882238134</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.mcscf.mc1step.CASSCF.Gradients">
<code class="sig-name descname">Gradients</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcscf.mc1step.CASSCF.Gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-relativistic restricted Hartree-Fock gradients</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.mc1step.CASSCF.ao2mo">
<code class="sig-name descname">ao2mo</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step.html#CASSCF.ao2mo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step.CASSCF.ao2mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the active space two-particle Hamiltonian.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.mc1step.CASSCF.as_scanner">
<code class="sig-name descname">as_scanner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcscf.mc1step.CASSCF.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner for CASSCF PES.</p>
<p>The returned solver is a function. This function requires one argument
“mol” as input and returns total CASSCF energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters of MCSCF object
(conv_tol, max_memory etc) are automatically applied in the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, …) during calculation.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.2&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc_scanner</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">mc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">mc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.5&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.mc1step.CASSCF.get_grad">
<code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">casdm1_casdm2=None</em>, <em class="sig-param">eris=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step.html#CASSCF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step.CASSCF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Orbital gradients</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.mc1step.CASSCF.get_h2cas">
<code class="sig-name descname">get_h2cas</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step.html#CASSCF.get_h2cas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step.CASSCF.get_h2cas" title="Permalink to this definition">¶</a></dt>
<dd><p>Computing active space two-particle Hamiltonian.</p>
<p>Note It is different to get_h2eff when df.approx_hessian is applied,
in which get_h2eff function returns the DF integrals while get_h2cas
returns the regular 2-electron integrals.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.mc1step.CASSCF.get_h2eff">
<code class="sig-name descname">get_h2eff</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step.html#CASSCF.get_h2eff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step.CASSCF.get_h2eff" title="Permalink to this definition">¶</a></dt>
<dd><p>Computing active space two-particle Hamiltonian.</p>
<p>Note It is different to get_h2cas when df.approx_hessian is applied,
in which get_h2eff function returns the DF integrals while get_h2cas
returns the regular 2-electron integrals.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.mc1step.CASSCF.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci0=None</em>, <em class="sig-param">callback=None</em>, <em class="sig-param">_kern=&lt;function kernel&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step.html#CASSCF.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step.CASSCF.kernel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns:</dt><dd><p>Five elements, they are
total energy,
active space CI energy,
the active space FCI wavefunction coefficients or DMRG wavefunction ID,
the MCSCF canonical orbital coefficients,
the MCSCF canonical orbital coefficients.</p>
</dd>
</dl>
<p>They are attributes of mcscf object, which can be accessed by
.e_tot, .e_cas, .ci, .mo_coeff, .mo_energy</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.mc1step.CASSCF.rotate_mo">
<code class="sig-name descname">rotate_mo</code><span class="sig-paren">(</span><em class="sig-param">mo</em>, <em class="sig-param">u</em>, <em class="sig-param">log=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step.html#CASSCF.rotate_mo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step.CASSCF.rotate_mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate orbitals with the given unitary matrix</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.mc1step.CASSCF.solve_approx_ci">
<code class="sig-name descname">solve_approx_ci</code><span class="sig-paren">(</span><em class="sig-param">h1</em>, <em class="sig-param">h2</em>, <em class="sig-param">ci0</em>, <em class="sig-param">ecore</em>, <em class="sig-param">e_cas</em>, <em class="sig-param">envs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step.html#CASSCF.solve_approx_ci"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step.CASSCF.solve_approx_ci" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve CI eigenvalue/response problem approximately</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.mc1step.as_scanner">
<code class="sig-prename descclassname">pyscf.mcscf.mc1step.</code><code class="sig-name descname">as_scanner</code><span class="sig-paren">(</span><em class="sig-param">mc</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step.html#as_scanner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner for CASSCF PES.</p>
<p>The returned solver is a function. This function requires one argument
“mol” as input and returns total CASSCF energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters of MCSCF object
(conv_tol, max_memory etc) are automatically applied in the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, …) during calculation.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.2&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc_scanner</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">mc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">mc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.5&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.mc1step.kernel">
<code class="sig-prename descclassname">pyscf.mcscf.mc1step.</code><code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">mo_coeff</em>, <em class="sig-param">tol=1e-07</em>, <em class="sig-param">conv_tol_grad=None</em>, <em class="sig-param">ci0=None</em>, <em class="sig-param">callback=None</em>, <em class="sig-param">verbose=3</em>, <em class="sig-param">dump_chk=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step.html#kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>quasi-newton CASSCF optimization driver</p>
</dd></dl>

<span class="target" id="module-pyscf.mcscf.mc1step_symm"></span><dl class="attribute">
<dt id="pyscf.mcscf.mc1step_symm.CASSCF">
<code class="sig-prename descclassname">pyscf.mcscf.mc1step_symm.</code><code class="sig-name descname">CASSCF</code><a class="headerlink" href="#pyscf.mcscf.mc1step_symm.CASSCF" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF" title="pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.mcscf.mc1step_symm.</code><code class="sig-name descname">SymAdaptedCASSCF</code><span class="sig-paren">(</span><em class="sig-param">mf_or_mol</em>, <em class="sig-param">ncas</em>, <em class="sig-param">nelecas</em>, <em class="sig-param">ncore=None</em>, <em class="sig-param">frozen=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step_symm.html#SymAdaptedCASSCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>mf_or_mol<span class="classifier">SCF object or Mole object</span></dt><dd><p>SCF or Mole to define the problem size.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Number of active orbitals.</p>
</dd>
<dt>nelecas<span class="classifier">int or a pair of int</span></dt><dd><p>Number of electrons in active space.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>ncore<span class="classifier">int</span></dt><dd><p>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</p>
</dd>
</dl>
</dd>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code>.</p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code>.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Active space size.</p>
</dd>
<dt>nelecas<span class="classifier">tuple of int</span></dt><dd><p>Active (nelec_alpha, nelec_beta)</p>
</dd>
<dt>ncore<span class="classifier">int or tuple of int</span></dt><dd><p>Core electron number.  In UHF-CASSCF, it’s a tuple to indicate the different core eletron numbers.</p>
</dd>
<dt>natorb<span class="classifier">bool</span></dt><dd><p>Whether to transform natural orbital in active space.  Be cautious
of this parameter when CASCI/CASSCF are combined with DMRG solver
or selected CI solver because DMRG and selected CI are not invariant
to the rotation in active space.
False by default.</p>
</dd>
<dt>canonicalization<span class="classifier">bool</span></dt><dd><p>Whether to canonicalize orbitals. Note that canonicalization does
not change the orbitals in active space by default. It only
diagonalizes core and external space of the general Fock matirx.
To get the natural orbitals in active space, attribute natorb
need to be enabled.
True by default.</p>
</dd>
<dt>sorting_mo_energy<span class="classifier">bool</span></dt><dd><p>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</p>
</dd>
<dt>fcisolver<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">FCISolver</span></code></span></dt><dd><p>The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal notranslate"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p>For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitls.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
<dt>mo_occ<span class="classifier">ndarray</span></dt><dd><p>Occupation numbers of natural orbitals if natorb is specified.</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
<span class="go">CASSCF</span>
</pre></div>
</div>
<p>Extra attributes for CASSCF:</p>
<blockquote>
<div><dl>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Converge threshold.  Default is 1e-7</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>Converge threshold for CI gradients and orbital rotation gradients.
Default is 1e-4</p>
</dd>
<dt>max_stepsize<span class="classifier">float</span></dt><dd><p>The step size for orbital rotation.  Small step (0.005 - 0.05) is prefered.
Default is 0.03.</p>
</dd>
<dt>max_cycle_macro<span class="classifier">int</span></dt><dd><p>Max number of macro iterations.  Default is 50.</p>
</dd>
<dt>max_cycle_micro<span class="classifier">int</span></dt><dd><p>Max number of micro iterations in each macro iteration.  Depending on
systems, increasing this value might reduce the total macro
iterations.  Generally, 2 - 5 steps should be enough.  Default is 3.</p>
</dd>
<dt>ah_level_shift<span class="classifier">float, for AH solver.</span></dt><dd><p>Level shift for the Davidson diagonalization in AH solver.  Default is 1e-8.</p>
</dd>
<dt>ah_conv_tol<span class="classifier">float, for AH solver.</span></dt><dd><p>converge threshold for AH solver.  Default is 1e-12.</p>
</dd>
<dt>ah_max_cycle<span class="classifier">float, for AH solver.</span></dt><dd><p>Max number of iterations allowd in AH solver.  Default is 30.</p>
</dd>
<dt>ah_lindep<span class="classifier">float, for AH solver.</span></dt><dd><p>Linear dependence threshold for AH solver.  Default is 1e-14.</p>
</dd>
<dt>ah_start_tol<span class="classifier">flat, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 0.2.</p>
</dd>
<dt>ah_start_cycle<span class="classifier">int, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 2.</p>
<p><code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_max_cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_start_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_start_cycle</span></code>
can affect the accuracy and performance of CASSCF solver.  Lower
<code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code> might improve the accuracy of CASSCF
optimization, but decrease the performance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401898486001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401887945668</span>
</pre></div>
</div>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>Checkpoint file to save the intermediate orbitals during the CASSCF optimization.
Default is the checkpoint file of mean field object.</p>
</dd>
<dt>ci_response_space<span class="classifier">int</span></dt><dd><p>subspace size to solve the CI vector response.  Default is 3.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</p>
</dd>
<dt>scale_restoration<span class="classifier">float</span></dt><dd><p>When a step of orbital rotation moves out of trust region, the
orbital optimization will be restored to previous state and the
step size of the orbital rotation needs to be reduced.
scale_restoration controls how much to scale down the step size.</p>
</dd>
</dl>
</div></blockquote>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>Optimized CASSCF orbitals coefficients. When canonicalization is
specified, the returned orbitals make the general Fock matrix
(Fock operator on top of MCSCF 1-particle density matrix)
diagonalized within each subspace (core, active, external).
If natorb (natural orbitals in active space) is specified,
the active segment of the mo_coeff is natural orbitls.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401882238134</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci0=None</em>, <em class="sig-param">callback=None</em>, <em class="sig-param">_kern=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step_symm.html#SymAdaptedCASSCF.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF.kernel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns:</dt><dd><p>Five elements, they are
total energy,
active space CI energy,
the active space FCI wavefunction coefficients or DMRG wavefunction ID,
the MCSCF canonical orbital coefficients,
the MCSCF canonical orbital coefficients.</p>
</dd>
</dl>
<p>They are attributes of mcscf object, which can be accessed by
.e_tot, .e_cas, .ci, .mo_coeff, .mo_energy</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF.rotate_mo">
<code class="sig-name descname">rotate_mo</code><span class="sig-paren">(</span><em class="sig-param">mo</em>, <em class="sig-param">u</em>, <em class="sig-param">log=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step_symm.html#SymAdaptedCASSCF.rotate_mo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF.rotate_mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate orbitals with the given unitary matrix</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF.sort_mo_by_irrep">
<code class="sig-name descname">sort_mo_by_irrep</code><span class="sig-paren">(</span><em class="sig-param">cas_irrep_nocc</em>, <em class="sig-param">cas_irrep_ncore=None</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/mc1step_symm.html#SymAdaptedCASSCF.sort_mo_by_irrep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.mc1step_symm.SymAdaptedCASSCF.sort_mo_by_irrep" title="Permalink to this definition">¶</a></dt>
<dd><p>Select active space based on symmetry information.
See also <a class="reference internal" href="#pyscf.mcscf.addons.sort_mo_by_irrep" title="pyscf.mcscf.addons.sort_mo_by_irrep"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyscf.mcscf.addons.sort_mo_by_irrep()</span></code></a></p>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyscf.mcscf.umc1step"></span><p>UCASSCF (CASSCF without spin-degeneracy between alpha and beta orbitals)
1-step optimization algorithm</p>
<dl class="attribute">
<dt id="pyscf.mcscf.umc1step.CASSCF">
<code class="sig-prename descclassname">pyscf.mcscf.umc1step.</code><code class="sig-name descname">CASSCF</code><a class="headerlink" href="#pyscf.mcscf.umc1step.CASSCF" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.mcscf.umc1step.UCASSCF" title="pyscf.mcscf.umc1step.UCASSCF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.mcscf.umc1step.UCASSCF</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pyscf.mcscf.umc1step.UCASSCF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.mcscf.umc1step.</code><code class="sig-name descname">UCASSCF</code><span class="sig-paren">(</span><em class="sig-param">mf_or_mol</em>, <em class="sig-param">ncas</em>, <em class="sig-param">nelecas</em>, <em class="sig-param">ncore=None</em>, <em class="sig-param">frozen=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/umc1step.html#UCASSCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.umc1step.UCASSCF" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyscf.mcscf.umc1step.UCASSCF.ao2mo">
<code class="sig-name descname">ao2mo</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/umc1step.html#UCASSCF.ao2mo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.umc1step.UCASSCF.ao2mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the active space two-particle Hamiltonian.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.umc1step.UCASSCF.get_h2cas">
<code class="sig-name descname">get_h2cas</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/umc1step.html#UCASSCF.get_h2cas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.umc1step.UCASSCF.get_h2cas" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the active space two-particle Hamiltonian.</p>
<p>Note It is different to get_h2eff when df.approx_hessian is applied,
in which get_h2eff function returns the DF integrals while get_h2cas
returns the regular 2-electron integrals.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.umc1step.UCASSCF.get_h2eff">
<code class="sig-name descname">get_h2eff</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/umc1step.html#UCASSCF.get_h2eff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.umc1step.UCASSCF.get_h2eff" title="Permalink to this definition">¶</a></dt>
<dd><p>Computing active space two-particle Hamiltonian.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.umc1step.UCASSCF.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci0=None</em>, <em class="sig-param">callback=None</em>, <em class="sig-param">_kern=&lt;function kernel&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/umc1step.html#UCASSCF.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.umc1step.UCASSCF.kernel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns:</dt><dd><p>Five elements, they are
total energy,
active space CI energy,
the active space FCI wavefunction coefficients or DMRG wavefunction ID,
the MCSCF canonical orbital coefficients,
the MCSCF canonical orbital coefficients.</p>
</dd>
</dl>
<p>They are attributes of mcscf object, which can be accessed by
.e_tot, .e_cas, .ci, .mo_coeff, .mo_energy</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.umc1step.UCASSCF.rotate_mo">
<code class="sig-name descname">rotate_mo</code><span class="sig-paren">(</span><em class="sig-param">mo</em>, <em class="sig-param">u</em>, <em class="sig-param">log=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/umc1step.html#UCASSCF.rotate_mo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.umc1step.UCASSCF.rotate_mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate orbitals with the given unitary matrix</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.mcscf.umc1step.UCASSCF.solve_approx_ci">
<code class="sig-name descname">solve_approx_ci</code><span class="sig-paren">(</span><em class="sig-param">h1</em>, <em class="sig-param">h2</em>, <em class="sig-param">ci0</em>, <em class="sig-param">ecore</em>, <em class="sig-param">e_cas</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/umc1step.html#UCASSCF.solve_approx_ci"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.umc1step.UCASSCF.solve_approx_ci" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve CI eigenvalue/response problem approximately</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyscf.mcscf.mc_ao2mo"></span><span class="target" id="module-pyscf.mcscf.umc_ao2mo"></span><p>MO integrals for UCASSCF methods</p>
</div>
<div class="section" id="module-pyscf.mcscf.addons">
<span id="addons"></span><h3><span class="section-number">10.18.6.3. </span>addons<a class="headerlink" href="#module-pyscf.mcscf.addons" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pyscf.mcscf.addons.cas_natorb">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">cas_natorb</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">sort=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#cas_natorb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.cas_natorb" title="Permalink to this definition">¶</a></dt>
<dd><p>Natrual orbitals in CAS space</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.caslst_by_irrep">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">caslst_by_irrep</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">mo_coeff</em>, <em class="sig-param">cas_irrep_nocc</em>, <em class="sig-param">cas_irrep_ncore=None</em>, <em class="sig-param">s=None</em>, <em class="sig-param">base=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#caslst_by_irrep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.caslst_by_irrep" title="Permalink to this definition">¶</a></dt>
<dd><p>Given number of active orbitals for each irrep, return the orbital
indices of active space</p>
<dl>
<dt>Args:</dt><dd><p>casscf : an <code class="xref py py-class docutils literal notranslate"><span class="pre">CASSCF</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">CASCI</span></code> object</p>
<dl class="simple">
<dt>cas_irrep_nocc<span class="classifier">list or dict</span></dt><dd><p>Number of active orbitals for each irrep.  It can be a dict, eg
{‘A1’: 2, ‘B2’: 4} to indicate the active space size based on
irrep names, or {0: 2, 3: 4} for irrep Id,  or a list [2, 0, 0, 4]
(identical to {0: 2, 3: 4}) in which the list index is served as
the irrep Id.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>cas_irrep_ncore<span class="classifier">list or dict</span></dt><dd><p>Number of closed shells for each irrep.  It can be a dict, eg
{‘A1’: 6, ‘B2’: 4} to indicate the closed shells based on
irrep names, or {0: 6, 3: 4} for irrep Id,  or a list [6, 0, 0, 4]
(identical to {0: 6, 3: 4}) in which the list index is served as
the irrep Id.  If cas_irrep_ncore is not given, the program
will generate a guess based on the lowest <code class="xref py py-attr docutils literal notranslate"><span class="pre">CASCI.ncore</span></code>
orbitals.</p>
</dd>
<dt>s<span class="classifier">ndarray</span></dt><dd><p>overlap matrix</p>
</dd>
<dt>base<span class="classifier">int</span></dt><dd><p>0-based (C-like) or 1-based (Fortran-like) caslst</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list of orbital indices</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mcscf</span><span class="o">.</span><span class="n">caslst_by_irrep</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;E1gx&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;E1gy&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;E1ux&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;E1uy&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="go">[5, 7, 8, 10, 11, 14, 15, 20, 25, 26, 31, 32]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.get_fock">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">get_fock</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#get_fock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.get_fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized Fock matrix in AO representation</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.make_rdm1">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle densit matrix in AO representation</p>
<dl class="simple">
<dt>Args:</dt><dd><p>casscf : an <code class="xref py py-class docutils literal notranslate"><span class="pre">CASSCF</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">CASCI</span></code> object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients. If not given, take casscf.ci.</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>Orbital coefficients. If not given, take casscf.mo_coeff.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">natocc</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">mcscf</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">(</span><span class="n">mc</span><span class="p">),</span> <span class="n">mf</span><span class="o">.</span><span class="n">get_ovlp</span><span class="p">(),</span> <span class="nb">type</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">natocc</span><span class="p">)</span>
<span class="go">[ 0.0121563   0.0494735   0.0494735   1.95040395  1.95040395  1.98808879</span>
<span class="go">  2.          2.          2.          2.        ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.make_rdm1s">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">make_rdm1s</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#make_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.make_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha and beta one-particle densit matrices in AO representation</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.map2hf">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">map2hf</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">mf_mo=None</em>, <em class="sig-param">base=1</em>, <em class="sig-param">tol=0.4</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#map2hf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.map2hf" title="Permalink to this definition">¶</a></dt>
<dd><p>The overlap between the CASSCF optimized orbitals and the canonical HF orbitals.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.project_init_guess">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">project_init_guess</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">init_mo</em>, <em class="sig-param">prev_mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#project_init_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.project_init_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the given initial guess to the current CASSCF problem.  The
projected initial guess has two parts.  The core orbitals are directly
taken from the Hartree-Fock orbitals, and the active orbitals are
projected from the given initial guess.</p>
<dl>
<dt>Args:</dt><dd><p>casscf : an <code class="xref py py-class docutils literal notranslate"><span class="pre">CASSCF</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">CASCI</span></code> object</p>
<dl class="simple">
<dt>init_mo<span class="classifier">ndarray or list of ndarray</span></dt><dd><p>Initial guess orbitals which are not orth-normal for the current
molecule.  When the casscf is UHF-CASSCF, the init_mo needs to be
a list of two ndarrays, for alpha and beta orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>prev_mol<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></span></dt><dd><p>If given, the inital guess orbitals are associated to the geometry
and basis of prev_mol.  Otherwise, the orbitals are based of
the geometry and basis of casscf.mol</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>New orthogonal initial guess orbitals with the core taken from
Hartree-Fock orbitals and projected active space from original initial
guess orbitals</p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 0.8&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mo</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">sort_mo</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;E(0.8) = </span><span class="si">%.12f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mo</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">init_mo</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">mo_coeff</span>
<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">)]]</span>
    <span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
    <span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">mo</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">project_init_guess</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">init_mo</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;E(</span><span class="si">%2.1f</span><span class="s1">) = </span><span class="si">%.12f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mo</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">init_mo</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">mo_coeff</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.sort_mo">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">sort_mo</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">mo_coeff</em>, <em class="sig-param">caslst</em>, <em class="sig-param">base=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#sort_mo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.sort_mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick orbitals for CAS space</p>
<dl>
<dt>Args:</dt><dd><p>casscf : an <code class="xref py py-class docutils literal notranslate"><span class="pre">CASSCF</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">CASCI</span></code> object</p>
<dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray or a list of ndarray</span></dt><dd><p>Orbitals for CASSCF initial guess.  In the UHF-CASSCF, it’s a list
of two orbitals, for alpha and beta spin.</p>
</dd>
<dt>caslst<span class="classifier">list of int or nested list of int</span></dt><dd><p>A list of orbital indices to represent the CAS space.  In the UHF-CASSCF,
it’s consist of two lists, for alpha and beta spin.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>base<span class="classifier">int</span></dt><dd><p>0-based (C-style) or 1-based (Fortran-style) caslst</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>An reoreded mo_coeff, which put the orbitals given by caslst in the CAS space</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cas_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span> <span class="c1"># pi orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">sort_mo</span><span class="p">(</span><span class="n">cas_list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mo</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.007378939813691</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.sort_mo_by_irrep">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">sort_mo_by_irrep</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">mo_coeff</em>, <em class="sig-param">cas_irrep_nocc</em>, <em class="sig-param">cas_irrep_ncore=None</em>, <em class="sig-param">s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#sort_mo_by_irrep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.sort_mo_by_irrep" title="Permalink to this definition">¶</a></dt>
<dd><p>Given number of active orbitals for each irrep, construct the mo initial
guess for CASSCF</p>
<dl>
<dt>Args:</dt><dd><p>casscf : an <code class="xref py py-class docutils literal notranslate"><span class="pre">CASSCF</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">CASCI</span></code> object</p>
<dl class="simple">
<dt>cas_irrep_nocc<span class="classifier">list or dict</span></dt><dd><p>Number of active orbitals for each irrep.  It can be a dict, eg
{‘A1’: 2, ‘B2’: 4} to indicate the active space size based on
irrep names, or {0: 2, 3: 4} for irrep Id,  or a list [2, 0, 0, 4]
(identical to {0: 2, 3: 4}) in which the list index is served as
the irrep Id.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>cas_irrep_ncore<span class="classifier">list or dict</span></dt><dd><p>Number of closed shells for each irrep.  It can be a dict, eg
{‘A1’: 6, ‘B2’: 4} to indicate the closed shells based on
irrep names, or {0: 6, 3: 4} for irrep Id,  or a list [6, 0, 0, 4]
(identical to {0: 6, 3: 4}) in which the list index is served as
the irrep Id.  If cas_irrep_ncore is not given, the program
will generate a guess based on the lowest <code class="xref py py-attr docutils literal notranslate"><span class="pre">CASCI.ncore</span></code>
orbitals.</p>
</dd>
<dt>s<span class="classifier">ndarray</span></dt><dd><p>overlap matrix</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>sorted orbitals, ordered as [c,..,c,a,..,a,v,..,v]</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">sort_mo_by_irrep</span><span class="p">({</span><span class="s1">&#39;E1gx&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;E1gy&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;E1ux&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;E1uy&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Same to mo = sort_mo_by_irrep(mc, mf.mo_coeff, {2: 4, 3: 4, 6: 2, 7: 2})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Same to mo = sort_mo_by_irrep(mc, mf.mo_coeff, [0, 0, 4, 4, 0, 0, 2, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mo</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.162863845084</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.spin_square">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">spin_square</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">ci=None</em>, <em class="sig-param">ovlp=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square of the UHF-CASSCF wavefunction</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; O 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">spin_square</span><span class="p">(</span><span class="n">mc</span><span class="p">))</span>
<span class="go">S^2 = 3.9831589, 2S+1 = 4.1149284</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.state_average">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">state_average</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">weights=(0.5</em>, <em class="sig-param">0.5)</em>, <em class="sig-param">wfnsym=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#state_average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.state_average" title="Permalink to this definition">¶</a></dt>
<dd><p>State average over the energy.  The energy funcitonal is
E = w1&lt;psi1|H|psi1&gt; + w2&lt;psi2|H|psi2&gt; + …</p>
<p>Note we may need change the FCI solver to</p>
<p>mc.fcisolver = fci.solver(mol, False)</p>
<p>before calling state_average_(mc), to mix the singlet and triplet states</p>
<p>MRH, 04/08/2019: Instead of turning casscf._finalize into an instance attribute
that points to the previous casscf object, I’m going to make a whole new child class.
This will have the added benefit of making state_average and <a href="#id5"><span class="problematic" id="id6">state_average_</span></a>
actually behave differently for the first time (until now they <em>both</em> modified the
casscf object inplace). I’m also going to assign the weights argument as a member
of the mc child class because an accurate second-order CASSCF algorithm for state-averaged
calculations requires that the gradient and Hessian be computed for CI vectors of each root
individually and then multiplied by that root’s weight. The second derivatives computed
by newton_casscf.py need to be extended to state-averaged calculations in order to be
used as intermediates for calculations of the gradient of a single root in the context
of the SA-CASSCF method; see: Mol. Phys. 99, 103 (2001).</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.state_average_">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">state_average_</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">weights=(0.5</em>, <em class="sig-param">0.5)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#state_average_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.state_average_" title="Permalink to this definition">¶</a></dt>
<dd><p>Inplace version of state_average</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.state_average_mix">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">state_average_mix</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">fcisolvers</em>, <em class="sig-param">weights=(0.5</em>, <em class="sig-param">0.5)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#state_average_mix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.state_average_mix" title="Permalink to this definition">¶</a></dt>
<dd><p>State-average CASSCF over multiple FCI solvers.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.state_average_mix_">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">state_average_mix_</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">fcisolvers</em>, <em class="sig-param">weights=(0.5</em>, <em class="sig-param">0.5)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#state_average_mix_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.state_average_mix_" title="Permalink to this definition">¶</a></dt>
<dd><p>Inplace version of state_average</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.state_specific">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">state_specific</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">state=1</em>, <em class="sig-param">wfnsym=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcscf.addons.state_specific" title="Permalink to this definition">¶</a></dt>
<dd><p>For excited state</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>state : int
0 for ground state; 1 for first excited state.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.mcscf.addons.state_specific_">
<code class="sig-prename descclassname">pyscf.mcscf.addons.</code><code class="sig-name descname">state_specific_</code><span class="sig-paren">(</span><em class="sig-param">casscf</em>, <em class="sig-param">state=1</em>, <em class="sig-param">wfnsym=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcscf/addons.html#state_specific_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.mcscf.addons.state_specific_" title="Permalink to this definition">¶</a></dt>
<dd><p>For excited state</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>state : int
0 for ground state; 1 for first excited state.</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mp.html" class="btn btn-neutral float-right" title="10.19. mp — MP2" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lo.html" class="btn btn-neutral float-left" title="10.17. lo — Orbital localization and analysis tools" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2019, The PySCF Developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>