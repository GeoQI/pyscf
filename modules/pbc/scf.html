

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>10.21.3. pbc.scf — Self-consistent field with periodic boundary conditions &mdash; PySCF 1.7.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="10.21.4. pbc.dft — DFT with PBCs" href="dft.html" />
    <link rel="prev" title="10.21.2. pbc.ao2mo — Integral transformations for crystalline Gaussian type orbitals" href="ao2mo.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../version.html">2. Version history</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code-rule.html">4. Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../benchmark.html">5. Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">6. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../theory.html">7. Theoretical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced.html">8. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../interface.html">9. Interfaces</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../modules.html">10. Main modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../adc.html">10.1. <code class="xref py py-mod docutils literal notranslate"><span class="pre">adc</span></code> — Algebraic diagrammatic construction (ADC) scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ao2mo.html">10.2. <code class="xref py py-mod docutils literal notranslate"><span class="pre">ao2mo</span></code> — Integral transformations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cc.html">10.3. <code class="xref py py-mod docutils literal notranslate"><span class="pre">cc</span></code> — Coupled cluster</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ccn.html">10.4. <code class="xref py py-mod docutils literal notranslate"><span class="pre">ccn</span></code> — Auto-generated coupled cluster of arbitrary order</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ci.html">10.5. <code class="xref py py-mod docutils literal notranslate"><span class="pre">ci</span></code> — Configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data.html">10.6. <code class="xref py py-mod docutils literal notranslate"><span class="pre">data</span></code> — Data for constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../df.html">10.7. <code class="xref py py-mod docutils literal notranslate"><span class="pre">df</span></code> — Density fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dft.html">10.8. <code class="xref py py-mod docutils literal notranslate"><span class="pre">dft</span></code> — Density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../doci.html">10.9. <code class="xref py py-mod docutils literal notranslate"><span class="pre">doci</span></code> — Doubly occupied configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fci.html">10.10. <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code> — Full configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../grad.html">10.11. <code class="xref py py-mod docutils literal notranslate"><span class="pre">grad</span></code> — Analytical nuclear gradients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gto.html">10.12. <code class="xref py py-mod docutils literal notranslate"><span class="pre">gto</span></code> — Molecular structure and GTO basis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gw.html">10.13. <code class="xref py py-mod docutils literal notranslate"><span class="pre">gw</span></code> — Molecular G0W0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hci.html">10.14. <code class="xref py py-mod docutils literal notranslate"><span class="pre">hci</span></code> — Heat-bath selected CI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hessian.html">10.15. <code class="xref py py-mod docutils literal notranslate"><span class="pre">hessian</span></code> — Analytical nuclear Hessian</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lib.html">10.16. <code class="xref py py-mod docutils literal notranslate"><span class="pre">lib</span></code> — Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lo.html">10.17. <code class="xref py py-mod docutils literal notranslate"><span class="pre">lo</span></code> — Orbital localization and analysis tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcscf.html">10.18. <code class="xref py py-mod docutils literal notranslate"><span class="pre">mcscf</span></code> — Multi-configurational self-consistent field</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mp.html">10.19. <code class="xref py py-mod docutils literal notranslate"><span class="pre">mp</span></code> — MP2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mrpt.html">10.20. <code class="xref py py-mod docutils literal notranslate"><span class="pre">mrpt</span></code> — Multi-reference perturbation theory</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../pbc.html">10.21. <code class="xref py py-mod docutils literal notranslate"><span class="pre">pbc</span></code> — Periodic boundary conditions</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="gto.html">10.21.1. pbc.gto — Crystal cell structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="ao2mo.html">10.21.2. pbc.ao2mo — Integral transformations for crystalline Gaussian type orbitals</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">10.21.3. pbc.scf — Self-consistent field with periodic boundary conditions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gamma-point-and-single-k-point-calculation">10.21.3.1. Gamma point and single k-point calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#k-point-sampling">10.21.3.2. k-point sampling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exchange-divergence-treatment">10.21.3.3. Exchange divergence treatment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gaussian-density-fitting">10.21.3.4. Gaussian density fitting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.pbc.scf.hf">10.21.3.5. Program reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="dft.html">10.21.4. pbc.dft  — DFT with PBCs</a></li>
<li class="toctree-l3"><a class="reference internal" href="df.html">10.21.5. pbc.df — PBC denisty fitting</a></li>
<li class="toctree-l3"><a class="reference internal" href="tdscf.html">10.21.6. pbc.tdscf — TDHF and TDDFT with PBCs</a></li>
<li class="toctree-l3"><a class="reference internal" href="mp.html">10.21.7. pbc.mp — PBC perturbation theory</a></li>
<li class="toctree-l3"><a class="reference internal" href="ci.html">10.21.8. pbc.ci — CISD with PBCs</a></li>
<li class="toctree-l3"><a class="reference internal" href="cc.html">10.21.9. pbc.cc — Coupled cluster with PBCs</a></li>
<li class="toctree-l3"><a class="reference internal" href="mpicc.html">10.21.10. pbc.mpicc — PBC coupled cluster for MPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="tools.html">10.21.11. pbc.tools — PBC tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="mix_mol.html">10.21.12. Mixing PBC and molecular modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="prop.html">10.21.13. pbc.prop — PBC property</a></li>
<li class="toctree-l3"><a class="reference internal" href="gw.html">10.21.14. pbc.gw — GW with PBC</a></li>
<li class="toctree-l3"><a class="reference internal" href="x2c.html">10.21.15. pbc.x2c — Exact Two-Component Method</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../prop.html">10.22. <code class="xref py py-mod docutils literal notranslate"><span class="pre">prop</span></code> — Molecular properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../qmmm.html">10.23. <code class="xref py py-mod docutils literal notranslate"><span class="pre">qmmm</span></code> — QM/MM interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rt.html">10.24. <code class="xref py py-mod docutils literal notranslate"><span class="pre">rt</span></code> — Real-time time-dependent density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scf.html">10.25. <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf</span></code> — Self-consistent field methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../semiempirical.html">10.26. <code class="xref py py-mod docutils literal notranslate"><span class="pre">semiempirical</span></code> — Semiempirical methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sgx.html">10.27. <code class="xref py py-mod docutils literal notranslate"><span class="pre">sgx</span></code> — Pseudo-spectral methods (COSX, PS, SN-K)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../solvent.html">10.28. <code class="xref py py-mod docutils literal notranslate"><span class="pre">solvent</span></code> — Solvent methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soscf.html">10.29. <code class="xref py py-mod docutils literal notranslate"><span class="pre">soscf</span></code> — Second order SCF solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../symm.html">10.30. <code class="xref py py-mod docutils literal notranslate"><span class="pre">symm</span></code> – Point group symmetry and spin symmetry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tdscf.html">10.31. <code class="xref py py-mod docutils literal notranslate"><span class="pre">tdscf</span></code> — TDHF and TDDFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools.html">10.32. <code class="xref py py-mod docutils literal notranslate"><span class="pre">tools</span></code> — Useful tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../x2c.html">10.33. <code class="xref py py-mod docutils literal notranslate"><span class="pre">x2c</span></code> — exact-two-component approach</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PySCF</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../modules.html"><span class="section-number">10. </span>Main modules</a> &raquo;</li>
        
          <li><a href="../pbc.html"><span class="section-number">10.21. </span><code class="xref py py-mod docutils literal notranslate"><span class="pre">pbc</span></code> — Periodic boundary conditions</a> &raquo;</li>
        
      <li><span class="section-number">10.21.3. </span>pbc.scf — Self-consistent field with periodic boundary conditions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/modules/pbc/scf.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pbc-scf-self-consistent-field-with-periodic-boundary-conditions">
<span id="pbc-scf"></span><h1><span class="section-number">10.21.3. </span>pbc.scf — Self-consistent field with periodic boundary conditions<a class="headerlink" href="#pbc-scf-self-consistent-field-with-periodic-boundary-conditions" title="Permalink to this headline">¶</a></h1>
<p>This module is constructed to be analogous to the molecular <a class="reference internal" href="../scf.html#module-pyscf.scf" title="pyscf.scf"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyscf.scf</span></code></a> module to handle
mean-field calculations with periodic boundary conditions.</p>
<div class="section" id="gamma-point-and-single-k-point-calculation">
<h2><span class="section-number">10.21.3.1. </span>Gamma point and single k-point calculation<a class="headerlink" href="#gamma-point-and-single-k-point-calculation" title="Permalink to this headline">¶</a></h2>
<p>The usage of the Gamma point Hartree-Fock program is very close to that of the
molecular program.  In a PBC Gamma point calculation, one needs to initialize the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object and the corresponding <a class="reference internal" href="#pyscf.pbc.scf.hf.RHF" title="pyscf.pbc.scf.hf.RHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.pbc.scf.hf.RHF</span></code></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;H     0.      0.      0.</span>
<span class="s1">              H     0.8917  0.8917  0.8917&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;sto3g&#39;</span><span class="p">,</span>
    <span class="n">h</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    0       1.7834  1.7834</span>
<span class="s1">    1.7834  0       1.7834</span>
<span class="s1">    1.7834  1.7834  0     &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">gs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>Compared to the <a class="reference internal" href="../scf.html#pyscf.scf.hf.RHF" title="pyscf.scf.hf.RHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.scf.hf.RHF</span></code></a> object for molecular calculations,
the PBC-HF calculation with <a class="reference internal" href="#pyscf.pbc.scf.hf.RHF" title="pyscf.pbc.scf.hf.RHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.pbc.scf.hf.RHF</span></code></a> or
<a class="reference internal" href="#pyscf.pbc.scf.uhf.UHF" title="pyscf.pbc.scf.uhf.UHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.pbc.scf.uhf.UHF</span></code></a> has three differences</p>
<ul>
<li><p><a class="reference internal" href="#pyscf.pbc.scf.hf.RHF" title="pyscf.pbc.scf.hf.RHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.pbc.scf.hf.RHF</span></code></a> is the single k-point PBC HF class.  By default,
it creates a Gamma point instance.  You can change to other (single) k-points by
setting the <code class="xref py py-attr docutils literal notranslate"><span class="pre">kpt</span></code> attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kpt</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_abs_kpts</span><span class="p">([</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="o">.</span><span class="mi">25</span><span class="p">])</span>  <span class="c1"># convert from scaled kpts</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p>The exchange integrals of the PBC Hartree-Fock method show a slow convergence
with respect to the number of k-points.  A proper treatment for the divergent
part of the exchange integral can improve the convergence.  The attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">exxdiv</span></code> is used to control the method to handle the divergent exchange
term.  The default <code class="docutils literal notranslate"><span class="pre">exxdiv='ewald'</span></code> can be used for most scenarios.  However,
if molecular post-HF methods are mixed with the Gamma point mean-field methods (see
<a class="reference internal" href="#mix-to-mol"><span class="std std-ref">Mixing with molecular program for post-HF methods</span></a>, you will need to explicitly use <code class="docutils literal notranslate"><span class="pre">exxdiv=None</span></code> to obtain a consistent total
energy (see <a class="reference internal" href="#exxdiv"><span class="std std-ref">Exchange divergence treatment</span></a>). If PBC post-HF methods are used, the <code class="xref py py-mod docutils literal notranslate"><span class="pre">exxdiv</span></code> attribute
is always treated as <code class="docutils literal notranslate"><span class="pre">None</span></code> in the correlated calculation to obtain a consistent total energy.</p></li>
<li><p>In PBC calculations there are different choices for how to
evaluate 2-electron integrals.  The default integral scheme (FFTDF) is accurate   for pseudo-potentials and fast for DFT calculations but
slow in other scenarios. A second integral
scheme which is a good balance of speed and accuracy for
Hartree-Fock, all-electron, and post-Hartree-Fock calculations, is
Gaussian density fitting. This can be used by setting the <code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code> attribute (see <a class="reference internal" href="df.html#pbc-df"><span class="std std-ref">pbc.df — PBC denisty fitting</span></a>) or, conveniently, by using the <code class="xref py py-func docutils literal notranslate"><span class="pre">density_fit()</span></code> function (see <span class="xref std std-ref">pbc_density_fit</span>). For</p></li>
</ul>
<dl class="simple">
<dt>higher accuracy, you may wish to use</dt><dd><p>mixed density fitting (MDF) (see <span class="xref std std-ref">with_df</span>).  Here is an example to update <code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code></p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Gamma point Hartree-Fock/DFT for all-electron calculation</span>

<span class="sd">The default FFT-based 2-electron integrals may not be accurate enough for</span>
<span class="sd">all-electron calculation.  It&#39;s recommended to use MDF (mixed density fitting)</span>
<span class="sd">technique to improve the accuracy.</span>

<span class="sd">See also</span>
<span class="sd">examples/df/00-with_df.py</span>
<span class="sd">examples/df/01-auxbasis.py</span>
<span class="sd">examples/df/40-precomupte_df_ints.py</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">dft</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mf">3.5668</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;C     0.      0.      0.    </span>
<span class="s1">              C     0.8917  0.8917  0.8917</span>
<span class="s1">              C     1.7834  1.7834  0.    </span>
<span class="s1">              C     2.6751  2.6751  0.8917</span>
<span class="s1">              C     1.7834  0.      1.7834</span>
<span class="s1">              C     2.6751  0.8917  2.6751</span>
<span class="s1">              C     0.      1.7834  1.7834</span>
<span class="s1">              C     0.8917  2.6751  2.6751&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;6-31g&#39;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1"># Mixed density fitting is another option for all-electron calculations</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">mix_density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span>  <span class="c1"># Tune #PWs in MDF for performance/accuracy balance</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1"># Or use even-tempered Gaussian basis as auxiliary fitting functions.</span>
<span class="c1"># The following auxbasis is generated based on the expression</span>
<span class="c1">#    alpha = a * 1.7^i   i = 0..N</span>
<span class="c1"># where a and N are determined by the smallest and largest exponents of AO basis.</span>
<span class="kn">import</span> <span class="nn">pyscf.df</span>
<span class="n">auxbasis</span> <span class="o">=</span> <span class="n">pyscf</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">aug_etb</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.7</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">(</span><span class="n">auxbasis</span><span class="o">=</span><span class="n">auxbasis</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Second order SCF solver can be used in the PBC SCF code the same way in the</span>
<span class="c1"># molecular calculation</span>
<span class="c1">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">(</span><span class="n">auxbasis</span><span class="o">=</span><span class="s1">&#39;weigend&#39;</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="s1">&#39;bp86&#39;</span>
<span class="c1"># You should first set mf.xc then apply newton method (see also</span>
<span class="c1"># examples/scf/22-newton.py)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">newton</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># The computational costs to initialize PBC DF object is high.  The density</span>
<span class="c1"># fitting integral tensor created in the initialization can be cached for</span>
<span class="c1"># future use.  See also examples/df/40-precomupte_df_ints.py</span>
<span class="c1">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">(</span><span class="n">auxbasis</span><span class="o">=</span><span class="s1">&#39;weigend&#39;</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">_cderi_to_save</span> <span class="o">=</span> <span class="s1">&#39;df_ints.h5&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="c1">#</span>
<span class="c1"># The DF integral tensor can be preloaded in an independent calculation.</span>
<span class="c1">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">_cderi</span> <span class="o">=</span> <span class="s1">&#39;df_ints.h5&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="mixing-with-molecular-program-for-post-hf-methods">
<span id="mix-to-mol"></span><h3><span class="section-number">10.21.3.1.1. </span>Mixing with molecular program for post-HF methods<a class="headerlink" href="#mixing-with-molecular-program-for-post-hf-methods" title="Permalink to this headline">¶</a></h3>
<p>The Gamma point HF code adopts the same code structure, function and
method names and argument’ conventions as the molecular SCF code.
This desgin allows one to mix PBC HF objects with the existing molecular post-HF
code for PBC electron correlation treatments.  A typical molecular post-HF
calculation starts from the finite-size HF method with the <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code>
object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">cc</span>
<span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>The PBC Gamma point post-HF calculation requires the <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object and
PBC HF object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span>
             <span class="n">h</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">gs</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">cc</span>
<span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>The differences are the <code class="docutils literal notranslate"><span class="pre">mol</span></code> or <code class="docutils literal notranslate"><span class="pre">cell</span></code> object to create and the
<code class="docutils literal notranslate"><span class="pre">scf</span></code> module to import.  With the system-specific mean-field object, one
can carry out various post-HF methods (MP2, Coupled cluster, CISD, TDHF,
TDDFT, …) using the same code for finite-size and extended systems.
See <a class="reference internal" href="mix_mol.html#mix-mol"><span class="std std-ref">Mixing PBC and molecular modules</span></a> for more details of the interface between PBC and molecular
modules.</p>
</div>
</div>
<div class="section" id="k-point-sampling">
<h2><span class="section-number">10.21.3.2. </span>k-point sampling<a class="headerlink" href="#k-point-sampling" title="Permalink to this headline">¶</a></h2>
<p>An example demonstrating the use of k-points for a KRHF, KRKS calculation, and using the Newton (second-order SCF) solver.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Mean field with k-points sampling</span>

<span class="sd">The 2-electron integrals are computed using Poisson solver with FFT by default.</span>
<span class="sd">In most scenario, it should be used with pseudo potential.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">dft</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mf">3.5668</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;C     0.      0.      0.    </span>
<span class="s1">              C     0.8917  0.8917  0.8917</span>
<span class="s1">              C     1.7834  1.7834  0.    </span>
<span class="s1">              C     2.6751  2.6751  0.8917</span>
<span class="s1">              C     1.7834  0.      1.7834</span>
<span class="s1">              C     2.6751  0.8917  2.6751</span>
<span class="s1">              C     0.      1.7834  1.7834</span>
<span class="s1">              C     0.8917  2.6751  2.6751&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;gth-szv&#39;</span><span class="p">,</span>
    <span class="n">pseudo</span> <span class="o">=</span> <span class="s1">&#39;gth-pade&#39;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">nk</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>  <span class="c1"># 4 k-points for each axis, 4^3=64 kpts in total</span>
<span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>

<span class="n">kmf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">KRHF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="n">kmf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="n">kmf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">KRKS</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="c1"># Turn to the atomic grids if you like</span>
<span class="n">kmf</span><span class="o">.</span><span class="n">grids</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">gen_grid</span><span class="o">.</span><span class="n">BeckeGrids</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">kmf</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="s1">&#39;m06,m06&#39;</span>
<span class="n">kmf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>


<span class="c1">#</span>
<span class="c1"># Second order SCF solver can be used in the PBC SCF code the same way in the</span>
<span class="c1"># molecular calculation</span>
<span class="c1">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">KRHF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span><span class="o">.</span><span class="n">newton</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

</pre></div>
</div>
<div class="section" id="smearing">
<h3><span class="section-number">10.21.3.2.1. </span>Smearing<a class="headerlink" href="#smearing" title="Permalink to this headline">¶</a></h3>
<p>In many periodic systems, the HOMO-LUMO gap may become very small. In such a case, one needs to use occupation number smearing
to converge the SCF calculation, as illustrated here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Cell</span><span class="p">()</span>
<span class="n">cell</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">He 0 0 1</span>
<span class="s1">He 1 0 1</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
<span class="n">cell</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">cell</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Use scf.addons.smearing_ function to modify the</span>
<span class="c1"># PBC (gamma-point or k-points) SCF object</span>
<span class="c1">#</span>
<span class="n">nks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">KRHF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">(</span><span class="n">nks</span><span class="p">))</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">smearing_</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fermi&#39;</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="exchange-divergence-treatment">
<span id="exxdiv"></span><h2><span class="section-number">10.21.3.3. </span>Exchange divergence treatment<a class="headerlink" href="#exchange-divergence-treatment" title="Permalink to this headline">¶</a></h2>
<p>The attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">exxdiv</span></code> controls the handling of the slow convergence
of the HF exchange integrals.
Generally, <code class="xref py py-attr docutils literal notranslate"><span class="pre">exxdiv</span></code> leads to a shift in the total energy that
can be thought of as a HF finite size-correction. It also modifies the spectrum of
the occupied orbitals. When a Gamma-point PBC mean-field calculation is mixed with a molecular post-HF implementation, setting this attribute to anything other than <code class="docutils literal notranslate"><span class="pre">None</span></code> will lead to an inconsistency in the total energy.</p>
<p>Possible values are <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">vcut_sph</span></code> (spherical cutoff), <code class="docutils literal notranslate"><span class="pre">vcut_ws</span></code> (Wigner-Seitz cutoff), <code class="docutils literal notranslate"><span class="pre">ewald</span></code> (probe-charge Ewald correction).
<code class="docutils literal notranslate"><span class="pre">vcut_sph</span></code> and <code class="docutils literal notranslate"><span class="pre">vcut_ws</span></code> are only available when using FFTDF. When using hybrid functionals, the exchange treatment will use the <code class="xref py py-attr docutils literal notranslate"><span class="pre">exxdiv</span></code> attribute.</p>
<p>Note that when calling <code class="xref py py-func docutils literal notranslate"><span class="pre">get_bands()</span></code>, the choice of <code class="xref py py-attr docutils literal notranslate"><span class="pre">exxdiv</span></code> affects the band structure. In particular, <code class="docutils literal notranslate"><span class="pre">vcut_sph</span></code> (spherical cutoff), <code class="docutils literal notranslate"><span class="pre">vcut_ws</span></code> (Wigner-Seitz cutoff) should be used to obtain smooth bands, otherwise, the band structure should be computed by twisting the
SCF calculation (i.e. redoing self-consistency at each k point).</p>
</div>
<div class="section" id="gaussian-density-fitting">
<h2><span class="section-number">10.21.3.4. </span>Gaussian density fitting<a class="headerlink" href="#gaussian-density-fitting" title="Permalink to this headline">¶</a></h2>
<p>This example uses the <code class="xref py py-func docutils literal notranslate"><span class="pre">density_fit()</span></code> function to enable Gaussian density fitting:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span> <span class="k">as</span> <span class="n">mol_gto</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">df</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Cell</span><span class="p">()</span>
<span class="n">cell</span><span class="o">.</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">C 0.000000000000   0.000000000000   0.000000000000</span>
<span class="s1">C 1.685068664391   1.685068664391   1.685068664391</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;gth-dzv&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">pseudo</span> <span class="o">=</span> <span class="s1">&#39;gth-pade&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">0.000000000, 3.370137329, 3.370137329</span>
<span class="s1">3.370137329, 0.000000000, 3.370137329</span>
<span class="s1">3.370137329, 3.370137329, 0.000000000&#39;&#39;&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;B&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">cell</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Default DF auxiliary basis is a set of even-tempered gaussian basis (with</span>
<span class="c1"># exponents alpha * beta**i, i = 1,..,N).  The even-tempered parameter alpha</span>
<span class="c1"># is determined automatically based on the orbital basis.  beta is set to 2.0</span>
<span class="c1">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="module-pyscf.pbc.scf.hf">
<span id="program-reference"></span><h2><span class="section-number">10.21.3.5. </span>Program reference<a class="headerlink" href="#module-pyscf.pbc.scf.hf" title="Permalink to this headline">¶</a></h2>
<p>Hartree-Fock for periodic systems at a single k-point</p>
<dl class="simple">
<dt>See Also:</dt><dd><p>pyscf.pbc.scf.khf.py : Hartree-Fock for periodic systems with k-point sampling</p>
</dd>
</dl>
<dl class="class">
<dt id="pyscf.pbc.scf.hf.RHF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">RHF</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">kpt=array([0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.])</em>, <em class="sig-param">exxdiv='ewald'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#RHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.RHF" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyscf.pbc.scf.hf.RHF.convert_from_">
<code class="sig-name descname">convert_from_</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#RHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.RHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to RHF</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.RHF.stability">
<code class="sig-name descname">stability</code><span class="sig-paren">(</span><em class="sig-param">internal=True</em>, <em class="sig-param">external=False</em>, <em class="sig-param">verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/scf/hf.html#RHF.stability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.RHF.stability" title="Permalink to this definition">¶</a></dt>
<dd><p>RHF/RKS stability analysis.</p>
<p>See also pyscf.scf.stability.rhf_stability function.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the RHF optimization space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. Including the RHF -&gt; UHF and real -&gt; complex
stability analysis.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>New orbitals that are more close to the stable condition.  The return
value includes two set of orbitals.  The first corresponds to the
internal stability and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyscf.pbc.scf.hf.SCF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">SCF</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">kpt=array([0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.])</em>, <em class="sig-param">exxdiv='ewald'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class adapted for PBCs.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>kpt<span class="classifier">(3,) ndarray</span></dt><dd><p>The AO k-point in Cartesian coordinates, in units of 1/Bohr.</p>
</dd>
<dt>exxdiv<span class="classifier">str</span></dt><dd><p>Exchange divergence treatment, can be one of</p>
<div class="line-block">
<div class="line">None : ignore G=0 contribution in exchange</div>
<div class="line">‘ewald’ : Ewald probe charge correction [JCP 122, 234102 (2005); DOI:10.1063/1.1926272]</div>
</div>
</dd>
<dt>with_df<span class="classifier">density fitting object</span></dt><dd><p>Default is the FFT based DF model. For all-electron calculation,
MDF model is favored for better accuracy.  See also <code class="xref py py-mod docutils literal notranslate"><span class="pre">pyscf.pbc.df</span></code>.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>When this flag is set to true, the J/K matrices will be computed
directly through the underlying with_df methods.  Otherwise,
depending the available memory, the 4-index integrals may be cached
and J/K matrices are computed based on the 4-index integrals.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.check_sanity">
<code class="sig-name descname">check_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.check_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.check_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.dip_moment">
<code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">unit='Debye'</em>, <em class="sig-param">verbose=3</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell (is it well defined)?</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm (ndarray) : density matrix</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.from_chk">
<code class="sig-name descname">from_chk</code><span class="sig-paren">(</span><em class="sig-param">chk=None</em>, <em class="sig-param">project=None</em>, <em class="sig-param">kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.from_chk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.from_chk" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_bands">
<code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param">kpts_band</em>, <em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">kpt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_j">
<code class="sig-name descname">get_j</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">kpt=None</em>, <em class="sig-param">kpts_band=None</em>, <em class="sig-param">omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J matrix for the given density matrix and k-point (kpt).
When kpts_band is given, the J matrices on kpts_band are evaluated.</p>
<blockquote>
<div><p>J_{pq} = sum_{rs} (pq|rs) dm[s,r]</p>
</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_jk">
<code class="sig-name descname">get_jk</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">kpt=None</em>, <em class="sig-param">kpts_band=None</em>, <em class="sig-param">with_j=True</em>, <em class="sig-param">with_k=True</em>, <em class="sig-param">omega=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Coulomb (J) and exchange (K) following <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_jk_()</span></code>.
for particular k-point (kpt).</p>
<p>When kpts_band is given, the J, K matrices on kpts_band are evaluated.</p>
<blockquote>
<div><p>J_{pq} = sum_{rs} (pq|rs) dm[s,r]
K_{pq} = sum_{rs} (pr|sq) dm[r,s]</p>
</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_jk_incore">
<code class="sig-name descname">get_jk_incore</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">kpt=None</em>, <em class="sig-param">omega=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.get_jk_incore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_jk_incore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Coulomb (J) and exchange (K) following <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_jk_()</span></code>.</p>
<p><em>Incore</em> version of Coulomb and exchange build only.
Currently RHF always uses PBC AO integrals (unlike RKS), since
exchange is currently computed by building PBC AO integrals.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_k">
<code class="sig-name descname">get_k</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">kpt=None</em>, <em class="sig-param">kpts_band=None</em>, <em class="sig-param">omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.get_k"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute K matrix for the given density matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_rho">
<code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param">dm=None</em>, <em class="sig-param">grids=None</em>, <em class="sig-param">kpt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">dm_last=0</em>, <em class="sig-param">vhf_last=0</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">kpt=None</em>, <em class="sig-param">kpts_band=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.init_guess_by_1e">
<code class="sig-name descname">init_guess_by_1e</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.init_guess_by_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.init_guess_by_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.init_guess_by_chkfile">
<code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param">chk=None</em>, <em class="sig-param">project=None</em>, <em class="sig-param">kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.nuc_grad_method">
<code class="sig-name descname">nuc_grad_method</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.nuc_grad_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.nuc_grad_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset cell and relevant attributes associated to the old cell object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.to_ghf">
<code class="sig-name descname">to_ghf</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.to_ghf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.to_ghf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a GHF/GKS object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.to_rhf">
<code class="sig-name descname">to_rhf</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.to_rhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.to_rhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a RHF/ROHF/RKS/ROKS object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.to_uhf">
<code class="sig-name descname">to_uhf</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#SCF.to_uhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.to_uhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a UHF/UKS object</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.dip_moment">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">dm</em>, <em class="sig-param">unit='Debye'</em>, <em class="sig-param">verbose=3</em>, <em class="sig-param">grids=None</em>, <em class="sig-param">rho=None</em>, <em class="sig-param">kpt=array([0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.])</em>, <em class="sig-param">origin=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell (is it well defined)?</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm (ndarray) : density matrix</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_bands">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">kpts_band</em>, <em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_hcore">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_hcore</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">kpt=array([0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.])</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#get_hcore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_hcore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the core Hamiltonian AO matrix.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_j">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_j</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">dm</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">vhfopt=None</em>, <em class="sig-param">kpt=array([0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.])</em>, <em class="sig-param">kpts_band=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Coulomb (J) AO matrix for the given density matrix.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian
| 0 : no hermitian or symmetric
| 1 : hermitian
| 2 : anti-hermitian</p>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
<dt>kpt<span class="classifier">(3,) ndarray</span></dt><dd><p>The “inner” dummy k-point at which the DM was evaluated (or
sampled).</p>
</dd>
<dt>kpts_band<span class="classifier">(3,) ndarray or (<a href="#id1"><span class="problematic" id="id2">*</span></a>,3) ndarray</span></dt><dd><p>An arbitrary “band” k-point at which J is evaluated.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>The function returns one J matrix, corresponding to the input
density matrix (both order and shape).</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_jk">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_jk</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">cell</em>, <em class="sig-param">dm</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">vhfopt=None</em>, <em class="sig-param">kpt=array([0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.])</em>, <em class="sig-param">kpts_band=None</em>, <em class="sig-param">with_j=True</em>, <em class="sig-param">with_k=True</em>, <em class="sig-param">omega=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Coulomb (J) and exchange (K) AO matrices for the given density matrix.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian
| 0 : no hermitian or symmetric
| 1 : hermitian
| 2 : anti-hermitian</p>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
<dt>kpt<span class="classifier">(3,) ndarray</span></dt><dd><p>The “inner” dummy k-point at which the DM was evaluated (or
sampled).</p>
</dd>
<dt>kpts_band<span class="classifier">(3,) ndarray or (<a href="#id3"><span class="problematic" id="id4">*</span></a>,3) ndarray</span></dt><dd><p>An arbitrary “band” k-point at which J and K are evaluated.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>The function returns one J and one K matrix, corresponding to the input
density matrix (both order and shape).</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_nuc">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_nuc</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">kpt=array([0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.])</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#get_nuc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_nuc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bare periodic nuc-el AO matrix, with G=0 removed.</p>
<p>See Martin (12.16)-(12.21).</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_ovlp">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_ovlp</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">kpt=array([0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.])</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#get_ovlp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the overlap AO matrix.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_rho">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">grids=None</em>, <em class="sig-param">kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#get_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_t">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_t</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">kpt=array([0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.])</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#get_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the kinetic energy AO matrix.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.init_guess_by_chkfile">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">chkfile_name</em>, <em class="sig-param">project=None</em>, <em class="sig-param">kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">cell</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, (nao,nao) ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.makov_payne_correction">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">makov_payne_correction</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#makov_payne_correction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.makov_payne_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Makov-Payne correction (Phys. Rev. B, 51, 4014)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.normalize_dm_">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">normalize_dm_</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">dm</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/hf.html#normalize_dm_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.normalize_dm_" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale density matrix to make it produce the correct number of electrons.</p>
</dd></dl>

<span class="target" id="module-pyscf.pbc.scf.uhf"></span><p>Unrestricted Hartree-Fock for periodic systems at a single k-point</p>
<dl class="simple">
<dt>See Also:</dt><dd><p>pyscf/pbc/scf/khf.py : Hartree-Fock for periodic systems with k-point sampling</p>
</dd>
</dl>
<dl class="class">
<dt id="pyscf.pbc.scf.uhf.UHF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.uhf.</code><code class="sig-name descname">UHF</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">kpt=array([0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.])</em>, <em class="sig-param">exxdiv='ewald'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/uhf.html#UHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF" title="Permalink to this definition">¶</a></dt>
<dd><p>UHF class for PBCs.</p>
<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.analyze">
<code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param">verbose=None</em>, <em class="sig-param">with_meta_lowdin=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/scf/uhf.html#UHF.analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.canonicalize">
<code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff</em>, <em class="sig-param">mo_occ</em>, <em class="sig-param">fock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.convert_from_">
<code class="sig-name descname">convert_from_</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/uhf.html#UHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to RHF/ROHF</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.dip_moment">
<code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">unit='Debye'</em>, <em class="sig-param">verbose=3</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/uhf.html#UHF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.eig">
<code class="sig-name descname">eig</code><span class="sig-paren">(</span><em class="sig-param">fock</em>, <em class="sig-param">s</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/scf/uhf.html#UHF.eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.energy_elec">
<code class="sig-name descname">energy_elec</code><span class="sig-paren">(</span><em class="sig-param">dm=None</em>, <em class="sig-param">h1e=None</em>, <em class="sig-param">vhf=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Electronic energy of Unrestricted Hartree-Fock</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Hartree-Fock electronic energy and the 2-electron part contribution</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_bands">
<code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param">kpts_band</em>, <em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/uhf.html#UHF.get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_grad">
<code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff</em>, <em class="sig-param">mo_occ</em>, <em class="sig-param">fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/scf/uhf.html#UHF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_rho">
<code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param">dm=None</em>, <em class="sig-param">grids=None</em>, <em class="sig-param">kpt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">dm_last=0</em>, <em class="sig-param">vhf_last=0</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">kpt=None</em>, <em class="sig-param">kpts_band=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/uhf.html#UHF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.init_guess_by_1e">
<code class="sig-name descname">init_guess_by_1e</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/uhf.html#UHF.init_guess_by_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.init_guess_by_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.init_guess_by_atom">
<code class="sig-name descname">init_guess_by_atom</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em>, <em class="sig-param">breaksym=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/scf/uhf.html#UHF.init_guess_by_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.init_guess_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.init_guess_by_chkfile">
<code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param">chk=None</em>, <em class="sig-param">project=True</em>, <em class="sig-param">kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/uhf.html#UHF.init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.init_guess_by_huckel">
<code class="sig-name descname">init_guess_by_huckel</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em>, <em class="sig-param">breaksym=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/scf/uhf.html#UHF.init_guess_by_huckel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.init_guess_by_huckel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.init_guess_by_minao">
<code class="sig-name descname">init_guess_by_minao</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em>, <em class="sig-param">breaksym=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/scf/uhf.html#UHF.init_guess_by_minao"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.init_guess_by_minao" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess in terms of the overlap to minimal basis.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">mo_occ=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/scf/uhf.html#UHF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>A list of 2D ndarrays for alpha and beta spins</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.mulliken_meta">
<code class="sig-name descname">mulliken_meta</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">verbose=5</em>, <em class="sig-param">pre_orth_method='ANO'</em>, <em class="sig-param">s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/scf/uhf.html#UHF.mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or 2-item list of ndarray</span></dt><dd><p>Density matrix.  ROHF dm is a 2-item list of 2D array</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.mulliken_pop">
<code class="sig-name descname">mulliken_pop</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">s=None</em>, <em class="sig-param">verbose=5</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/scf/uhf.html#UHF.mulliken_pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.mulliken_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.spin_square">
<code class="sig-name descname">spin_square</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/scf/uhf.html#UHF.spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square and multiplicity of UHF determinant</p>
<div class="math notranslate nohighlight">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math notranslate nohighlight">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math notranslate nohighlight">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl>
<dt>There are two possibilities for <span class="math notranslate nohighlight">\(S_+ S_-\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron <span class="math notranslate nohighlight">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math notranslate nohighlight">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math notranslate nohighlight">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="math notranslate nohighlight">
\[\langle S_+ S_- \rangle = \langle ij|s_+ s_-|ij\rangle
                        - \langle ij|s_+ s_-|ji\rangle
                        = -\langle i^\alpha|j^\beta\rangle
                           \langle j^\beta|i^\alpha\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Similarly, for <span class="math notranslate nohighlight">\(S_- S_+\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle S_- S_+ \rangle = -\langle i^\beta|j^\alpha\rangle
                           \langle j^\alpha|i^\beta\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>For <span class="math notranslate nohighlight">\(S_z^2\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}&amp;\frac{1}{2}\sum_{ij}(\langle ij|2s_{z1}s_{z2}|ij\rangle
                     -\langle ij|2s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}(n_\alpha^2 - n_\alpha n_\beta - n_\beta n_\alpha + n_\beta^2)
 -\frac{1}{4}(n_\alpha + n_\beta) \\
&amp;=\frac{1}{4}((n_\alpha-n_\beta)^2 - (n_\alpha+n_\beta))\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<p>In total</p>
<div class="math notranslate nohighlight">
\[\begin{split}\langle S^2\rangle &amp;= \frac{1}{2}
(n_\alpha-\sum_{ij}\langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle
+n_\beta -\sum_{ij}\langle i^\beta|j^\alpha\rangle\langle j^\alpha|i^\beta\rangle)
+ \frac{1}{4}(n_\alpha-n_\beta)^2 \\\end{split}\]</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo<span class="classifier">a list of 2 ndarrays</span></dt><dd><p>Occupied alpha and occupied beta orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>s<span class="classifier">ndarray</span></dt><dd><p>AO overlap</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.stability">
<code class="sig-name descname">stability</code><span class="sig-paren">(</span><em class="sig-param">internal=True</em>, <em class="sig-param">external=False</em>, <em class="sig-param">verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/scf/uhf.html#UHF.stability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.stability" title="Permalink to this definition">¶</a></dt>
<dd><p>Stability analysis for RHF/RKS method.</p>
<p>See also pyscf.scf.stability.uhf_stability function.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : UHF or UKS object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the UHF space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. Including the UHF -&gt; GHF and real -&gt; complex
stability analysis.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>New orbitals that are more close to the stable condition.  The return
value includes two set of orbitals.  The first corresponds to the
internal stability and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.uhf.dip_moment">
<code class="sig-prename descclassname">pyscf.pbc.scf.uhf.</code><code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">dm</em>, <em class="sig-param">unit='Debye'</em>, <em class="sig-param">verbose=3</em>, <em class="sig-param">grids=None</em>, <em class="sig-param">rho=None</em>, <em class="sig-param">kpt=array([0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.])</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/uhf.html#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.uhf.init_guess_by_chkfile">
<code class="sig-prename descclassname">pyscf.pbc.scf.uhf.</code><code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">chkfile_name</em>, <em class="sig-param">project=None</em>, <em class="sig-param">kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/uhf.html#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file and make the density matrix
for UHF initial guess.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, (nao,nao) ndarray</p>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-pyscf.pbc.scf.khf"></span><p>Hartree-Fock for periodic systems with k-point sampling</p>
<dl class="simple">
<dt>See Also:</dt><dd><p>hf.py : Hartree-Fock for periodic systems at a single k-point</p>
</dd>
</dl>
<dl class="class">
<dt id="pyscf.pbc.scf.khf.KRHF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">KRHF</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">kpts=array([[0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.]])</em>, <em class="sig-param">exxdiv='ewald'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KRHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KRHF" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pyscf.pbc.scf.khf.KRHF.check_sanity">
<code class="sig-name descname">check_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KRHF.check_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KRHF.check_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KRHF.convert_from_">
<code class="sig-name descname">convert_from_</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KRHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KRHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to KRHF</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KRHF.nuc_grad_method">
<code class="sig-name descname">nuc_grad_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KRHF.nuc_grad_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KRHF.nuc_grad_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyscf.pbc.scf.khf.KSCF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">KSCF</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">kpts=array([[0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.]])</em>, <em class="sig-param">exxdiv='ewald'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class with k-point sampling.</p>
<p>Compared to molecular SCF, some members such as mo_coeff, mo_occ
now have an additional first dimension for the k-points,
e.g. mo_coeff is (nkpts, nao, nao) ndarray</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>kpts<span class="classifier">(nks,3) ndarray</span></dt><dd><p>The sampling k-points in Cartesian coordinates, in units of 1/Bohr.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.analyze">
<code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param">verbose=None</em>, <em class="sig-param">with_meta_lowdin=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.check_sanity">
<code class="sig-name descname">check_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.check_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.check_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.dip_moment">
<code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">unit='Debye'</em>, <em class="sig-param">verbose=3</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell (is it well defined)?</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.eig">
<code class="sig-name descname">eig</code><span class="sig-paren">(</span><em class="sig-param">h_kpts</em>, <em class="sig-param">s_kpts</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.energy_elec">
<code class="sig-name descname">energy_elec</code><span class="sig-paren">(</span><em class="sig-param">dm_kpts=None</em>, <em class="sig-param">h1e_kpts=None</em>, <em class="sig-param">vhf_kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.from_chk">
<code class="sig-name descname">from_chk</code><span class="sig-paren">(</span><em class="sig-param">chk=None</em>, <em class="sig-param">project=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.from_chk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.from_chk" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_bands">
<code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param">kpts_band</em>, <em class="sig-param">cell=None</em>, <em class="sig-param">dm_kpts=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_fermi">
<code class="sig-name descname">get_fermi</code><span class="sig-paren">(</span><em class="sig-param">mo_energy_kpts=None</em>, <em class="sig-param">mo_occ_kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_fermi" title="Permalink to this definition">¶</a></dt>
<dd><p>Fermi level</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_grad">
<code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff_kpts</em>, <em class="sig-param">mo_occ_kpts</em>, <em class="sig-param">fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 1D array of gradients, like non K-pt version
note that occ and virt indices of different k pts now occur
in sequential patches of the 1D array</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_hcore">
<code class="sig-name descname">get_hcore</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_hcore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the core Hamiltonian AO matrices at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>kpts : (nkpts, 3) ndarray</p>
</dd>
<dt>Returns:</dt><dd><p>hcore : (nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_j">
<code class="sig-name descname">get_j</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm_kpts=None</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">kpts=None</em>, <em class="sig-param">kpts_band=None</em>, <em class="sig-param">omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J matrix for the given density matrix and k-point (kpt).
When kpts_band is given, the J matrices on kpts_band are evaluated.</p>
<blockquote>
<div><p>J_{pq} = sum_{rs} (pq|rs) dm[s,r]</p>
</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_jk">
<code class="sig-name descname">get_jk</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm_kpts=None</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">kpts=None</em>, <em class="sig-param">kpts_band=None</em>, <em class="sig-param">with_j=True</em>, <em class="sig-param">with_k=True</em>, <em class="sig-param">omega=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Coulomb (J) and exchange (K) following <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_jk_()</span></code>.
for particular k-point (kpt).</p>
<p>When kpts_band is given, the J, K matrices on kpts_band are evaluated.</p>
<blockquote>
<div><p>J_{pq} = sum_{rs} (pq|rs) dm[s,r]
K_{pq} = sum_{rs} (pr|sq) dm[r,s]</p>
</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_k">
<code class="sig-name descname">get_k</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm_kpts=None</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">kpts=None</em>, <em class="sig-param">kpts_band=None</em>, <em class="sig-param">omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.get_k"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute K matrix for the given density matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_occ">
<code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param">mo_energy_kpts=None</em>, <em class="sig-param">mo_coeff_kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_ovlp">
<code class="sig-name descname">get_ovlp</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the overlap AO matrices at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>kpts : (nkpts, 3) ndarray</p>
</dd>
<dt>Returns:</dt><dd><p>ovlp_kpts : (nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_rho">
<code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param">dm=None</em>, <em class="sig-param">grids=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm_kpts=None</em>, <em class="sig-param">dm_last=0</em>, <em class="sig-param">vhf_last=0</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">kpts=None</em>, <em class="sig-param">kpts_band=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.init_guess_by_1e">
<code class="sig-name descname">init_guess_by_1e</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.init_guess_by_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.init_guess_by_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.init_guess_by_chkfile">
<code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param">chk=None</em>, <em class="sig-param">project=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff_kpts=None</em>, <em class="sig-param">mo_occ_kpts=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix in AO representation</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Orbital coefficients. Each column is one orbital.</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Occupancy</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.mulliken_meta">
<code class="sig-name descname">mulliken_meta</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">verbose=5</em>, <em class="sig-param">pre_orth_method='ANO'</em>, <em class="sig-param">s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or 2-item list of ndarray</span></dt><dd><p>Density matrix.  ROHF dm is a 2-item list of 2D array</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.mulliken_pop">
<code class="sig-name descname">mulliken_pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.mulliken_pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.mulliken_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.to_ghf">
<code class="sig-name descname">to_ghf</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.to_ghf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.to_ghf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a KGHF/KGKS object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.to_rhf">
<code class="sig-name descname">to_rhf</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.to_rhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.to_rhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a KRHF/KROHF/KRKS/KROKS object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.to_uhf">
<code class="sig-name descname">to_uhf</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#KSCF.to_uhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.to_uhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a KUHF/KUKS object</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.analyze">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">verbose=5</em>, <em class="sig-param">with_meta_lowdin=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Dipole moment</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.dip_moment">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">dm_kpts</em>, <em class="sig-param">unit='Debye'</em>, <em class="sig-param">verbose=3</em>, <em class="sig-param">grids=None</em>, <em class="sig-param">rho=None</em>, <em class="sig-param">kpts=array([[0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.]])</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell (is it well defined)?</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.energy_elec">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">energy_elec</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">dm_kpts=None</em>, <em class="sig-param">h1e_kpts=None</em>, <em class="sig-param">vhf_kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#energy_elec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_fermi">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_fermi</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">mo_energy_kpts=None</em>, <em class="sig-param">mo_occ_kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#get_fermi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_fermi" title="Permalink to this definition">¶</a></dt>
<dd><p>Fermi level</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_grad">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff_kpts</em>, <em class="sig-param">mo_occ_kpts</em>, <em class="sig-param">fock</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 1D array of gradients, like non K-pt version
note that occ and virt indices of different k pts now occur
in sequential patches of the 1D array</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_hcore">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_hcore</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">cell=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#get_hcore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_hcore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the core Hamiltonian AO matrices at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>kpts : (nkpts, 3) ndarray</p>
</dd>
<dt>Returns:</dt><dd><p>hcore : (nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_j">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_j</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">cell</em>, <em class="sig-param">dm_kpts</em>, <em class="sig-param">kpts</em>, <em class="sig-param">kpts_band=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Coulomb (J) AO matrix at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>dm_kpts<span class="classifier">(nkpts, nao, nao) ndarray or a list of (nkpts,nao,nao) ndarray</span></dt><dd><p>Density matrix at each k-point.  If a list of k-point DMs, eg,
UHF alpha and beta DM, the alpha and beta DMs are contracted
separately.  It needs to be Hermitian.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>kpts_band<span class="classifier">(k,3) ndarray</span></dt><dd><p>A list of arbitrary “band” k-points at which to evalute the matrix.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>vj : (nkpts, nao, nao) ndarray
or list of vj if the input dm_kpts is a list of DMs</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_jk">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_jk</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">cell</em>, <em class="sig-param">dm_kpts</em>, <em class="sig-param">kpts</em>, <em class="sig-param">kpts_band=None</em>, <em class="sig-param">with_j=True</em>, <em class="sig-param">with_k=True</em>, <em class="sig-param">omega=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Coulomb (J) and exchange (K) AO matrices at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>dm_kpts<span class="classifier">(nkpts, nao, nao) ndarray</span></dt><dd><p>Density matrix at each k-point. It needs to be Hermitian.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>kpts_band<span class="classifier">(3,) ndarray</span></dt><dd><p>A list of arbitrary “band” k-point at which to evalute the matrix.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>vj : (nkpts, nao, nao) ndarray
vk : (nkpts, nao, nao) ndarray
or list of vj and vk if the input dm_kpts is a list of DMs</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_occ">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">mo_energy_kpts=None</em>, <em class="sig-param">mo_coeff_kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#get_occ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_ovlp">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_ovlp</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">cell=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#get_ovlp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the overlap AO matrices at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>kpts : (nkpts, 3) ndarray</p>
</dd>
<dt>Returns:</dt><dd><p>ovlp_kpts : (nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_rho">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">grids=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#get_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.init_guess_by_chkfile">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">chkfile_name</em>, <em class="sig-param">project=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the KHF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">cell</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 3D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.make_rdm1">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff_kpts</em>, <em class="sig-param">mo_occ_kpts</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One particle density matrices for all k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>dm_kpts : (nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.mulliken_meta">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">mulliken_meta</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">dm_ao_kpts</em>, <em class="sig-param">verbose=5</em>, <em class="sig-param">pre_orth_method='ANO'</em>, <em class="sig-param">s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/khf.html#mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>A modified Mulliken population analysis, based on meta-Lowdin AOs.</p>
<p>Note this function only computes the Mulliken population for the gamma
point density matrix.</p>
</dd></dl>

<span class="target" id="module-pyscf.pbc.scf.kuhf"></span><p>Hartree-Fock for periodic systems with k-point sampling</p>
<dl class="simple">
<dt>See Also:</dt><dd><p>hf.py : Hartree-Fock for periodic systems at a single k-point</p>
</dd>
</dl>
<dl class="class">
<dt id="pyscf.pbc.scf.kuhf.KUHF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">KUHF</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">kpts=array([[0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.]])</em>, <em class="sig-param">exxdiv='ewald'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF" title="Permalink to this definition">¶</a></dt>
<dd><p>UHF class with k-point sampling.</p>
<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.analyze">
<code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param">verbose=None</em>, <em class="sig-param">with_meta_lowdin=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.canonicalize">
<code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff_kpts</em>, <em class="sig-param">mo_occ_kpts</em>, <em class="sig-param">fock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.convert_from_">
<code class="sig-name descname">convert_from_</code><span class="sig-paren">(</span><em class="sig-param">mf</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to KUHF</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.dip_moment">
<code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">unit='Debye'</em>, <em class="sig-param">verbose=3</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (two lists of ndarrays) : KUHF density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.eig">
<code class="sig-name descname">eig</code><span class="sig-paren">(</span><em class="sig-param">h_kpts</em>, <em class="sig-param">s_kpts</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.energy_elec">
<code class="sig-name descname">energy_elec</code><span class="sig-paren">(</span><em class="sig-param">dm_kpts=None</em>, <em class="sig-param">h1e_kpts=None</em>, <em class="sig-param">vhf_kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_bands">
<code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param">kpts_band</em>, <em class="sig-param">cell=None</em>, <em class="sig-param">dm_kpts=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_fermi">
<code class="sig-name descname">get_fermi</code><span class="sig-paren">(</span><em class="sig-param">mo_energy_kpts=None</em>, <em class="sig-param">mo_occ_kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_fermi" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair of Fermi level for spin-up and spin-down orbitals</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_grad">
<code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff_kpts</em>, <em class="sig-param">mo_occ_kpts</em>, <em class="sig-param">fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 1D array of gradients, like non K-pt version
note that occ and virt indices of different k pts now occur
in sequential patches of the 1D array</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_occ">
<code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param">mo_energy_kpts=None</em>, <em class="sig-param">mo_coeff_kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_rho">
<code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param">dm=None</em>, <em class="sig-param">grids=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm_kpts=None</em>, <em class="sig-param">dm_last=0</em>, <em class="sig-param">vhf_last=0</em>, <em class="sig-param">hermi=1</em>, <em class="sig-param">kpts=None</em>, <em class="sig-param">kpts_band=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.init_guess_by_1e">
<code class="sig-name descname">init_guess_by_1e</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.init_guess_by_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.init_guess_by_atom">
<code class="sig-name descname">init_guess_by_atom</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em>, <em class="sig-param">breaksym=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.init_guess_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.init_guess_by_chkfile">
<code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param">chk=None</em>, <em class="sig-param">project=True</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.init_guess_by_huckel">
<code class="sig-name descname">init_guess_by_huckel</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em>, <em class="sig-param">breaksym=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.init_guess_by_huckel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.init_guess_by_minao">
<code class="sig-name descname">init_guess_by_minao</code><span class="sig-paren">(</span><em class="sig-param">mol=None</em>, <em class="sig-param">breaksym=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.init_guess_by_minao" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess in terms of the overlap to minimal basis.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff_kpts=None</em>, <em class="sig-param">mo_occ_kpts=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>A list of 2D ndarrays for alpha and beta spins</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.mulliken_meta">
<code class="sig-name descname">mulliken_meta</code><span class="sig-paren">(</span><em class="sig-param">cell=None</em>, <em class="sig-param">dm=None</em>, <em class="sig-param">verbose=5</em>, <em class="sig-param">pre_orth_method='ANO'</em>, <em class="sig-param">s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>A modified Mulliken population analysis, based on meta-Lowdin AOs.</p>
<p>Note this function only computes the Mulliken population for the gamma
point density matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.mulliken_pop">
<code class="sig-name descname">mulliken_pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.mulliken_pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.mulliken_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.nuc_grad_method">
<code class="sig-name descname">nuc_grad_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.nuc_grad_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.nuc_grad_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.spin_square">
<code class="sig-name descname">spin_square</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff=None</em>, <em class="sig-param">s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square and multiplicity of UHF determinant</p>
<div class="math notranslate nohighlight">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math notranslate nohighlight">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math notranslate nohighlight">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl>
<dt>There are two possibilities for <span class="math notranslate nohighlight">\(S_+ S_-\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron <span class="math notranslate nohighlight">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math notranslate nohighlight">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math notranslate nohighlight">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="math notranslate nohighlight">
\[\langle S_+ S_- \rangle = \langle ij|s_+ s_-|ij\rangle
                        - \langle ij|s_+ s_-|ji\rangle
                        = -\langle i^\alpha|j^\beta\rangle
                           \langle j^\beta|i^\alpha\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Similarly, for <span class="math notranslate nohighlight">\(S_- S_+\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle S_- S_+ \rangle = -\langle i^\beta|j^\alpha\rangle
                           \langle j^\alpha|i^\beta\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>For <span class="math notranslate nohighlight">\(S_z^2\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}&amp;\frac{1}{2}\sum_{ij}(\langle ij|2s_{z1}s_{z2}|ij\rangle
                     -\langle ij|2s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}(n_\alpha^2 - n_\alpha n_\beta - n_\beta n_\alpha + n_\beta^2)
 -\frac{1}{4}(n_\alpha + n_\beta) \\
&amp;=\frac{1}{4}((n_\alpha-n_\beta)^2 - (n_\alpha+n_\beta))\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<p>In total</p>
<div class="math notranslate nohighlight">
\[\begin{split}\langle S^2\rangle &amp;= \frac{1}{2}
(n_\alpha-\sum_{ij}\langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle
+n_\beta -\sum_{ij}\langle i^\beta|j^\alpha\rangle\langle j^\alpha|i^\beta\rangle)
+ \frac{1}{4}(n_\alpha-n_\beta)^2 \\\end{split}\]</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo<span class="classifier">a list of 2 ndarrays</span></dt><dd><p>Occupied alpha and occupied beta orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>s<span class="classifier">ndarray</span></dt><dd><p>AO overlap</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.stability">
<code class="sig-name descname">stability</code><span class="sig-paren">(</span><em class="sig-param">internal=True</em>, <em class="sig-param">external=False</em>, <em class="sig-param">verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#KUHF.stability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.stability" title="Permalink to this definition">¶</a></dt>
<dd><p>Stability analysis for RHF/RKS method.</p>
<p>See also pyscf.scf.stability.uhf_stability function.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : UHF or UKS object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the UHF space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. Including the UHF -&gt; GHF and real -&gt; complex
stability analysis.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>New orbitals that are more close to the stable condition.  The return
value includes two set of orbitals.  The first corresponds to the
internal stability and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.canonicalize">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">mo_coeff_kpts</em>, <em class="sig-param">mo_occ_kpts</em>, <em class="sig-param">fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#canonicalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.dip_moment">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">dm_kpts</em>, <em class="sig-param">unit='Debye'</em>, <em class="sig-param">verbose=3</em>, <em class="sig-param">grids=None</em>, <em class="sig-param">rho=None</em>, <em class="sig-param">kpts=array([[0.</em>, <em class="sig-param">0.</em>, <em class="sig-param">0.]])</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (two lists of ndarrays) : KUHF density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.energy_elec">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">energy_elec</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">dm_kpts=None</em>, <em class="sig-param">h1e_kpts=None</em>, <em class="sig-param">vhf_kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#energy_elec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.get_fermi">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">get_fermi</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">mo_energy_kpts=None</em>, <em class="sig-param">mo_occ_kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#get_fermi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.get_fermi" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair of Fermi level for spin-up and spin-down orbitals</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.get_occ">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">mo_energy_kpts=None</em>, <em class="sig-param">mo_coeff_kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#get_occ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.init_guess_by_chkfile">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">chkfile_name</em>, <em class="sig-param">project=None</em>, <em class="sig-param">kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the KHF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">cell</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 3D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.make_rdm1">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param">mo_coeff_kpts</em>, <em class="sig-param">mo_occ_kpts</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha and beta spin one particle density matrices for all k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>dm_kpts : (2, nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.mulliken_meta">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">mulliken_meta</code><span class="sig-paren">(</span><em class="sig-param">cell</em>, <em class="sig-param">dm_ao_kpts</em>, <em class="sig-param">verbose=5</em>, <em class="sig-param">pre_orth_method='ANO'</em>, <em class="sig-param">s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/pbc/scf/kuhf.html#mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>A modified Mulliken population analysis, based on meta-Lowdin AOs.</p>
<p>Note this function only computes the Mulliken population for the gamma
point density matrix.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dft.html" class="btn btn-neutral float-right" title="10.21.4. pbc.dft — DFT with PBCs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ao2mo.html" class="btn btn-neutral float-left" title="10.21.2. pbc.ao2mo — Integral transformations for crystalline Gaussian type orbitals" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2019, The PySCF Developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>