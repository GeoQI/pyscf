

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>10.3. cc — Coupled cluster &mdash; PySCF 1.7.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="10.4. ccn — Auto-generated coupled cluster of arbitrary order" href="ccn.html" />
    <link rel="prev" title="10.2. ao2mo — Integral transformations" href="ao2mo.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../version.html">2. Version history</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code-rule.html">4. Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmark.html">5. Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">6. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory.html">7. Theoretical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced.html">8. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interface.html">9. Interfaces</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../modules.html">10. Main modules</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="adc.html">10.1. <code class="xref py py-mod docutils literal notranslate"><span class="pre">adc</span></code> — Algebraic diagrammatic construction (ADC) scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="ao2mo.html">10.2. <code class="xref py py-mod docutils literal notranslate"><span class="pre">ao2mo</span></code> — Integral transformations</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">10.3. <code class="xref py py-mod docutils literal notranslate"><span class="pre">cc</span></code> — Coupled cluster</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#examples">10.3.1. Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#a-general-solver-for-customized-hamiltonian">10.3.1.1. A general solver for customized Hamiltonian</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-ccsd-as-casci-active-space-solver">10.3.1.2. Using CCSD as CASCI active space solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gamma-point-ccsd-with-periodic-boundary-condition">10.3.1.3. Gamma point CCSD with Periodic boundary condition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ccsd-with-truncated-mos-to-avoid-linear-dependency">10.3.1.4. CCSD with truncated MOs to avoid linear dependency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#response-and-un-relaxed-ccsd-density-matrix">10.3.1.5. Response and un-relaxed CCSD density matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reusing-integrals-in-ccsd-and-relevant-calculations">10.3.1.6. Reusing integrals in CCSD and relevant calculations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interfering-ccsd-diis">10.3.1.7. Interfering CCSD-DIIS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#restart-ccsd">10.3.1.8. Restart CCSD</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#program-reference">10.3.2. Program reference</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cc-ccsd-module-and-ccsd-class">10.3.2.1. cc.ccsd module and CCSD class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cc-rccsd-and-rccsd-class">10.3.2.2. cc.rccsd and RCCSD class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cc-uccsd-and-uccsd-class">10.3.2.3. cc.uccsd and UCCSD class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cc-addons">10.3.2.4. cc.addons</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ccsd-t">10.3.2.5. CCSD(T)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ccsd-gradients">10.3.2.6. CCSD gradients</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ccn.html">10.4. <code class="xref py py-mod docutils literal notranslate"><span class="pre">ccn</span></code> — Auto-generated coupled cluster of arbitrary order</a></li>
<li class="toctree-l2"><a class="reference internal" href="ci.html">10.5. <code class="xref py py-mod docutils literal notranslate"><span class="pre">ci</span></code> — Configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="data.html">10.6. <code class="xref py py-mod docutils literal notranslate"><span class="pre">data</span></code> — Data for constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="df.html">10.7. <code class="xref py py-mod docutils literal notranslate"><span class="pre">df</span></code> — Density fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="dft.html">10.8. <code class="xref py py-mod docutils literal notranslate"><span class="pre">dft</span></code> — Density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="doci.html">10.9. <code class="xref py py-mod docutils literal notranslate"><span class="pre">doci</span></code> — Doubly occupied configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="fci.html">10.10. <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code> — Full configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="grad.html">10.11. <code class="xref py py-mod docutils literal notranslate"><span class="pre">grad</span></code> — Analytical nuclear gradients</a></li>
<li class="toctree-l2"><a class="reference internal" href="gto.html">10.12. <code class="xref py py-mod docutils literal notranslate"><span class="pre">gto</span></code> — Molecular structure and GTO basis</a></li>
<li class="toctree-l2"><a class="reference internal" href="gw.html">10.13. <code class="xref py py-mod docutils literal notranslate"><span class="pre">gw</span></code> — Molecular G0W0</a></li>
<li class="toctree-l2"><a class="reference internal" href="hci.html">10.14. <code class="xref py py-mod docutils literal notranslate"><span class="pre">hci</span></code> — Heat-bath selected CI</a></li>
<li class="toctree-l2"><a class="reference internal" href="hessian.html">10.15. <code class="xref py py-mod docutils literal notranslate"><span class="pre">hessian</span></code> — Analytical nuclear Hessian</a></li>
<li class="toctree-l2"><a class="reference internal" href="lib.html">10.16. <code class="xref py py-mod docutils literal notranslate"><span class="pre">lib</span></code> — Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="lo.html">10.17. <code class="xref py py-mod docutils literal notranslate"><span class="pre">lo</span></code> — Orbital localization and analysis tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="mcscf.html">10.18. <code class="xref py py-mod docutils literal notranslate"><span class="pre">mcscf</span></code> — Multi-configurational self-consistent field</a></li>
<li class="toctree-l2"><a class="reference internal" href="mp.html">10.19. <code class="xref py py-mod docutils literal notranslate"><span class="pre">mp</span></code> — MP2</a></li>
<li class="toctree-l2"><a class="reference internal" href="mrpt.html">10.20. <code class="xref py py-mod docutils literal notranslate"><span class="pre">mrpt</span></code> — Multi-reference perturbation theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="pbc.html">10.21. <code class="xref py py-mod docutils literal notranslate"><span class="pre">pbc</span></code> — Periodic boundary conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="prop.html">10.22. <code class="xref py py-mod docutils literal notranslate"><span class="pre">prop</span></code> — Molecular properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="qmmm.html">10.23. <code class="xref py py-mod docutils literal notranslate"><span class="pre">qmmm</span></code> — QM/MM interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rt.html">10.24. <code class="xref py py-mod docutils literal notranslate"><span class="pre">rt</span></code> — Real-time time-dependent density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="scf.html">10.25. <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf</span></code> — Self-consistent field methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="semiempirical.html">10.26. <code class="xref py py-mod docutils literal notranslate"><span class="pre">semiempirical</span></code> — Semiempirical methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="sgx.html">10.27. <code class="xref py py-mod docutils literal notranslate"><span class="pre">sgx</span></code> — Pseudo-spectral methods (COSX, PS, SN-K)</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvent.html">10.28. <code class="xref py py-mod docutils literal notranslate"><span class="pre">solvent</span></code> — Solvent methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="soscf.html">10.29. <code class="xref py py-mod docutils literal notranslate"><span class="pre">soscf</span></code> — Second order SCF solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="symm.html">10.30. <code class="xref py py-mod docutils literal notranslate"><span class="pre">symm</span></code> – Point group symmetry and spin symmetry</a></li>
<li class="toctree-l2"><a class="reference internal" href="tdscf.html">10.31. <code class="xref py py-mod docutils literal notranslate"><span class="pre">tdscf</span></code> — TDHF and TDDFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">10.32. <code class="xref py py-mod docutils literal notranslate"><span class="pre">tools</span></code> — Useful tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="x2c.html">10.33. <code class="xref py py-mod docutils literal notranslate"><span class="pre">x2c</span></code> — exact-two-component approach</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PySCF</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../modules.html"><span class="section-number">10. </span>Main modules</a> &raquo;</li>
        
      <li><span class="section-number">10.3. </span><code class="xref py py-mod docutils literal notranslate"><span class="pre">cc</span></code> — Coupled cluster</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/modules/cc.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-cc">
<span id="cc-coupled-cluster"></span><span id="cc"></span><h1><span class="section-number">10.3. </span><a class="reference internal" href="#module-cc" title="cc: Coupled cluster energies and properties"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cc</span></code></a> — Coupled cluster<a class="headerlink" href="#module-cc" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="#module-cc" title="cc: Coupled cluster energies and properties"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cc</span></code></a> module implements the coupled cluster (CC) model to compute
energies, analytical nuclear gradients, density matrices, excited states, and
relevant properties.</p>
<p>To compute the CC energy, one first needs to perform a mean-field calculation using
the mean-field module <a class="reference internal" href="scf.html#module-scf" title="scf: restricted and unrestricted, closed shell and open shell Hartree-Fock methods"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scf</span></code></a>.  The mean-field object defines the Hamiltonian
and the problem size, which are used to initialize the CC object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>Unrelaxed density matrices are evaluated in the MO basis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dm1</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="n">dm2</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">()</span>
</pre></div>
</div>
<p>The CCSD(T) energy can be obtained by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="k">import</span> <span class="n">ccsd_t</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ccsd_t</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Gradients are available:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="k">import</span> <span class="n">ccsd_grad</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">grad</span>
<span class="n">grad_e</span> <span class="o">=</span> <span class="n">ccsd_grad</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">)</span>
<span class="n">grad_n</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">grad_nuc</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">grad</span> <span class="o">=</span> <span class="n">grad_e</span> <span class="o">+</span> <span class="n">grad_nuc</span>
</pre></div>
</div>
<p>Excited states can be calculated with ionization potential (IP), electron affinity (EA),
and electronic excitation (EE) equation-of-motion (EOM) CCSD:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">RCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">e_ip</span><span class="p">,</span> <span class="n">c_ip</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e_ea</span><span class="p">,</span> <span class="n">c_ea</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eaccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e_ee</span><span class="p">,</span> <span class="n">c_ee</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eeccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">UCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">e_ip</span><span class="p">,</span> <span class="n">c_ip</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e_ea</span><span class="p">,</span> <span class="n">c_ea</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eaccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e_ee</span><span class="p">,</span> <span class="n">c_ee</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eeccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>All CC methods have two implementations.  One is simple and highly readable (suffixed
by <code class="docutils literal notranslate"><span class="pre">_slow</span></code> in the filename) and the other is extensively optimized for
computational efficiency.
All code in the <code class="docutils literal notranslate"><span class="pre">_slow</span></code> versions is structured as close as
possible to the formulas documented in the literature.  Pure Python/numpy
data structures and functions are used so that explicit memory management is avoided.
It is easy to make modifications or develop new methods based on the slow
implementations.</p>
<p>The computationally efficient (outcore) version is the default implementation
for the CC module.  In this implementation, the CPU usage, memory footprint,
memory efficiency, and IO overhead are carefully considered.  To keep a small
memory footprint, most integral tensors are stored on disk.  IO is one of the
main bottlenecks in this implementation.  Two techniques are used to reduce
the IO overhead.  One is the asynchronized IO to overlap the computation and
reading/writing of the 4-index tensors.  The other is AO-driven for the
contraction of T2 and <code class="docutils literal notranslate"><span class="pre">(vv|vv)</span></code> integrals in CCSD and CCSD-lambda functions.
These techniques allow the CC module to efficiently handle medium-sized
systems.  In a test system with 25 occupied orbitals and 1500 virtual orbitals, each
CCSD iteration takes about 2.5 hours.  The program does not automatically
switch to AO-driven CCSD for large systems.  The user must manually set the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">direct</span></code> attribute to enable an AO-driven CCSD calculation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">direct</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>Some of the CC methods have an efficient incore implementation, where
all tensors are held in memory.  The incore implementation reduces the IO overhead
and optimizes certain formulas to gain the best FLOPS.  It is about 30% faster
than the outcore implementation.  Depending on the available memory, the incore
code can be used for systems with up to approximately 250 orbitals.</p>
<p>Point group symmetry is not considered in the CCSD programs, but it is used in
the CCSD(T) code to gain the best performance.</p>
<p>Arbitrary frozen orbitals (not limited to frozen core) are supported
by the CCSD, CCSD(T), density matrices, and EOM-CCSD modules, but not in
the analytical CCSD gradient module.</p>
<div class="section" id="examples">
<h2><span class="section-number">10.3.1. </span>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>This section documents some examples about how to effectively use the CCSD
module, and how to incorporate the CCSD solver with other PySCF functions to
perform advanced simulations.  For a complete list of CC examples, see
<code class="docutils literal notranslate"><span class="pre">pyscf/examples/cc</span></code>.</p>
<div class="section" id="a-general-solver-for-customized-hamiltonian">
<h3><span class="section-number">10.3.1.1. </span>A general solver for customized Hamiltonian<a class="headerlink" href="#a-general-solver-for-customized-hamiltonian" title="Permalink to this headline">¶</a></h3>
<p>The CC module is not limited to molecular systems.  The program is implemented as
a general solver for arbitrary Hamiltonians.  It allows users to overwrite the
default molecular Hamiltonian with their own effective Hamiltonians.  In this
example, we create a Hubbard model and feed its Hamiltonian to the CCSD module.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Six-site 1D U/t=2 Hubbard-like model system with PBC at half filling.</span>
<span class="sd">The model is gapped at the mean-field level</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">ao2mo</span><span class="p">,</span> <span class="n">cc</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">=</span> <span class="n">n</span>
<span class="c1"># Setting incore_anyway=True to ensure the customized Hamiltonian (the _eri</span>
<span class="c1"># attribute) to be used in the post-HF calculations.  Without this parameter,</span>
<span class="c1"># some post-HF method (particularly in the MO integral transformation) may</span>
<span class="c1"># ignore the customized Hamiltonian if memory is not enough.</span>
<span class="n">mol</span><span class="o">.</span><span class="n">incore_anyway</span> <span class="o">=</span> <span class="kc">True</span>

<span class="n">h1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">h1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
<span class="n">h1</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
<span class="n">eri</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">eri</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">get_hcore</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">h1</span>
<span class="n">mf</span><span class="o">.</span><span class="n">get_ovlp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">_eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">eri</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>


<span class="c1"># In PySCF, the customized Hamiltonian needs to be created once in mf object.</span>
<span class="c1"># The Hamiltonian will be used everywhere whenever possible.  Here, the model</span>
<span class="c1"># Hamiltonian is passed to CCSD object via the mf object.</span>

<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">RCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">e</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="using-ccsd-as-casci-active-space-solver">
<h3><span class="section-number">10.3.1.2. </span>Using CCSD as CASCI active space solver<a class="headerlink" href="#using-ccsd-as-casci-active-space-solver" title="Permalink to this headline">¶</a></h3>
<p>CCSD program can be wrapped as a Full CI solver, which can be combined with the
CASCI solver to approximate the multi-configuration calculation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Using the CCSD method as the active space solver to compute an approximate</span>
<span class="sd">CASCI energy.</span>

<span class="sd">A wrapper is required to adapt the CCSD solver to CASCI fcisolver interface.</span>
<span class="sd">Inside the wrapper function, the CCSD code is the same as the example</span>
<span class="sd">40-ccsd_with_given_hamiltonian.py</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">ao2mo</span><span class="p">,</span> <span class="n">mcscf</span>

<span class="k">class</span> <span class="nc">AsFCISolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">,</span> <span class="n">ci0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ecore</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">fakemol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nelec</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nelec</span><span class="p">)</span>
        <span class="n">fakemol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">=</span> <span class="n">nelec</span>
        <span class="n">fake_hf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">fakemol</span><span class="p">)</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">_eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">h2</span><span class="p">,</span> <span class="n">norb</span><span class="p">)</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">get_hcore</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">h1</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">get_ovlp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">norb</span><span class="p">)</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">fake_hf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eris</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">()</span>
        <span class="n">e_corr</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eris</span><span class="p">)</span>
        <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">solve_lambda</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">eris</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eris</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">fake_hf</span><span class="o">.</span><span class="n">e_tot</span> <span class="o">+</span> <span class="n">e_corr</span>
        <span class="k">return</span> <span class="n">e</span><span class="o">+</span><span class="n">ecore</span><span class="p">,</span> <span class="n">CCSDAmplitudesAsCIWfn</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_rdm1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">):</span>
        <span class="n">mo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">mo_coeff</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">fake_ci</span><span class="o">.</span><span class="n">t1</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">fake_ci</span><span class="o">.</span><span class="n">t2</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="n">fake_ci</span><span class="o">.</span><span class="n">l1</span>
        <span class="n">l2</span> <span class="o">=</span> <span class="n">fake_ci</span><span class="o">.</span><span class="n">l2</span>
        <span class="n">dm1</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">),</span> <span class="n">mo</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dm1</span>

    <span class="k">def</span> <span class="nf">make_rdm12</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">):</span>
        <span class="n">mo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">mo_coeff</span>
        <span class="n">nmo</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">fake_ci</span><span class="o">.</span><span class="n">t1</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">fake_ci</span><span class="o">.</span><span class="n">t2</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="n">fake_ci</span><span class="o">.</span><span class="n">l1</span>
        <span class="n">l2</span> <span class="o">=</span> <span class="n">fake_ci</span><span class="o">.</span><span class="n">l2</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nmo</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">nmo</span><span class="p">),</span> <span class="n">mo</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">nmo</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nmo</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">nmo</span><span class="p">),</span> <span class="n">mo</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="n">dm2</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">nmo</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">(</span><span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">),</span> <span class="n">dm2</span>

    <span class="k">def</span> <span class="nf">spin_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>

<span class="k">class</span> <span class="nc">CCSDAmplitudesAsCIWfn</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t1</span> <span class="o">=</span> <span class="n">t1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t2</span> <span class="o">=</span> <span class="n">t2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.2&#39;</span><span class="p">,</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">norb</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">nelec</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">AsFCISolver</span><span class="p">()</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

</pre></div>
</div>
</div>
<div class="section" id="gamma-point-ccsd-with-periodic-boundary-condition">
<h3><span class="section-number">10.3.1.3. </span>Gamma point CCSD with Periodic boundary condition<a class="headerlink" href="#gamma-point-ccsd-with-periodic-boundary-condition" title="Permalink to this headline">¶</a></h3>
<p>Integrals in Gamma point of periodic Hartree-Fock calculation are all real.
You can feed the integrals into any pyscf molecular module using the same
operations as the above example.  However, the interface between PBC code and
molecular code are more compatible.  You can treat the crystal object and the
molecule object in the same manner.  In this example, you can pass the PBC mean
field method to CC module to have the gamma point CCSD correlation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Gamma point post-HF calculation needs only real integrals.</span>
<span class="sd">Methods implemented in finite-size system can be directly used here without</span>
<span class="sd">any modification.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mf">3.5668</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;C     0.      0.      0.    </span>
<span class="s1">              C     0.8917  0.8917  0.8917</span>
<span class="s1">              C     1.7834  1.7834  0.    </span>
<span class="s1">              C     2.6751  2.6751  0.8917</span>
<span class="s1">              C     1.7834  0.      1.7834</span>
<span class="s1">              C     2.6751  0.8917  2.6751</span>
<span class="s1">              C     0.      1.7834  1.7834</span>
<span class="s1">              C     0.8917  2.6751  2.6751&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;6-31g&#39;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Import CC, TDDFT module from the molecular implementations</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">cc</span><span class="p">,</span> <span class="n">tddft</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="n">mytd</span> <span class="o">=</span> <span class="n">tddft</span><span class="o">.</span><span class="n">TDHF</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mytd</span><span class="o">.</span><span class="n">nstates</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">mytd</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="ccsd-with-truncated-mos-to-avoid-linear-dependency">
<h3><span class="section-number">10.3.1.4. </span>CCSD with truncated MOs to avoid linear dependency<a class="headerlink" href="#ccsd-with-truncated-mos-to-avoid-linear-dependency" title="Permalink to this headline">¶</a></h3>
<p>It is common to have linear dependence when one wants to systematically enlarge
the AO basis set to approach complete basis set limit.  The numerical
instability usually has noticeable effects on the CCSD convergence.  An
effective way to remove this negative effects is to truncate the AO sets and
allow the MO orbitals being less than AO functions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">:func:`scf.addons.remove_linear_dep_` discards the small eigenvalues of overlap</span>
<span class="sd">matrix.  This reduces the number of MOs from 50 to 49.  The problem size of</span>
<span class="sd">the following CCSD method is 49.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)]</span>
<span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span>
<span class="n">mol</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">remove_linear_dep_</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

</pre></div>
</div>
</div>
<div class="section" id="response-and-un-relaxed-ccsd-density-matrix">
<h3><span class="section-number">10.3.1.5. </span>Response and un-relaxed CCSD density matrix<a class="headerlink" href="#response-and-un-relaxed-ccsd-density-matrix" title="Permalink to this headline">¶</a></h3>
<p>CCSD has two kinds of one-particle density matrices.  The (second order)
un-relaxed density matrix and the (relaxed) response density matrix.  The
<code class="xref py py-func docutils literal notranslate"><span class="pre">CCSD.make_rdm1()</span></code> function computes the un-relaxed density matrix which is
associated to the regular CCSD energy formula.  The response density is mainly
used to compute the first order response quantities eg the analytical nuclear
gradients.  It is not recommended to use the response density matrix for
population analysis.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#</span>
<span class="c1"># Author: Qiming Sun &lt;osirpt.sun@gmail.com&gt;</span>
<span class="c1">#</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">CCSD density matrix</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">ao2mo</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># CCSD density matrix in MO basis</span>
<span class="c1">#</span>
<span class="n">dm1</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="n">dm2</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># CCSD energy based on density matrices</span>
<span class="c1">#</span>
<span class="n">h1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;pi,pq,qj-&gt;ij&#39;</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">mf</span><span class="o">.</span><span class="n">get_hcore</span><span class="p">(),</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">)</span>
<span class="n">nmo</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">nmo</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;pq,qp&#39;</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">dm1</span><span class="p">)</span>
<span class="c1"># Note dm2 is transposed to simplify its contraction to integrals</span>
<span class="n">E</span><span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;pqrs,pqrs&#39;</span><span class="p">,</span> <span class="n">eri</span><span class="p">,</span> <span class="n">dm2</span><span class="p">)</span> <span class="o">*</span> <span class="o">.</span><span class="mi">5</span>
<span class="n">E</span><span class="o">+=</span> <span class="n">mol</span><span class="o">.</span><span class="n">energy_nuc</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;E(CCSD) = </span><span class="si">%s</span><span class="s1">, reference </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">e_tot</span><span class="p">))</span>


<span class="c1"># When plotting CCSD density on the grids, CCSD density matrices need to be</span>
<span class="c1"># first transformed to AO basis.</span>
<span class="n">dm1_ao</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;pi,ij,qj-&gt;pq&#39;</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>

<span class="kn">from</span> <span class="nn">pyscf.tools</span> <span class="k">import</span> <span class="n">cubegen</span>
<span class="n">cubegen</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="s1">&#39;rho_ccsd.cube&#39;</span><span class="p">,</span> <span class="n">dm1_ao</span><span class="p">)</span>

</pre></div>
</div>
</div>
<div class="section" id="reusing-integrals-in-ccsd-and-relevant-calculations">
<h3><span class="section-number">10.3.1.6. </span>Reusing integrals in CCSD and relevant calculations<a class="headerlink" href="#reusing-integrals-in-ccsd-and-relevant-calculations" title="Permalink to this headline">¶</a></h3>
<p>By default the CCSD solver and the relevant CCSD lambda solver, CCSD(T), CCSD
gradients program generate MO integrals in their own runtime.  But in most
scenario, the same MO integrals can be generated once and reused in the four
modules.  To remove the overhead of recomputing MO integrals, the three module
support user to feed MO integrals.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#</span>
<span class="c1"># Author: Qiming Sun &lt;osirpt.sun@gmail.com&gt;</span>
<span class="c1">#</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">To avoid recomputing AO to MO integral transformation, integrals for CCSD,</span>
<span class="sd">CCSD(T), CCSD lambda equation etc can be reused.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># CCSD module allows you feed MO integrals</span>
<span class="c1">#</span>
<span class="n">eris</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">()</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># The same MO integrals can be used in CCSD lambda equation</span>
<span class="c1">#</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">solve_lambda</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># CCSD(T) module requires the same integrals used by CCSD module</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="k">import</span> <span class="n">ccsd_t</span>
<span class="n">ccsd_t</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># CCSD gradients need zeroth order MO integrals when solving the &quot;relaxed&quot;</span>
<span class="c1"># 1-particle density matrix.</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">pyscf.grad.ccsd</span> <span class="k">import</span> <span class="n">Gradients</span>
<span class="n">grad_e</span> <span class="o">=</span> <span class="n">Gradients</span><span class="p">(</span><span class="n">mycc</span><span class="p">)</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>  <span class="c1"># The electronic part only</span>

</pre></div>
</div>
</div>
<div class="section" id="interfering-ccsd-diis">
<h3><span class="section-number">10.3.1.7. </span>Interfering CCSD-DIIS<a class="headerlink" href="#interfering-ccsd-diis" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="restart-ccsd">
<h3><span class="section-number">10.3.1.8. </span>Restart CCSD<a class="headerlink" href="#restart-ccsd" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="program-reference">
<h2><span class="section-number">10.3.2. </span>Program reference<a class="headerlink" href="#program-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="cc-ccsd-module-and-ccsd-class">
<h3><span class="section-number">10.3.2.1. </span>cc.ccsd module and CCSD class<a class="headerlink" href="#cc-ccsd-module-and-ccsd-class" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#pyscf.cc.ccsd.CCSD" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a> class is the object to hold the restricted CCSD environment
attributes and results.  The environment attributes are the parameters to
control the runtime behavior of the CCSD module, e.g. the convergence criteria, DIIS
parameters, and so on.  After the ground state CCSD calculation, correlation
energy, <code class="docutils literal notranslate"><span class="pre">T1</span></code> and <code class="docutils literal notranslate"><span class="pre">T2</span></code> amplitudes are stored in the CCSD object.
This class supports the calculation of CCSD 1- and 2-particle density matrices.</p>
<dl class="class">
<dt id="pyscf.cc.ccsd.CCSD">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">CCSD</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">frozen=None</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">mo_occ=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#CCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD" title="Permalink to this definition">¶</a></dt>
<dd><p>restricted CCSD</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-7.</p>
</dd>
<dt>conv_tol_normt<span class="classifier">float</span></dt><dd><p>converge threshold for norm(t1,t2).  Default is 1e-5.</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  Default is 50.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  Default is 6.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 0.</p>
</dd>
<dt>iterative_damping<span class="classifier">float</span></dt><dd><p>The self consistent damping parameter.</p>
</dd>
<dt>direct<span class="classifier">bool</span></dt><dd><p>AO-direct CCSD. Default is False.</p>
</dd>
<dt>async_io<span class="classifier">bool</span></dt><dd><p>Allow for asynchronous function execution. Default is True.</p>
</dd>
<dt>incore_complete<span class="classifier">bool</span></dt><dd><p>Avoid all I/O (also for DIIS). Default is False.</p>
</dd>
<dt>level_shift<span class="classifier">float</span></dt><dd><p>A shift on virtual orbital energies to stablize the CCSD iteration</p>
</dd>
<dt>frozen<span class="classifier">int or list</span></dt><dd><p>If integer is given, the inner-most orbitals are frozen from CC
amplitudes.  Given the orbital indices (0-based) in a list, both
occupied and virtual orbitals can be frozen in CC calculation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals and 3 high lying unoccupied orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>CCSD converged or not</p>
</dd>
<dt>e_corr<span class="classifier">float</span></dt><dd><p>CCSD correlation correction</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total CCSD energy (HF + correlation)</p>
</dd>
<dt>t1, t2 :</dt><dd><p>T amplitudes t1[i,a], t2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
<dt>l1, l2 :</dt><dd><p>Lambda amplitudes l1[i,a], l2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<span class="target" id="module-pyscf.cc.ccsd"></span><p>RCCSD for real integrals
8-fold permutation symmetry has been used
(ij|kl) = (ji|kl) = (kl|ij) = …</p>
<dl class="attribute">
<dt id="pyscf.cc.ccsd.CC">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">CC</code><a class="headerlink" href="#pyscf.cc.ccsd.CC" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.cc.ccsd.CCSD" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a></p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">CCSD</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">frozen=None</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">mo_occ=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#CCSD"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>restricted CCSD</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-7.</p>
</dd>
<dt>conv_tol_normt<span class="classifier">float</span></dt><dd><p>converge threshold for norm(t1,t2).  Default is 1e-5.</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  Default is 50.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  Default is 6.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 0.</p>
</dd>
<dt>iterative_damping<span class="classifier">float</span></dt><dd><p>The self consistent damping parameter.</p>
</dd>
<dt>direct<span class="classifier">bool</span></dt><dd><p>AO-direct CCSD. Default is False.</p>
</dd>
<dt>async_io<span class="classifier">bool</span></dt><dd><p>Allow for asynchronous function execution. Default is True.</p>
</dd>
<dt>incore_complete<span class="classifier">bool</span></dt><dd><p>Avoid all I/O (also for DIIS). Default is False.</p>
</dd>
<dt>level_shift<span class="classifier">float</span></dt><dd><p>A shift on virtual orbital energies to stablize the CCSD iteration</p>
</dd>
<dt>frozen<span class="classifier">int or list</span></dt><dd><p>If integer is given, the inner-most orbitals are frozen from CC
amplitudes.  Given the orbital indices (0-based) in a list, both
occupied and virtual orbitals can be frozen in CC calculation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals and 3 high lying unoccupied orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>CCSD converged or not</p>
</dd>
<dt>e_corr<span class="classifier">float</span></dt><dd><p>CCSD correlation correction</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total CCSD energy (HF + correlation)</p>
</dd>
<dt>t1, t2 :</dt><dd><p>T amplitudes t1[i,a], t2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
<dt>l1, l2 :</dt><dd><p>Lambda amplitudes l1[i,a], l2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
</dl>
</div></blockquote>
<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.EOMEA_Ta">
<code class="sig-name descname">EOMEA_Ta</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.EOMEA_Ta" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for EOM EACCSD(T)*(a) method by Matthews and Stanton.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.EOMIP_Ta">
<code class="sig-name descname">EOMIP_Ta</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.EOMIP_Ta" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for EOM IPCCSD(T)*(a) method by Matthews and Stanton.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.as_scanner">
<code class="sig-name descname">as_scanner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner/solver for CCSD PES.</p>
<p>The returned solver is a function. This function requires one argument
“mol” as input and returns total CCSD energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
CCSD and the underlying SCF objects (conv_tol, max_memory etc) are
automatically applied in the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, …) during calculation.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cc_scanner</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.5&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.energy">
<code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">eris=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>CCSD correlation energy</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.get_frozen_mask">
<code class="sig-name descname">get_frozen_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.get_frozen_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Get boolean mask for the restricted reference orbitals.</p>
<p>In the returned boolean (mask) array of frozen orbital indices, the
element is False if it corresonds to the frozen orbital.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">eris=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#CCSD.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel function is the main driver of a method.  Every method should
define the kernel function as the entry of the calculation.  Note the
return value of kernel function is not strictly defined.  It can be
anything related to the method (such as the energy, the wave-function,
the DFT mesh grids etc.).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">l1=None</em>, <em class="sig-param">l2=None</em>, <em class="sig-param">ao_repr=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#CCSD.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-relaxed 1-particle density matrix in MO space</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.make_rdm2">
<code class="sig-name descname">make_rdm2</code><span class="sig-paren">(</span><em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">l1=None</em>, <em class="sig-param">l2=None</em>, <em class="sig-param">ao_repr=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#CCSD.make_rdm2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.make_rdm2" title="Permalink to this definition">¶</a></dt>
<dd><p>2-particle density matrix in MO space.  The density matrix is
stored as</p>
<p>dm2[p,r,q,s] = &lt;p^+ q^+ s r&gt;</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.ccsd.CCSD.restore_from_diis_">
<code class="sig-name descname">restore_from_diis_</code><span class="sig-paren">(</span><em class="sig-param">diis_file</em>, <em class="sig-param">inplace=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.restore_from_diis_" title="Permalink to this definition">¶</a></dt>
<dd><p>Reuse an existed DIIS object in the CCSD calculation.</p>
<p>The CCSD amplitudes will be restored from the DIIS object to generate t1
and t2 amplitudes. The t1/t2 amplitudes of the CCSD object will be
overwritten by the generated t1 and t2 amplitudes. The amplitudes vector
and error vector will be reused in the CCSD calculation.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pyscf.cc.ccsd.RCCSD">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">RCCSD</code><a class="headerlink" href="#pyscf.cc.ccsd.RCCSD" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.cc.ccsd.CCSD" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.ccsd.as_scanner">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">as_scanner</code><span class="sig-paren">(</span><em class="sig-param">cc</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#as_scanner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner/solver for CCSD PES.</p>
<p>The returned solver is a function. This function requires one argument
“mol” as input and returns total CCSD energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
CCSD and the underlying SCF objects (conv_tol, max_memory etc) are
automatically applied in the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, …) during calculation.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cc_scanner</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.5&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.ccsd.energy">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param">mycc</em>, <em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">eris=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>CCSD correlation energy</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.ccsd.get_d1_diagnostic">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">get_d1_diagnostic</code><span class="sig-paren">(</span><em class="sig-param">t1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#get_d1_diagnostic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.get_d1_diagnostic" title="Permalink to this definition">¶</a></dt>
<dd><p>D1 diagnostic given in</p>
<p>Janssen, et. al Chem. Phys. Lett. 290 (1998) 423</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.ccsd.get_d2_diagnostic">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">get_d2_diagnostic</code><span class="sig-paren">(</span><em class="sig-param">t2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#get_d2_diagnostic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.get_d2_diagnostic" title="Permalink to this definition">¶</a></dt>
<dd><p>D2 diagnostic given in</p>
<blockquote>
<div><p>Nielsen, et. al Chem. Phys. Lett. 310 (1999) 568</p>
</div></blockquote>
<p>Note: This is currently only defined in the literature for restricted
closed-shell systems.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.ccsd.get_t1_diagnostic">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">get_t1_diagnostic</code><span class="sig-paren">(</span><em class="sig-param">t1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#get_t1_diagnostic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.get_t1_diagnostic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the t1 amplitude norm, normalized by number of correlated electrons.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.ccsd.restore_from_diis_">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">restore_from_diis_</code><span class="sig-paren">(</span><em class="sig-param">mycc</em>, <em class="sig-param">diis_file</em>, <em class="sig-param">inplace=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#restore_from_diis_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.restore_from_diis_" title="Permalink to this definition">¶</a></dt>
<dd><p>Reuse an existed DIIS object in the CCSD calculation.</p>
<p>The CCSD amplitudes will be restored from the DIIS object to generate t1
and t2 amplitudes. The t1/t2 amplitudes of the CCSD object will be
overwritten by the generated t1 and t2 amplitudes. The amplitudes vector
and error vector will be reused in the CCSD calculation.</p>
</dd></dl>

</div>
<div class="section" id="cc-rccsd-and-rccsd-class">
<h3><span class="section-number">10.3.2.2. </span>cc.rccsd and RCCSD class<a class="headerlink" href="#cc-rccsd-and-rccsd-class" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#pyscf.cc.rccsd.RCCSD" title="pyscf.cc.rccsd.RCCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.rccsd.RCCSD</span></code></a> is also a class for restricted CCSD calculations, but
different to the <a class="reference internal" href="#pyscf.cc.ccsd.CCSD" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a> class.  It uses different formula
to compute the ground state CCSD solution.  Although slower than the
implmentation in the <a class="reference internal" href="#pyscf.cc.ccsd.CCSD" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a> class, it supports the system
with complex integrals.  Another difference is that this class supports EOM-CCSD
methods, including EOM-IP-CCSD, EOM-EA-CCSD, EOM-EE-CCSD, EOM-SF-CCSD.</p>
<dl class="class">
<dt id="pyscf.cc.rccsd.RCCSD">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.cc.rccsd.</code><code class="sig-name descname">RCCSD</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">frozen=None</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">mo_occ=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/rccsd.html#RCCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD" title="Permalink to this definition">¶</a></dt>
<dd><p>restricted CCSD with IP-EOM, EA-EOM, EE-EOM, and SF-EOM capabilities</p>
<p>Ground-state CCSD is performed in optimized ccsd.CCSD and EOM is performed here.</p>
</dd></dl>

<span class="target" id="module-pyscf.cc.rccsd"></span><p>Restricted CCSD implementation which supports both real and complex integrals.
The 4-index integrals are saved on disk entirely (without using any symmetry).
This code is slower than the pyscf.cc.ccsd implementation.</p>
<p>Note MO integrals are treated in chemist’s notation</p>
<p>Ref: Hirata et al., J. Chem. Phys. 120, 2581 (2004)</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">pyscf.cc.rccsd.</code><code class="sig-name descname">RCCSD</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">frozen=None</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">mo_occ=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/rccsd.html#RCCSD"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>restricted CCSD with IP-EOM, EA-EOM, EE-EOM, and SF-EOM capabilities</p>
<p>Ground-state CCSD is performed in optimized ccsd.CCSD and EOM is performed here.</p>
<dl class="method">
<dt id="pyscf.cc.rccsd.RCCSD.ccsd">
<code class="sig-name descname">ccsd</code><span class="sig-paren">(</span><em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">eris=None</em>, <em class="sig-param">mbpt2=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/rccsd.html#RCCSD.ccsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD.ccsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Ground-state CCSD.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mbpt2<span class="classifier">bool</span></dt><dd><p>Use one-shot MBPT2 approximation to CCSD.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.rccsd.RCCSD.energy">
<code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">eris=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>RCCSD correlation energy</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.rccsd.RCCSD.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">eris=None</em>, <em class="sig-param">mbpt2=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/rccsd.html#RCCSD.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel function is the main driver of a method.  Every method should
define the kernel function as the entry of the calculation.  Note the
return value of kernel function is not strictly defined.  It can be
anything related to the method (such as the energy, the wave-function,
the DFT mesh grids etc.).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.cc.rccsd.energy">
<code class="sig-prename descclassname">pyscf.cc.rccsd.</code><code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param">cc</em>, <em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">eris=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/rccsd.html#energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>RCCSD correlation energy</p>
</dd></dl>

</div>
<div class="section" id="cc-uccsd-and-uccsd-class">
<h3><span class="section-number">10.3.2.3. </span>cc.uccsd and UCCSD class<a class="headerlink" href="#cc-uccsd-and-uccsd-class" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#pyscf.cc.uccsd.UCCSD" title="pyscf.cc.uccsd.UCCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.uccsd.UCCSD</span></code></a> class supports the CCSD calculation based on UHF
wavefunction as well as the ROHF wavefunction.  Besides the ground state UCCSD calculation,
UCCSD lambda equation, 1-particle and 2-particle density matrices, EOM-IP-CCSD,
EOM-EA-CCSD, EOM-EE-CCSD are all available in this class.  Note this class does
not support complex integrals.</p>
<dl class="class">
<dt id="pyscf.cc.uccsd.UCCSD">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.cc.uccsd.</code><code class="sig-name descname">UCCSD</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">frozen=None</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">mo_occ=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#UCCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="target" id="module-pyscf.cc.uccsd"></span><p>UCCSD with spatial integrals</p>
<dl class="attribute">
<dt id="pyscf.cc.uccsd.CCSD">
<code class="sig-prename descclassname">pyscf.cc.uccsd.</code><code class="sig-name descname">CCSD</code><a class="headerlink" href="#pyscf.cc.uccsd.CCSD" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.cc.uccsd.UCCSD" title="pyscf.cc.uccsd.UCCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.uccsd.UCCSD</span></code></a></p>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="sig-prename descclassname">pyscf.cc.uccsd.</code><code class="sig-name descname">UCCSD</code><span class="sig-paren">(</span><em class="sig-param">mf</em>, <em class="sig-param">frozen=None</em>, <em class="sig-param">mo_coeff=None</em>, <em class="sig-param">mo_occ=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#UCCSD"><span class="viewcode-link">[source]</span></a></dt>
<dd><dl class="method">
<dt id="pyscf.cc.uccsd.UCCSD.ccsd">
<code class="sig-name descname">ccsd</code><span class="sig-paren">(</span><em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">eris=None</em>, <em class="sig-param">mbpt2=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#UCCSD.ccsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD.ccsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Ground-state unrestricted (U)CCSD.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mbpt2<span class="classifier">bool</span></dt><dd><p>Use one-shot MBPT2 approximation to CCSD.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.uccsd.UCCSD.energy">
<code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">eris=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>UCCSD correlation energy</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.uccsd.UCCSD.get_frozen_mask">
<code class="sig-name descname">get_frozen_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD.get_frozen_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Get boolean mask for the unrestricted reference orbitals.</p>
<p>In the returned boolean (mask) array of frozen orbital indices, the
element is False if it corresonds to the frozen orbital.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.uccsd.UCCSD.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">eris=None</em>, <em class="sig-param">mbpt2=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#UCCSD.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel function is the main driver of a method.  Every method should
define the kernel function as the entry of the calculation.  Note the
return value of kernel function is not strictly defined.  It can be
anything related to the method (such as the energy, the wave-function,
the DFT mesh grids etc.).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.uccsd.UCCSD.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">l1=None</em>, <em class="sig-param">l2=None</em>, <em class="sig-param">ao_repr=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#UCCSD.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-relaxed 1-particle density matrix in MO space</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>dm1a, dm1b</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.cc.uccsd.UCCSD.make_rdm2">
<code class="sig-name descname">make_rdm2</code><span class="sig-paren">(</span><em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">l1=None</em>, <em class="sig-param">l2=None</em>, <em class="sig-param">ao_repr=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#UCCSD.make_rdm2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD.make_rdm2" title="Permalink to this definition">¶</a></dt>
<dd><p>2-particle density matrix in spin-oribital basis.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.cc.uccsd.energy">
<code class="sig-prename descclassname">pyscf.cc.uccsd.</code><code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param">cc</em>, <em class="sig-param">t1=None</em>, <em class="sig-param">t2=None</em>, <em class="sig-param">eris=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>UCCSD correlation energy</p>
</dd></dl>

</div>
<div class="section" id="cc-addons">
<h3><span class="section-number">10.3.2.4. </span>cc.addons<a class="headerlink" href="#cc-addons" title="Permalink to this headline">¶</a></h3>
<p>Helper functions for CCSD, RCCSD and UCCSD modules are implemented in
<code class="xref py py-mod docutils literal notranslate"><span class="pre">cc.addons</span></code></p>
<span class="target" id="module-pyscf.cc.addons"></span><dl class="function">
<dt id="pyscf.cc.addons.spatial2spin">
<code class="sig-prename descclassname">pyscf.cc.addons.</code><code class="sig-name descname">spatial2spin</code><span class="sig-paren">(</span><em class="sig-param">tx</em>, <em class="sig-param">orbspin=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/addons.html#spatial2spin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.addons.spatial2spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert T1/T2 of spatial orbital representation to T1/T2 of
spin-orbital representation</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.cc.addons.spatial2spinorb">
<code class="sig-prename descclassname">pyscf.cc.addons.</code><code class="sig-name descname">spatial2spinorb</code><span class="sig-paren">(</span><em class="sig-param">tx</em>, <em class="sig-param">orbspin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.addons.spatial2spinorb" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert T1/T2 of spatial orbital representation to T1/T2 of
spin-orbital representation</p>
</dd></dl>

</div>
<div class="section" id="ccsd-t">
<h3><span class="section-number">10.3.2.5. </span>CCSD(T)<a class="headerlink" href="#ccsd-t" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.cc.ccsd_t"></span><p>RHF-CCSD(T) for real integrals</p>
</div>
<div class="section" id="ccsd-gradients">
<h3><span class="section-number">10.3.2.6. </span>CCSD gradients<a class="headerlink" href="#ccsd-gradients" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ccn.html" class="btn btn-neutral float-right" title="10.4. ccn — Auto-generated coupled cluster of arbitrary order" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ao2mo.html" class="btn btn-neutral float-left" title="10.2. ao2mo — Integral transformations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2019, The PySCF Developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>