

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>11. df — Density fitting &mdash; PySCF 1.7.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PySCF 1.7.0 documentation" href="index.html"/>
        <link rel="next" title="12. dft — Density functional theory" href="dft.html"/>
        <link rel="prev" title="10. symm – Point group symmetry and spin symmetry" href="symm.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">2. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="gto.html">4. gto &#8212; Molecular structure and GTO basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="lib.html">5. <code class="docutils literal"><span class="pre">lib</span></code> &#8212; Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="scf.html">6. scf &#8212; Mean-field methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="ao2mo.html">7. ao2mo &#8212; Integral transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="mcscf.html">8. mcscf &#8212; Multi-configurational self-consistent field</a></li>
<li class="toctree-l1"><a class="reference internal" href="fci.html">9. fci &#8212; Full configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="symm.html">10. symm &#8211; Point group symmetry and spin symmetry</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">11. df &#8212; Density fitting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">11.1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#df-auxiliary-basis">11.1.1. DF auxiliary basis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#even-tempered-auxiliary-gaussian-basis">11.1.1.1. Even-tempered auxiliary Gaussian basis</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#saving-loading-df-integral-tensor">11.1.2. Saving/Loading DF integral tensor</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#precomputing-the-df-integral-tensor">11.1.2.1. Precomputing the DF integral tensor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#approximating-orbital-hessian-in-scf-and-mcscf">11.1.3. Approximating orbital hessian in SCF and MCSCF</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#program-reference">11.2. Program reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#df-class">11.2.1. DF class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyscf.df.incore">11.2.2. df.incore</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyscf.df.outcore">11.2.3. df.outcore</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyscf.df.addons">11.2.4. df.addons</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dft.html">12. dft &#8212; Density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="tddft.html">13. tddft &#8212; Time dependent density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="cc.html">14. cc &#8212; Coupled cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">15. ci &#8212; Configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dmrgscf.html">16. dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="fciqmcscf.html">17. fciqmcscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">18. tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="grad.html">19. grad &#8212; Analytical nuclear gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="hessian.html">20. hessian &#8212; Analytical nuclear Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="pbc.html">21. pbc &#8212; Periodic boundary conditions</a></li>
<li class="toctree-l1"><a class="reference internal" href="nao.html">22. nao &#8212; Numerical Atomic Orbitals</a></li>
<li class="toctree-l1"><a class="reference internal" href="lo.html">23. lo &#8212; Orbital localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">24. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="qmmm.html">25. qmmm &#8212; QM/MM interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrpt.html">26. mrpt &#8212; Multi-reference perturbation theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmark.html">27. Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="code-rule.html">28. Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">29. Version history</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PySCF</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>11. df &#8212; Density fitting</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/df.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-df">
<span id="df-density-fitting"></span><span id="mol-df"></span><h1>11. df &#8212; Density fitting<a class="headerlink" href="#module-df" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>11.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-df" title="df: Density fitting and RI approximation"><code class="xref py py-mod docutils literal"><span class="pre">df</span></code></a> module provides the fundamental functions to handle the 3-index
tensors required by the density fitting (DF) method or the resolution of
identity (RI) approximation.  Specifically, it includes the functions to compute
the 3-center 2-electron AO integrals, the DF/RI 3-index tensor in the form of
Cholesky decomposed integral tensor (<span class="math">\((ij|kl)=V_{ij,x}V_{kl,x}\)</span>),
the AO to MO integral transformation of the 3-index tensor, as well as the
functions to generate the density fitting basis.</p>
<p>The <code class="xref py py-func docutils literal"><span class="pre">density_fit()</span></code> method can utilize the DF method at SCF and MCSCF
level:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.2&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;def2-tzvp&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>Once the DF method is enabled at the SCF level, all the post-SCF methods will
automatically enable the DF method, for example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">dft</span><span class="p">,</span> <span class="n">tddft</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.2&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;def2-tzvp&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">td</span> <span class="o">=</span> <span class="n">tddft</span><span class="o">.</span><span class="n">TDA</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">td</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>In PySCF, DF is implemented at different level of implementations for different
methods.  They are summarized in the following table</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="13%" />
<col width="17%" />
<col width="32%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Methods</td>
<td>Fake-ERI</td>
<td>Native DF</td>
<td>Properties with DF</td>
</tr>
<tr class="row-even"><td>HF/DFT</td>
<td>Yes</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Generlized HF/DFT</td>
<td>Yes</td>
<td>No</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Relativistic HF</td>
<td>Yes</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>TDDFT</td>
<td>Yes</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>RCCSD</td>
<td>Yes</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>UCCSD</td>
<td>Yes</td>
<td>No</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>RCCSD(T)</td>
<td>Yes</td>
<td>No</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>EOM-CCSD</td>
<td>Yes</td>
<td>No</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>RMP2</td>
<td>Yes</td>
<td>No</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>UMP2</td>
<td>Yes</td>
<td>No</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>PBC HF/DFT</td>
<td>Yes</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>PBC TDDFT</td>
<td>Yes</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>PBC Gamma-point CCSD</td>
<td>Yes</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>PBC k-points CCSD</td>
<td>Yes</td>
<td>No</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>Fake-ERI means to mimic the 4-center 2-electron repulsion integrals (ERI) by
precontracting the DF 3-index tensor.
This is the simplest way to enable DF integrals, although the fake-ERI mechanism
may require huge amount of memory also may be slow in performance.  It provides
the most convenient way to embed the DF integrals in the existing code, thus it
is supported by almost every method in PySCF.  It is particularly important in
the periodic code.  Using the fake-ERIs allows us to call all quantum chemistry
methods developed at molecular level in the <span class="math">\(\Gamma\)</span>-point calculations
without modifying any existing molecular code.  See also the <a class="reference internal" href="pbc/df.html#pbc-df"><span class="std std-ref">pbc.df &#8212; PBC denisty fitting</span></a>
module.</p>
<p>Some methods have native DF implementation.  This means the performance of the
DF technique has been considered in the code.  In these methods, DF
approximation generally runs faster than the regular scheme without integral
approximation and also consumes less memory or disk space.</p>
<p>When density fitting is enabled in a method, a <code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code> object will be
generated and attached to the method object.  <code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code> is the object to
hold all DF relevant quantiles, such as the DF basis, the file to save the
3-index tensor, the amount of memory to use etc.  You can modify the attributes
of <code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code> to get more control over the DF methods.  In the SCF and
MCSCF methods, setting <code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code> to <code class="docutils literal"><span class="pre">None</span></code> will switch off the DF
approximation.  In the periodic code, all two-electron integrals are evaluated
by DF approximations.  There are four different types of DF schemes
(<code class="xref py py-class docutils literal"><span class="pre">FFTDF</span></code>, <code class="xref py py-class docutils literal"><span class="pre">AFTDF</span></code>, <code class="xref py py-class docutils literal"><span class="pre">GDF</span></code>, <code class="xref py py-class docutils literal"><span class="pre">MDF</span></code> see <a class="reference internal" href="pbc/df.html#pbc-df"><span class="std std-ref">pbc.df &#8212; PBC denisty fitting</span></a>),
available in the periodic code.  By assigning different DF object to
<code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code>, different DF schemes can be applied in the PBC calculations.</p>
<div class="section" id="df-auxiliary-basis">
<span id="df-auxbasis"></span><h3>11.1.1. DF auxiliary basis<a class="headerlink" href="#df-auxiliary-basis" title="Permalink to this headline">¶</a></h3>
<p>The default auxiliary basis set are generated by function
<code class="xref py py-func docutils literal"><span class="pre">pyscf.df.addons.make_basis()</span></code> based on the orbital basis specified in
the calculation according to the rules defined in
<code class="xref py py-data docutils literal"><span class="pre">pyscf.df.addons.DEFAULT_AUXBASIS</span></code>.
Specifically, the <cite>jkfit</cite> basis in the first column is used for Hartree-Fock or
DFT methods, and the <cite>ri</cite> basis in the second column is used for correlation
calculations. These optimized auxiliary basis sets are obtained from
<a class="reference external" href="http://www.psicode.org/psi4manual/master/basissets_byfamily.html">http://www.psicode.org/psi4manual/master/basissets_byfamily.html</a>
If optimized auxiliary basis set was not found for the orbital basis set,
even-tempered Gaussian functions are generated automatically.</p>
<p>Specifying auxiliary basis is a common requirement in the real applications.
For example, the default auxiliary basis set for the pure DFT calculations may
be over complete since it is designed to represent both the Coulomb and HF
exchange matrix.  Coulomb fitting basis such as Weigend-cfit basis or
Ahlrichs-cfit basis are often enough to obtain chemical accuracy.  To control
the fitting basis in DF method, You can change the value of
<code class="xref py py-attr docutils literal"><span class="pre">with_df.auxbasis</span></code> attribute.  The input format of auxiliary fitting basis
is exactly the same to the input format of orbital <a class="reference internal" href="gto.html#gto-basis"><span class="std std-ref">basis</span></a> set.  For
example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">dft</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.2&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;def2-tzvp&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="s1">&#39;pbe,pbe&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># -109.432313679876</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># -109.432329411505</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">auxbasis</span> <span class="o">=</span> <span class="s1">&#39;weigend&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># -109.432334646584</span>
</pre></div>
</div>
<p>More examples for inputing auxiliary basis in the DF calculation can be found
in <code class="docutils literal"><span class="pre">examples/df/01-auxbasis.py</span></code>.</p>
<div class="section" id="even-tempered-auxiliary-gaussian-basis">
<span id="df-etb-auxbasis"></span><h4>11.1.1.1. Even-tempered auxiliary Gaussian basis<a class="headerlink" href="#even-tempered-auxiliary-gaussian-basis" title="Permalink to this headline">¶</a></h4>
<p>The even-tempered auxiliary Gaussian basis is generated by function <code class="xref py py-func docutils literal"><span class="pre">aug_etb()</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1.2&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>                            <span class="c1"># 28</span>
<span class="n">auxbasis</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">aug_etb</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">make_auxmol</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">auxbasis</span><span class="p">)</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>  <span class="c1"># 200</span>
<span class="n">auxbasis</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">aug_etb</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.6</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">make_auxmol</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">auxbasis</span><span class="p">)</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>  <span class="c1"># 338</span>
</pre></div>
</div>
<p>Here the <code class="xref py py-func docutils literal"><span class="pre">make_auxmol()</span></code> function converts the auxbasis to a <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code>
object which can be used to evaluate the analytical integrals the same way as
the regular <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> object.  The formula to generate the exponents
<span class="math">\(\zeta\)</span> of the even-tempered auxiliary basis are</p>
<div class="math">
\[\begin{split}\varphi &amp;= r^l \exp(-\zeta_{il} r^2), \quad i = 0..n \\
\zeta_{il} &amp;= \alpha \times \beta^i
:label: etb\end{split}\]</div>
<p>The default value of <span class="math">\(\beta\)</span> is 2.3.  <span class="math">\(\alpha\)</span> and the number of
auxiliary basis <span class="math">\(n\)</span> is determined based on the orbital basis.  Given the
orbital basis</p>
<div class="math">
\[\chi = r^l \exp(-\alpha_l r^2)\]</div>
<p>the orbital pair on the same center produces a new one-center basis</p>
<div class="math">
\[\chi \chi' = r^{l+l'} \exp(-(\alpha_l+\alpha_l') r^2)
= r^L \exp(-\alpha_L r^2)\]</div>
<p>The minimal <span class="math">\(\alpha_L\)</span> in all orbital pairs is assigned to <span class="math">\(\alpha\)</span>
in <a href="#equation-etb">(?)</a>.
Then <span class="math">\(n\)</span> is estimated to make the largest auxiliary exponent <span class="math">\(\zeta\)</span>
as close as possible to the maximum <span class="math">\(\alpha_L\)</span>.
The size of generated even-tempered Gaussian basis is typically 5 - 10 times of
the size of the orbital basis, or 2 - 3 times more than the optimized auxiliary
basis.  (Note the accuracy of this even-tempered auxiliary basis is not fully
benchmarked. The error is close to the optimized auxiliary basis in our tests.)</p>
</div>
</div>
<div class="section" id="saving-loading-df-integral-tensor">
<span id="sl-cderi"></span><h3>11.1.2. Saving/Loading DF integral tensor<a class="headerlink" href="#saving-loading-df-integral-tensor" title="Permalink to this headline">¶</a></h3>
<p>Although it is not expensive to compute DF integral tensor in the molecular
calculation, saving/loading the 3-index tensor is still useful since it provides
an alternative way, different to the attribute <code class="xref py py-attr docutils literal"><span class="pre">_eri</span></code> of mean-field object
(see <a class="reference internal" href="scf.html#customize-h"><span class="std std-ref">Customizing Hamiltonian</span></a>), to customize the Hamiltonian.</p>
<p>In the DF-SCF method, the 3-index tensor is held in the <code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code> object.
The <code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code> object (see <a class="reference internal" href="#pyscf.df.df.DF" title="pyscf.df.df.DF"><code class="xref py py-class docutils literal"><span class="pre">pyscf.df.df.DF</span></code></a> class) provides
two attributes <code class="xref py py-attr docutils literal"><span class="pre">_cderi_to_save</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">_cderi</span></code> to access the DF 3-index
integrals.</p>
<p>If a DF integral tensor is assigned to <code class="xref py py-attr docutils literal"><span class="pre">_cderi</span></code>, the integrals will be
used in the DF calculation.  The DF integral tensor can be either a numpy array
or an HDF5 file on disk.  When the DF integrals are provided in the HDF5 file,
the integral needs to be stored under the dataset <code class="docutils literal"><span class="pre">'j3c'</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">df</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 1 0 1; H 0 1 1; H 1 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto3g&#39;</span><span class="p">)</span>
<span class="n">nao</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()</span>
<span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s1">&#39;df_ints.h5&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="p">[</span><span class="s1">&#39;j3c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="n">nao</span><span class="o">*</span><span class="p">(</span><span class="n">nao</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">_cderi</span> <span class="o">=</span> <span class="s1">&#39;df_ints.h5&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>As shown in the above example, the integral tensor <span class="math">\(V_{x,ij}\)</span> provided in
<code class="xref py py-attr docutils literal"><span class="pre">_cderi</span></code> should be a 2D array in C (row-major) convention. Its first index
corresponds to the auxiliary basis and the second combined index <code class="docutils literal"><span class="pre">ij</span></code> is the
orbital pair index.  When load DF integrals, we assumed hermitian symmetry
between the two orbital index, ie only the elements <span class="math">\(i\geq j\)</span> are left in
the DF integral tensor.  Thus the DF integral tensor should be a 2D array, with
shape <code class="docutils literal"><span class="pre">(M,N*(N+1)/2)</span></code>, where <code class="docutils literal"><span class="pre">M</span></code> is the number of auxiliary functions, N is
the number of orbitals.</p>
<p>If <code class="xref py py-attr docutils literal"><span class="pre">_cderi</span></code> is not specified, the DF integral tensor will be generated
during the calculation and stored to the file that the attribute
<code class="xref py py-attr docutils literal"><span class="pre">_cderi_to_save</span></code> points to.  By default, it is a random file and the
random file will be deleted if the calculation finishes successfully.  You
can find the filename in the output log (when <code class="docutils literal"><span class="pre">with.verbose</span> <span class="pre">&gt;</span> <span class="pre">3</span></code>, for example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>******** &lt;class &#39;pyscf.df.df.DF&#39;&gt; flags ********
auxbasis = None
max_memory = 20000
_cderi_to_save = /scratch/tmp6rGrSD
</pre></div>
</div>
<p>If the calculation is terminated problematically with error or any other
reasons, you can reuse the DF integrals in the next calculation by assigning
the integral file to <code class="xref py py-attr docutils literal"><span class="pre">_cderi</span></code>.
Overwriting <code class="xref py py-attr docutils literal"><span class="pre">_cderi_to_save</span></code> with a filename will make the program save the
DF integrals in the given filename regardless whether the calculation is succeed
or failed.  See also the example
<code class="docutils literal"><span class="pre">pyscf/examples/df/10-access_df_integrals.py</span></code>.</p>
<div class="section" id="precomputing-the-df-integral-tensor">
<h4>11.1.2.1. Precomputing the DF integral tensor<a class="headerlink" href="#precomputing-the-df-integral-tensor" title="Permalink to this headline">¶</a></h4>
<p>The DF integral tensor can be computed without initialization the
<code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code> object.  Functions <code class="xref py py-func docutils literal"><span class="pre">cholesky_eri()</span></code> defined in
<code class="xref py py-mod docutils literal"><span class="pre">df.incore</span></code> and <code class="xref py py-mod docutils literal"><span class="pre">df.outcore</span></code> can generate DF integral tensor in memory
or in a HDF5 file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">cderi</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">incore</span><span class="o">.</span><span class="n">cholesky_eri</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">auxbasis</span><span class="o">=</span><span class="s1">&#39;ccpvdz-jkfit&#39;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">outcore</span><span class="o">.</span><span class="n">cholesky_eri</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="s1">&#39;df_ints.h5&#39;</span><span class="p">,</span> <span class="n">auxbasis</span><span class="o">=</span><span class="s1">&#39;ccpvdz-jkfit&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>These <code class="docutils literal"><span class="pre">cderi</span></code> integrals has the same data structure as the one generated in
<code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code> object.  They can be directly used in the DF type calculations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">scf</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">_cderi</span> <span class="o">=</span> <span class="n">cderi</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">_cderi</span> <span class="o">=</span> <span class="s1">&#39;df_ints.h5&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="approximating-orbital-hessian-in-scf-and-mcscf">
<h3>11.1.3. Approximating orbital hessian in SCF and MCSCF<a class="headerlink" href="#approximating-orbital-hessian-in-scf-and-mcscf" title="Permalink to this headline">¶</a></h3>
<p>Orbital hessian is required by the second order SCF solver or MCSCF solver.
In many systems, approximating the orbital hessian has negligible effects to the
convergence and the solutions of the SCF or MCSCF orbital optimization procedure.
Using DF method to approximate the orbital hessian can improve the overall
performance.  For example, the following code enables the DF approximation to
the orbital hessian in SCF calculation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; O 0 0 1.5&#39;</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">newton</span><span class="p">()</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># converged SCF energy = -129.0896469563</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>                         <span class="c1"># converged SCF energy = -129.0896469563</span>
</pre></div>
</div>
<p>The approximation to orbital hessian does not change the SCF result.  In the
above example, it produces the same solution to the regular SCF result.
Similarly, when the DF approximation is used with CASSCF orbital hessian, the
CASSCF result should not change.  Continuing the above example, we can use the
<code class="xref py py-func docutils literal"><span class="pre">mcscf.approx_hessian()</span></code> function to change the orbital hessian of the given
CASSCF object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">mcscf</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">approx_hessian</span><span class="p">(</span><span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># -129.283077136</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>                        <span class="c1"># -129.283077136</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the second order SCF solver, the order to apply the density_fit
and newton methods affects the character of the resultant SCF object.  For
example, the statement <code class="docutils literal"><span class="pre">mf</span> <span class="pre">=</span> <span class="pre">scf.RHF(mol).density_fit().newton()</span></code> first
produces a DFHF object then enable the second order Newton solver for the DFHF
object.  The resultant SCF object is a DFHF object.  See more examples in
<code class="docutils literal"><span class="pre">examples/scf/23-decorate_scf.py</span></code></p>
</div>
</div>
</div>
<div class="section" id="program-reference">
<h2>11.2. Program reference<a class="headerlink" href="#program-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="df-class">
<h3>11.2.1. DF class<a class="headerlink" href="#df-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyscf.df.df.DF">
<em class="property">class </em><code class="descclassname">pyscf.df.df.</code><code class="descname">DF</code><span class="sig-paren">(</span><em>mol</em>, <em>auxbasis=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/df.html#DF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.df.DF" title="Permalink to this definition">¶</a></dt>
<dd><p>Object to hold 3-index tensor</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>auxbasis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or dict</span><dd>Same input format as <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code></dd>
<dt>auxmol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">Mole object</span><dd>Read only Mole object to hold the auxiliary basis.  auxmol is
generated automatically in the initialization step based on the
given auxbasis.  It is used in the rest part of the code to
determine the problem size, the integral batches etc.  This object
should NOT be modified.</dd>
<dt>_cderi_to_save</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>If _cderi_to_save is specified, the DF integral tensor will be
saved in this file.</dd>
<dt>_cderi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or numpy array</span><dd>If _cderi is specified, the DF integral tensor will be read from
this HDF5 file (or numpy array). When the DF integral tensor is
provided from the HDF5 file, it has to be stored under the dataset
&#8216;j3c&#8217;.
The DF integral tensor <span class="math">\(V_{x,ij}\)</span> should be a 2D array in C
(row-major) convention, where x corresponds to index of auxiliary
basis, and the combined index ij is the orbital pair index. The
hermitian symmetry is assumed for the combined ij index, ie
the elements of <span class="math">\(V_{x,i,j}\)</span> with <span class="math">\(i\geq j\)</span> are existed
in the DF integral tensor.  Thus the shape of DF integral tensor
is (M,N*(N+1)/2), where M is the number of auxbasis functions and
N is the number of basis functions of the orbital basis.</dd>
<dt>blockdim</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>When reading DF integrals from disk the chunk size to load.  It is
used to improve IO performance.</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="pyscf.df.df.DF.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><em>mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/df.html#DF.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.df.DF.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset mol and clean up relevant attributes for scanner mode</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyscf.df.incore">
<span id="df-incore"></span><h3>11.2.2. df.incore<a class="headerlink" href="#module-pyscf.df.incore" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pyscf.df.incore.aux_e1">
<code class="descclassname">pyscf.df.incore.</code><code class="descname">aux_e1</code><span class="sig-paren">(</span><em>mol</em>, <em>auxmol</em>, <em>intor='int3c2e'</em>, <em>aosym='s1'</em>, <em>comp=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/incore.html#aux_e1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.incore.aux_e1" title="Permalink to this definition">¶</a></dt>
<dd><p>3-center 2-electron AO integrals (L|ij), where L is the auxiliary basis.</p>
<p>Note aux_e1 is basically analogous to aux_e2 function. It can be viewed as
the version of transposed aux_e2 tensor:
if comp == 1:</p>
<blockquote>
<div>aux_e1 = aux_e2().T</div></blockquote>
<dl class="docutils">
<dt>else:</dt>
<dd>aux_e1 = aux_e2().transpose(0,2,1)</dd>
</dl>
<p>The same arguments as function aux_e2 can be input to aux_e1.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.incore.aux_e2">
<code class="descclassname">pyscf.df.incore.</code><code class="descname">aux_e2</code><span class="sig-paren">(</span><em>mol</em>, <em>auxmol</em>, <em>intor='int3c2e'</em>, <em>aosym='s1'</em>, <em>comp=None</em>, <em>out=None</em>, <em>cintopt=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/incore.html#aux_e2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.incore.aux_e2" title="Permalink to this definition">¶</a></dt>
<dd><p>3-center AO integrals (ij|L), where L is the auxiliary basis.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>cintopt</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">Libcint-3.14 and newer version support to compute int3c2e</span><dd><p class="first">without the opt for the 3rd index.  It can be precomputed to
reduce the overhead of cintopt initialization repeatedly.</p>
<p class="last">cintopt = gto.moleintor.make_cintopt(mol._atm, mol._bas, mol._env, &#8216;int3c2e&#8217;)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.incore.cholesky_eri">
<code class="descclassname">pyscf.df.incore.</code><code class="descname">cholesky_eri</code><span class="sig-paren">(</span><em>mol</em>, <em>auxbasis='weigend+etb'</em>, <em>auxmol=None</em>, <em>int3c='int3c2e'</em>, <em>aosym='s2ij'</em>, <em>int2c='int2c2e'</em>, <em>comp=1</em>, <em>max_memory=2000</em>, <em>verbose=0</em>, <em>fauxe2=&lt;function aux_e2&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/incore.html#cholesky_eri"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.incore.cholesky_eri" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns:</dt>
<dd>2D array of (naux,nao*(nao+1)/2) in C-contiguous</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.incore.cholesky_eri_debug">
<code class="descclassname">pyscf.df.incore.</code><code class="descname">cholesky_eri_debug</code><span class="sig-paren">(</span><em>mol</em>, <em>auxbasis='weigend+etb'</em>, <em>auxmol=None</em>, <em>int3c='int3c2e'</em>, <em>aosym='s2ij'</em>, <em>int2c='int2c2e'</em>, <em>comp=1</em>, <em>verbose=0</em>, <em>fauxe2=&lt;function aux_e2&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/incore.html#cholesky_eri_debug"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.incore.cholesky_eri_debug" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns:</dt>
<dd>2D array of (naux,nao*(nao+1)/2) in C-contiguous</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.incore.fill_2c2e">
<code class="descclassname">pyscf.df.incore.</code><code class="descname">fill_2c2e</code><span class="sig-paren">(</span><em>mol</em>, <em>auxmol</em>, <em>intor='int2c2e'</em>, <em>comp=None</em>, <em>hermi=1</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/incore.html#fill_2c2e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.incore.fill_2c2e" title="Permalink to this definition">¶</a></dt>
<dd><p>2-center 2-electron AO integrals for auxiliary basis (auxmol)</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.df.outcore">
<span id="df-outcore"></span><h3>11.2.3. df.outcore<a class="headerlink" href="#module-pyscf.df.outcore" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pyscf.df.outcore.cholesky_eri">
<code class="descclassname">pyscf.df.outcore.</code><code class="descname">cholesky_eri</code><span class="sig-paren">(</span><em>mol</em>, <em>erifile</em>, <em>auxbasis='weigend+etb'</em>, <em>dataname='j3c'</em>, <em>tmpdir=None</em>, <em>int3c='int3c2e'</em>, <em>aosym='s2ij'</em>, <em>int2c='int2c2e'</em>, <em>comp=1</em>, <em>max_memory=2000</em>, <em>auxmol=None</em>, <em>verbose=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/outcore.html#cholesky_eri"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.outcore.cholesky_eri" title="Permalink to this definition">¶</a></dt>
<dd><p>3-index density-fitting tensor.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.outcore.cholesky_eri_b">
<code class="descclassname">pyscf.df.outcore.</code><code class="descname">cholesky_eri_b</code><span class="sig-paren">(</span><em>mol</em>, <em>erifile</em>, <em>auxbasis='weigend+etb'</em>, <em>dataname='j3c'</em>, <em>int3c='int3c2e'</em>, <em>aosym='s2ij'</em>, <em>int2c='int2c2e'</em>, <em>comp=1</em>, <em>max_memory=2000</em>, <em>auxmol=None</em>, <em>verbose=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/outcore.html#cholesky_eri_b"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.outcore.cholesky_eri_b" title="Permalink to this definition">¶</a></dt>
<dd><p>3-center 2-electron DF tensor.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.outcore.general">
<code class="descclassname">pyscf.df.outcore.</code><code class="descname">general</code><span class="sig-paren">(</span><em>mol</em>, <em>mo_coeffs</em>, <em>erifile</em>, <em>auxbasis='weigend+etb'</em>, <em>dataname='eri_mo'</em>, <em>tmpdir=None</em>, <em>int3c='int3c2e'</em>, <em>aosym='s2ij'</em>, <em>int2c='int2c2e'</em>, <em>comp=1</em>, <em>max_memory=2000</em>, <em>verbose=0</em>, <em>compact=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/outcore.html#general"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.outcore.general" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform ij of (ij|L) to MOs.</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.df.addons">
<span id="df-addons"></span><h3>11.2.4. df.addons<a class="headerlink" href="#module-pyscf.df.addons" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pyscf.df.addons.aug_etb">
<code class="descclassname">pyscf.df.addons.</code><code class="descname">aug_etb</code><span class="sig-paren">(</span><em>mol</em>, <em>beta=2.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/addons.html#aug_etb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.addons.aug_etb" title="Permalink to this definition">¶</a></dt>
<dd><p>To generate the even-tempered auxiliary Gaussian basis</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.addons.aug_etb_for_dfbasis">
<code class="descclassname">pyscf.df.addons.</code><code class="descname">aug_etb_for_dfbasis</code><span class="sig-paren">(</span><em>mol</em>, <em>dfbasis='weigend'</em>, <em>beta=2.0</em>, <em>start_at=36</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/addons.html#aug_etb_for_dfbasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.addons.aug_etb_for_dfbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>augment weigend basis with even-tempered gaussian basis
exps = alpha*beta^i for i = 1..N</p>
</dd></dl>

<dl class="class">
<dt id="pyscf.df.addons.load">
<em class="property">class </em><code class="descclassname">pyscf.df.addons.</code><code class="descname">load</code><span class="sig-paren">(</span><em>eri</em>, <em>dataname='j3c'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/addons.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.addons.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load 3c2e integrals from hdf5 file. It can be used in the context
manager:</p>
<dl class="docutils">
<dt>with load(cderifile) as eri:</dt>
<dd>print(eri.shape)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.addons.make_auxbasis">
<code class="descclassname">pyscf.df.addons.</code><code class="descname">make_auxbasis</code><span class="sig-paren">(</span><em>mol</em>, <em>mp2fit=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/addons.html#make_auxbasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.addons.make_auxbasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Depending on the orbital basis, generating even-tempered Gaussians or
the optimized auxiliary basis defined in DEFAULT_AUXBASIS</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.df.addons.make_auxmol">
<code class="descclassname">pyscf.df.addons.</code><code class="descname">make_auxmol</code><span class="sig-paren">(</span><em>mol</em>, <em>auxbasis=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/df/addons.html#make_auxmol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.df.addons.make_auxmol" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a fake Mole object which uses the density fitting auxbasis as
the basis sets.  If auxbasis is not specified, the optimized auxiliary fitting
basis set will be generated according to the rules recorded in
pyscf.df.addons.DEFAULT_AUXBASIS.  If the optimized auxiliary basis is not
available (either not specified in DEFAULT_AUXBASIS or the basis set of the
required elements not defined in the optimized auxiliary basis),
even-tempered Gaussian basis set will be generated.</p>
<p>See also the paper JCTC, 13, 554 about generating auxiliary fitting basis.</p>
</dd></dl>

</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dft.html" class="btn btn-neutral float-right" title="12. dft — Density functional theory" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="symm.html" class="btn btn-neutral" title="10. symm – Point group symmetry and spin symmetry" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.7.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>