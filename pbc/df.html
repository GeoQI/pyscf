

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>21.5. pbc.df — PBC denisty fitting &mdash; PySCF 1.7.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PySCF 1.7.0 documentation" href="../index.html"/>
        <link rel="up" title="21. pbc — Periodic boundary conditions" href="../pbc.html"/>
        <link rel="next" title="21.6. pbc.tdscf — PBC time dependent density functional theory" href="tdscf.html"/>
        <link rel="prev" title="21.4. pbc.dft — PBC density functional theory" href="dft.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">2. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gto.html">4. gto &#8212; Molecular structure and GTO basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lib.html">5. <code class="docutils literal"><span class="pre">lib</span></code> &#8212; Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scf.html">6. scf &#8212; Mean-field methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ao2mo.html">7. ao2mo &#8212; Integral transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mcscf.html">8. mcscf &#8212; Multi-configurational self-consistent field</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fci.html">9. fci &#8212; Full configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symm.html">10. symm &#8211; Point group symmetry and spin symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../df.html">11. df &#8212; Density fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dft.html">12. dft &#8212; Density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tddft.html">13. tddft &#8212; Time dependent density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cc.html">14. cc &#8212; Coupled cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ci.html">15. ci &#8212; Configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dmrgscf.html">16. dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fciqmcscf.html">17. fciqmcscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools.html">18. tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../grad.html">19. grad &#8212; Analytical nuclear gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hessian.html">20. hessian &#8212; Analytical nuclear Hessian</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../pbc.html">21. pbc &#8212; Periodic boundary conditions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="gto.html">21.1. pbc.gto &#8212; Crystal cell structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ao2mo.html">21.2. pbc.ao2mo &#8212; PBC integral transformation</a></li>
<li class="toctree-l2"><a class="reference internal" href="scf.html">21.3. pbc.scf &#8212; Mean-field with periodic boundary condition</a></li>
<li class="toctree-l2"><a class="reference internal" href="dft.html">21.4. pbc.dft  &#8212; PBC density functional theory</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">21.5. pbc.df &#8212; PBC denisty fitting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">21.5.1. Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#fftdf-fft-based-density-fitting">21.5.1.1. FFTDF &#8212; FFT-based density fitting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aftdf-aft-based-density-fitting">21.5.1.2. AFTDF &#8212; AFT-based density fitting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gdf-gaussian-density-fitting">21.5.1.3. GDF &#8212; Gaussian density fitting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mdf-mixed-density-fitting">21.5.1.4. MDF &#8212; mixed density fitting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#all-electron-calculation">21.5.1.5. All-electron calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#low-dimension-system">21.5.1.6. Low-dimension system</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interface-to-molecular-df-post-hf-methods">21.5.2. Interface to molecular DF-post-HF methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples">21.5.3. Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#program-reference">21.5.4. Program reference</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#fftdf-class">21.5.4.1. FFTDF class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.pbc.df.fft_jk">21.5.4.2. FFTDF helper functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aftdf-class">21.5.4.3. AFTDF class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.pbc.df.aft_jk">21.5.4.4. AFTDF helper functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gdf-class">21.5.4.5. GDF class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.pbc.df.df_jk">21.5.4.6. GDF helper functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mdf-class">21.5.4.7. MDF class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-pyscf.pbc.df.mdf_jk">21.5.4.8. MDF helper functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tdscf.html">21.6. pbc.tdscf &#8212; PBC time dependent density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="mp.html">21.7. pbc.mp &#8212; PBC perturbation theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="ci.html">21.8. pbc.ci &#8212; PBC configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="cc.html">21.9. pbc.cc &#8212; PBC coupled cluster</a></li>
<li class="toctree-l2"><a class="reference internal" href="mpicc.html">21.10. pbc.mpicc &#8212; PBC coupled cluster for MPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">21.11. pbc.tools &#8212; PBC tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="mix_mol.html">21.12. Mixing PBC and molecular modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="prop.html">21.13. pbc.prop &#8212; PBC property</a></li>
<li class="toctree-l2"><a class="reference internal" href="gw.html">21.14. pbc.gw &#8212; GW with PBC</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../nao.html">22. nao &#8212; Numerical Atomic Orbitals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lo.html">23. lo &#8212; Orbital localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced.html">24. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../qmmm.html">25. qmmm &#8212; QM/MM interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mrpt.html">26. mrpt &#8212; Multi-reference perturbation theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmark.html">27. Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code-rule.html">28. Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../version.html">29. Version history</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gw.html">30. gw &#8212; Molecular G0W0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hci.html">31. hci &#8212; Interface to Heat-Bath selective CI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sgx.html">32. sgx &#8212; Pseudo-spectral methods (COSX, PS, SN-K)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../semiempirical.html">33. semiempirical &#8212; Semiempirical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mp.html">34. mp &#8212; MP2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../semiempirical.html">33. semiempirical &#8212; Semiempirical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../soscf.html">35. soscf &#8212; Second order Hartree-Fock solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../icmpspt.html">36. icmpspt &#8212; Internal-contracted MPS perturbation method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ccn.html">37. ccn &#8212; Auto-Generated Coupled-Cluster Equations of Arbitrary Order</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cornell_shci.html">38. cornell_shci &#8212; Interface to Fast Semistochastic Heat Bath Configuration Interaction (SHCI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dftd3.html">39. dftd3 &#8212; DFT plus Dispersion Correction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dmrgscf.html">16. dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doci.html">40. doci &#8212; Doubly occupied configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../geomopt.html">41. geomopt &#8212; Geometry optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../solvent.html">42. solvent &#8212; Solvent methods</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PySCF</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../pbc.html">21. pbc &#8212; Periodic boundary conditions</a> &raquo;</li>
        
      <li>21.5. pbc.df &#8212; PBC denisty fitting</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/pbc/df.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pbc.df">
<span id="pbc-df-pbc-denisty-fitting"></span><span id="pbc-df"></span><h1>21.5. pbc.df &#8212; PBC denisty fitting<a class="headerlink" href="#module-pbc.df" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>21.5.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-pbc.df" title="pbc.df: Density fitting and RI approximation with periodic boundary conditions"><code class="xref py py-mod docutils literal"><span class="pre">pbc.df</span></code></a> module provides the fundamental functions to handle the
density fitting (DF) integral tensors required by the gamma-point and k-point
PBC calculations.  There are four types of DF methods available for PBC
systems.  They are FFTDF (plane-wave density fitting with fast Fourier
transformation), AFTDF (plane-wave density fitting with analytical Fourier
transformation), GDF (Gaussian density fitting) and MDF (mixed density fitting).
The Coulomb integrals and nuclear attraction integrals in the PBC calculations
are all computed with DF technique.  The default scheme is FFTDF.</p>
<p>The characters of these PBC DF methods are summarized in the following table</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="15%" />
<col width="15%" />
<col width="14%" />
<col width="20%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Subject</td>
<td>FFTDF</td>
<td>AFTDF</td>
<td>GDF</td>
<td>MDF</td>
</tr>
<tr class="row-even"><td>Initialization</td>
<td>No</td>
<td>No</td>
<td>Slow</td>
<td>Slow</td>
</tr>
<tr class="row-odd"><td>HF Coulomb matrix (J)</td>
<td>Fast</td>
<td>Slow</td>
<td>Fast</td>
<td>Moderate</td>
</tr>
<tr class="row-even"><td>HF exchange matrix (K)</td>
<td>Slow</td>
<td>Slow</td>
<td>Fast</td>
<td>Moderate</td>
</tr>
<tr class="row-odd"><td>Building ERIs</td>
<td>Slow</td>
<td>Slow</td>
<td>Fast</td>
<td>Moderate</td>
</tr>
<tr class="row-even"><td>All-electron calculation</td>
<td>Huge error</td>
<td>Large error</td>
<td>Accurate</td>
<td>Most accurate</td>
</tr>
<tr class="row-odd"><td>Low-dimension system</td>
<td>N/A</td>
<td>0D,1D,2D</td>
<td>0D,1D,2D</td>
<td>0D,1D,2D</td>
</tr>
</tbody>
</table>
<div class="section" id="fftdf-fft-based-density-fitting">
<span id="fftdf"></span><h3>21.5.1.1. FFTDF &#8212; FFT-based density fitting<a class="headerlink" href="#fftdf-fft-based-density-fitting" title="Permalink to this headline">¶</a></h3>
<p>FFTDF represents the method to compute electron repulsion integrals in
reciprocal space with the Fourier transformed Coulomb kernel</p>
<div class="math">
\[(ij|kl) = \sum_G \rho_{ij}(\mathbf{G}) \frac{4\pi}{G^2} \rho_{kl}(-\mathbf{G})\]</div>
<p><span class="math">\(\mathbf{G}\)</span> is the plane wave vector.
<span class="math">\(\rho_{ij}(\mathbf{G})\)</span> is the Fourier transformed orbital pair</p>
<div class="math">
\[\rho_{ij}(\mathbf{G}) = \sum_{r} e^{-\mathbf{G}\cdot\mathbf{r}} \phi_i(\mathbf{r})\phi_j(\mathbf{r})\]</div>
<p>Here are some examples to initialize FFTDF object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fftdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">FFTDF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fftdf</span><span class="p">)</span>
<span class="go">&lt;pyscf.pbc.df.fft.FFTDF object at 0x7f599dbd6450&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="p">)</span>
<span class="go">&lt;pyscf.pbc.df.fft.FFTDF object at 0x7f59a1a10c50&gt;</span>
</pre></div>
</div>
<p>As the default integral scheme of PBC calculations, FFTDF is created when
initializing the PBC mean-field object and held in the attribute <code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code>.</p>
<div class="section" id="nuclear-type-integrals">
<h4>21.5.1.1.1. Nuclear type integrals<a class="headerlink" href="#nuclear-type-integrals" title="Permalink to this headline">¶</a></h4>
<p>PBC nuclear-electron interaction and pseudo-potential (PP) integrals can be
computed with the FFTDF methods <code class="xref py py-func docutils literal"><span class="pre">FFTDF.get_nuc()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">FFTDF.get_pp()</span></code>.
<code class="xref py py-func docutils literal"><span class="pre">FFTDF.get_nuc()</span></code> function only evaluates the integral of the point charge.
If PP was specified in the cell object, <code class="xref py py-func docutils literal"><span class="pre">FFTDF.get_nuc()</span></code> produces the
integrals of the point nuclei with the effective charges.  If PP was not
defined in the cell object, <code class="xref py py-func docutils literal"><span class="pre">FFTDF.get_pp()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">FFTDF.get_nuc()</span></code>
produce the same integrals.  Depending on the input k-point(s),
the two functions can produce the nuclear-type integrals for a single k-point or
a list of nuclear-type integrals for the k-points.  By default, they compute the
nuclear-type integrals of Gamma point:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vnuc</span> <span class="o">=</span> <span class="n">fftdf</span><span class="o">.</span><span class="n">get_pp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">vnuc</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vnuc</span> <span class="o">=</span> <span class="n">fftdf</span><span class="o">.</span><span class="n">get_pp</span><span class="p">(</span><span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">vnuc</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(8, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vnuc</span> <span class="o">=</span> <span class="n">fftdf</span><span class="o">.</span><span class="n">get_pp</span><span class="p">(</span><span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">vnuc</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(2, 2)</span>
</pre></div>
</div>
</div>
<div class="section" id="hartree-fock-coulomb-and-exchange">
<h4>21.5.1.1.2. Hartree-Fock Coulomb and exchange<a class="headerlink" href="#hartree-fock-coulomb-and-exchange" title="Permalink to this headline">¶</a></h4>
<p><code class="xref py py-class docutils literal"><span class="pre">FFTDF</span></code> class provides a method <code class="xref py py-func docutils literal"><span class="pre">FFTDF.get_jk()</span></code> to compute
Hartree-Fock Coulomb matrix (J) and exchange matrix (K).  This method can take
one density matrix or a list of density matrices as input and return the J and K
matrices for each density matrix:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">fftdf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">fftdf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
<p>When k-points are specified, the input density matrices should have the correct
shape that matches the number of k-points:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">fftdf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">kpts</span><span class="o">=</span><span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">fftdf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">kpts</span><span class="o">=</span><span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(5, 3, 2, 2)</span>
</pre></div>
</div>
</div>
<div class="section" id="index-eri-tensor-and-integral-transformation">
<h4>21.5.1.1.3. 4-index ERI tensor and integral transformation<a class="headerlink" href="#index-eri-tensor-and-integral-transformation" title="Permalink to this headline">¶</a></h4>
<p>4-index electron repulsion integrals can be computed with <code class="xref py py-func docutils literal"><span class="pre">FFTDF.get_eri()</span></code>
and <code class="xref py py-func docutils literal"><span class="pre">FFTDF.ao2mo()</span></code> methods.  Given 4 k-points(s) (corresponding to the 4
AO indices), <code class="xref py py-func docutils literal"><span class="pre">FFTDF.get_eri()</span></code> method produce the regular 4-index ERIs
<span class="math">\((ij|kl)\)</span> in AO basis.  The 4 k-points should follow the law of momentum
conservation</p>
<div class="math">
\[(\mathbf{k}_j - \mathbf{k}_i + \mathbf{k}_l - \mathbf{k}_k) \cdot a = 2n\pi.\]</div>
<p>By default, four <span class="math">\(\Gamma\)</span>-points are assigned to the four AO indices.
As the format of molecular ERI tensor, the PBC ERI tensor is reshaped to a 2D
array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eri</span> <span class="o">=</span> <span class="n">fftdf</span><span class="o">.</span><span class="n">get_eri</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eri</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(4, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eri</span> <span class="o">=</span> <span class="n">fftdf</span><span class="o">.</span><span class="n">get_eri</span><span class="p">([</span><span class="n">kpts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">kpts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">kpts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">kpts</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eri</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(4, 4)</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal"><span class="pre">FFTDF.ao2mo()</span></code> function applies integral transformation for the given four
sets of orbital coefficients, four input k-points.  The four k-points need to
follow the momentum conservation law.  Similar to <code class="xref py py-func docutils literal"><span class="pre">FFTDF.get_eri()</span></code>, the
returned integral tensor is shaped to a 2D array:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">orbs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eri_mo</span> <span class="o">=</span> <span class="n">fftdf</span><span class="o">.</span><span class="n">get_eri</span><span class="p">(</span><span class="n">orbs</span><span class="p">,</span> <span class="p">[</span><span class="n">kpts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">kpts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">kpts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">kpts</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eri_mo</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(4, 4)</span>
</pre></div>
</div>
</div>
<div class="section" id="kinetic-energy-cutoff">
<h4>21.5.1.1.4. Kinetic energy cutoff<a class="headerlink" href="#kinetic-energy-cutoff" title="Permalink to this headline">¶</a></h4>
<p>The accuracy of FFTDF integrals are affected by the kinetic energy cutoff.  The
default kinetic energy cutoff is a conservative estimation based on the basis
set and the lattice parameter.  You can adjust the attribute <code class="xref py py-attr docutils literal"><span class="pre">FFTDF.gs</span></code>
(the numbers of grid points in each positive direction) to change the kinetic
energy cutoff.  If any values in <code class="xref py py-attr docutils literal"><span class="pre">FFTDF.gs</span></code> is too small to reach the
required accuracy <code class="xref py py-attr docutils literal"><span class="pre">cell.precision</span></code>, <code class="xref py py-class docutils literal"><span class="pre">FFTDF</span></code> may output a warning
message, eg:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">WARN</span><span class="p">:</span> <span class="n">ke_cutoff</span><span class="o">/</span><span class="n">gs</span> <span class="p">(</span><span class="mf">12.437</span> <span class="o">/</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">enough</span> <span class="k">for</span> <span class="n">FFTDF</span> <span class="n">to</span> <span class="n">get</span> <span class="n">integral</span> <span class="n">accuracy</span> <span class="mf">1e-08</span><span class="o">.</span>
<span class="n">Coulomb</span> <span class="n">integral</span> <span class="n">error</span> <span class="ow">is</span> <span class="o">~</span> <span class="mf">2.6</span> <span class="n">Eh</span><span class="o">.</span>
<span class="n">Recomended</span> <span class="n">ke_cutoff</span><span class="o">/</span><span class="n">gs</span> <span class="n">are</span> <span class="mf">538.542</span> <span class="o">/</span> <span class="p">[</span><span class="mi">20</span> <span class="mi">20</span> <span class="mi">20</span><span class="p">]</span><span class="o">.</span>
</pre></div>
</div>
<p>In this warning message, <code class="docutils literal"><span class="pre">Coulomb</span> <span class="pre">integral</span> <span class="pre">error</span></code> is a rough estimation for
the largest error of the matrix elements of the two-electron Coulomb integrals.
The overall computational error may be varied by 1 - 2 orders of magnitude.</p>
</div>
</div>
<div class="section" id="aftdf-aft-based-density-fitting">
<h3>21.5.1.2. AFTDF &#8212; AFT-based density fitting<a class="headerlink" href="#aftdf-aft-based-density-fitting" title="Permalink to this headline">¶</a></h3>
<p>AFTDF mans that the Fourier transform of the orbital pair is computed
analytically</p>
<div class="math">
\[\rho_{ij}(\mathbf{G}) = \int e^{-\mathbf{G}\cdot\mathbf{r}} \phi_i(\mathbf{r})\phi_j(\mathbf{r}) d^3\mathbf{r}\]</div>
<p>To enable AFTDF in the calculation, <code class="xref py py-class docutils literal"><span class="pre">AFTDF</span></code> object can be initialized
and assigned to <code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code> object of mean-field object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aft</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">AFTDF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">aft</span><span class="p">)</span>
<span class="go">&lt;pyscf.pbc.df.aft.AFTDF object at 0x7ff8b1893d90&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">with_df</span> <span class="o">=</span> <span class="n">aft</span>
</pre></div>
</div>
<p>Generally, AFTDF is slower than FFTDF method.</p>
<p><code class="xref py py-class docutils literal"><span class="pre">AFTDF</span></code> class offers the same methods as the <code class="xref py py-class docutils literal"><span class="pre">FFTDF</span></code> class.
Nuclear and PP integrals, Hartree-Fock J and K matrices, electron repulsion
integrals and integral transformation can be computed with functions
<code class="xref py py-func docutils literal"><span class="pre">AFTDF.get_nuc()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">AFTDF.get_pp()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">AFTDF.get_jk()</span></code>,
<code class="xref py py-func docutils literal"><span class="pre">AFTDF.get_eri()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">AFTDF.ao2mo()</span></code> using the same calling APIs as the
analogy functions in <a class="reference internal" href="#fftdf"><span class="std std-ref">FFTDF &#8212; FFT-based density fitting</span></a>.</p>
<div class="section" id="id1">
<h4>21.5.1.2.1. Kinetic energy cutoff<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p><code class="xref py py-class docutils literal"><span class="pre">AFTDF</span></code> also makes estimation on the kinetic energy cutoff.  When the
any values of <code class="xref py py-attr docutils literal"><span class="pre">AFTDF.gs</span></code> are too small for required accuracy
<code class="xref py py-attr docutils literal"><span class="pre">cell.precision</span></code>, this class also outputs the
<code class="docutils literal"><span class="pre">Coulomb</span> <span class="pre">integral</span> <span class="pre">error</span></code> warning message as the <code class="xref py py-class docutils literal"><span class="pre">FFTDF</span></code> class.</p>
</div>
</div>
<div class="section" id="gdf-gaussian-density-fitting">
<span id="pbc-gdf"></span><h3>21.5.1.3. GDF &#8212; Gaussian density fitting<a class="headerlink" href="#gdf-gaussian-density-fitting" title="Permalink to this headline">¶</a></h3>
<p>GDF is an analogy of the conventional density fitting method with periodic
boundary condition.  The auxiliary fitting basis in PBC GDF is periodic Gaussian
function (To ensure the long range Coulomb integrals converging in the real
space lattice summation, the multipoles are removed from the auxiliary basis).
<code class="xref py py-class docutils literal"><span class="pre">GDF</span></code> object can be initialized and enabled in the SCF calculation in two
ways:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">GDF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">with_df</span> <span class="o">=</span> <span class="n">gdf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Using SCF.density_fit method</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="p">)</span>
<span class="go">&lt;pyscf.pbc.df.df.GDF object at 0x7fec7722aa10&gt;</span>
</pre></div>
</div>
<p>Similar to the molecular code, <code class="xref py py-func docutils literal"><span class="pre">SCF.density_fit()</span></code> method returns a
mean-field object with <code class="xref py py-class docutils literal"><span class="pre">GDF</span></code> as the integral engine.</p>
<p>In the <code class="xref py py-class docutils literal"><span class="pre">GDF</span></code> method, the DF-integral tensor is precomputed and stored
on disk.  <code class="xref py py-class docutils literal"><span class="pre">GDF</span></code> method supports both the <span class="math">\(\Gamma\)</span>-point ERIs and
the ERIs of different k-points.  <code class="xref py py-attr docutils literal"><span class="pre">GDF.kpts</span></code> should be specified before
initializing <code class="xref py py-class docutils literal"><span class="pre">GDF</span></code> object.  <code class="xref py py-class docutils literal"><span class="pre">GDF</span></code> class provides the same APIs as
the <code class="xref py py-class docutils literal"><span class="pre">FFTDF</span></code> class to compute nuclear integrals and electron Coulomb
repulsion integrals:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">GDF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">get_eri</span><span class="p">([</span><span class="n">kpts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">kpts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">kpts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">kpts</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<p>In the mean-field calculation, assigning <code class="xref py py-attr docutils literal"><span class="pre">kpts</span></code> attribute to mean-field
object updates the <code class="xref py py-attr docutils literal"><span class="pre">kpts</span></code> attribute of the underlying DF method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">KRHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kpts</span> <span class="o">=</span> <span class="n">kpts</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">get_eri</span><span class="p">([</span><span class="n">kpts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">kpts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">kpts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">kpts</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<p>Once the GDF integral tensor was initialized, the <code class="xref py py-class docutils literal"><span class="pre">GDF</span></code> can be only used
with certain k-points calculations.  An incorrect <code class="xref py py-attr docutils literal"><span class="pre">kpts</span></code> argument can lead
to a runtime error:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">GDF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kpts</span><span class="o">=</span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">get_eri</span><span class="p">([</span><span class="n">kpt</span><span class="p">,</span><span class="n">kpt</span><span class="p">,</span><span class="n">kpt</span><span class="p">,</span><span class="n">kpt</span><span class="p">])</span>
<span class="go">RuntimeError: j3c for kpts [[ 0.53135523  0.06389596  0.19441766]</span>
<span class="go"> [ 0.53135523  0.06389596  0.19441766]] is not initialized.</span>
<span class="go">You need to update the attribute .kpts then call .build() to initialize j3c.</span>
</pre></div>
</div>
<p>The GDF initialization is very expensive.  To reduce the initialization cost in
a series of calculations, it would be useful to cache the GDF integral tensor in
a file then load them into the calculation when needed.  The GDF integral tensor
can be saved and loaded the same way as we did for the molecular DF method (see
<a class="reference internal" href="../df.html#sl-cderi"><span class="std std-ref">Saving/Loading DF integral tensor</span></a>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">)</span>
<span class="n">gdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">GDF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kpts</span><span class="o">=</span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="n">gdf</span><span class="o">.</span><span class="n">_cderi_to_save</span> <span class="o">=</span> <span class="s1">&#39;df_ints.h5&#39;</span>  <span class="c1"># To save the GDF integrals</span>
<span class="n">gdf</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">KRHF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kpts</span><span class="o">=</span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">_cderi</span> <span class="o">=</span> <span class="s1">&#39;df_ints.h5&#39;</span>   <span class="c1"># To load the GDF integrals</span>
<span class="n">mf</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="auxiliary-gaussian-basis">
<h4>21.5.1.3.1. Auxiliary Gaussian basis<a class="headerlink" href="#auxiliary-gaussian-basis" title="Permalink to this headline">¶</a></h4>
<p>GDF method requires a set of Gaussian functions as the density fitting auxiliary basis.
See also <a class="reference internal" href="../df.html#df-auxbasis"><span class="std std-ref">DF auxiliary basis</span></a> and <a class="reference internal" href="../df.html#df-etb-auxbasis"><span class="std std-ref">Even-tempered auxiliary Gaussian basis</span></a> for the choices of DF auxiliary
basis in PySCF GDF code.  There are not many optimized auxiliary basis sets available
for PBC AO basis.  You can use the even-tempered Gaussian functions as the
auxiliary basis in the PBC GDF method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">)</span>
<span class="n">gdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">GDF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kpts</span><span class="o">=</span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="n">gdf</span><span class="o">.</span><span class="n">auxbasis</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">aug_etb</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="n">gdf</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>21.5.1.3.2. Kinetic energy cutoff<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>GDF method does not require the specification of kinetic energy cutoff.
<code class="xref py py-attr docutils literal"><span class="pre">cell.ke_cutoff</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">cell.gs</span></code> are ignored in the <code class="xref py py-class docutils literal"><span class="pre">GDF</span></code>
class.  Internally, a small set of planewaves is used in the GDF method to
accelerate the convergence of GDF integrals in the real space lattice summation.
The estimated energy cutoff is generated in the <code class="xref py py-class docutils literal"><span class="pre">GDF</span></code> class and stored in
the attribute <code class="xref py py-class docutils literal"><span class="pre">GDF.gs</span></code>.  It is not recommended to change this parameter.</p>
</div>
</div>
<div class="section" id="mdf-mixed-density-fitting">
<span id="pbc-mdf"></span><h3>21.5.1.4. MDF &#8212; mixed density fitting<a class="headerlink" href="#mdf-mixed-density-fitting" title="Permalink to this headline">¶</a></h3>
<p>MDF method combines the AFTDF and GDF in the same framework.  The MDF auxiliary
basis is Gaussian and plane-wave mixed basis.  <code class="xref py py-class docutils literal"><span class="pre">MDF</span></code> object can be
created in two ways:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">,</span> <span class="n">ke_cutoff</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">MDF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mdf</span><span class="p">)</span>
<span class="go">&lt;pyscf.pbc.df.mdf.MDF object at 0x7f4025120a10&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">mix_density_fit</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="p">)</span>
<span class="go">&lt;pyscf.pbc.df.mdf.MDF object at 0x7f7963390a10&gt;</span>
</pre></div>
</div>
<p>The kinetic energy cutoff is specified in this example to constrain the number of
planewaves.  The number of planewaves can also be controlled by through
attribute <code class="xref py py-attr docutils literal"><span class="pre">MDF.gs</span></code>.</p>
<p>In principle, the accuracy of MDF method can be increased by adding
more plane waves in the auxiliary basis.  In practice, the linear dependency
between plane waves and Gaussians may lead to numerical stability issue.
The optimal accuracy (with reasonable computational cost) requires a reasonable
size of plan wave basis with a reasonable linear dependency threshold.  A
threshold too large would remove many auxiliary functions while a threshold too
small would cause numerical instability.
.. In our preliminary test, <code class="docutils literal"><span class="pre">ke_cutoff=10</span></code> is able to produce 0.1 mEh accuracy in
.. total energy.
The default linear dependency threshold is 1e-10.  The threshold can be adjusted
through the attribute <code class="xref py py-attr docutils literal"><span class="pre">MDF.linear_dep_threshold</span></code>.</p>
<p>Like the GDF method, it is also very demanding to initialize the 3-center
Gaussian integrals in the MDF method.  The 3-center Gaussian integral tensor can
be cached in a file and loaded to <code class="xref py py-class docutils literal"><span class="pre">MDF</span></code> object at the runtime:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">)</span>
<span class="n">mdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">MDF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kpts</span><span class="o">=</span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="n">mdf</span><span class="o">.</span><span class="n">_cderi_to_save</span> <span class="o">=</span> <span class="s1">&#39;df_ints.h5&#39;</span>  <span class="c1"># To save the GDF integrals</span>
<span class="n">mdf</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">KRHF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kpts</span><span class="o">=</span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">mix_density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">_cderi</span> <span class="o">=</span> <span class="s1">&#39;df_ints.h5&#39;</span>   <span class="c1"># To load the GDF integrals</span>
<span class="n">mf</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="all-electron-calculation">
<h3>21.5.1.5. All-electron calculation<a class="headerlink" href="#all-electron-calculation" title="Permalink to this headline">¶</a></h3>
<p>All-electron calculations with FFTDF or AFTDF methods requires high energy cutoff
for most elements.  It is recommended to use GDF or MDF methods in the
all-electron calculations.  In fact, GDF and MDF can also be used in PP
calculations to reduce the number of planewave basis if steep functions are
existed in the AO basis.</p>
</div>
<div class="section" id="low-dimension-system">
<h3>21.5.1.6. Low-dimension system<a class="headerlink" href="#low-dimension-system" title="Permalink to this headline">¶</a></h3>
<p><code class="xref py py-class docutils literal"><span class="pre">AFTDF</span></code> supports the systems with 0D (molecule), 1D and 2D periodic
boundary conditions.  When computing the integrals of low-dimension systems, an
infinite vacuum is placed on the free boundary.  You can set the
<code class="xref py py-attr docutils literal"><span class="pre">cell.dimension</span></code>, to enable the integral algorithms for
low-dimension systems in <code class="xref py py-class docutils literal"><span class="pre">AFTDF</span></code> class:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">aft</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">AFTDF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">aft</span><span class="o">.</span><span class="n">get_eri</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal"><span class="pre">GDF</span></code> and <code class="xref py py-class docutils literal"><span class="pre">MDF</span></code> all support the integrals of low-dimension system.
Similar to the usage of AFTDF method, you need to set <code class="xref py py-attr docutils literal"><span class="pre">cell.dimension</span></code> for
the low-dimension systems:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">gdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">GDF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">gdf</span><span class="o">.</span><span class="n">get_eri</span><span class="p">()</span>
</pre></div>
</div>
<p>See more examples in <code class="docutils literal"><span class="pre">examples/pbc/31-low_dimensional_pbc.py</span></code></p>
</div>
</div>
<div class="section" id="interface-to-molecular-df-post-hf-methods">
<h2>21.5.2. Interface to molecular DF-post-HF methods<a class="headerlink" href="#interface-to-molecular-df-post-hf-methods" title="Permalink to this headline">¶</a></h2>
<p>PBC DF object is compatible to the molecular DF object.  The
<span class="math">\(\Gamma\)</span>-point PBC SCF object can be directly passed to molecular DF
post-HF methods for an electron correlation calculations in PBC:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">scf</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">cc</span> <span class="k">as</span> <span class="n">mol_cc</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;3-21g&#39;</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mol_cc</span><span class="o">.</span><span class="n">RCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="examples">
<h2>21.5.3. Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>DF relevant examples can be found in the PySCF examples directory:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">examples</span><span class="o">/</span><span class="n">pbc</span><span class="o">/</span><span class="mi">10</span><span class="o">-</span><span class="n">gamma_point_scf</span><span class="o">.</span><span class="n">py</span>
<span class="n">examples</span><span class="o">/</span><span class="n">pbc</span><span class="o">/</span><span class="mi">11</span><span class="o">-</span><span class="n">gamma_point_all_electron_scf</span><span class="o">.</span><span class="n">py</span>
<span class="n">examples</span><span class="o">/</span><span class="n">pbc</span><span class="o">/</span><span class="mi">12</span><span class="o">-</span><span class="n">gamma_point_post_hf</span><span class="o">.</span><span class="n">py</span>
<span class="n">examples</span><span class="o">/</span><span class="n">pbc</span><span class="o">/</span><span class="mi">20</span><span class="o">-</span><span class="n">k_points_scf</span><span class="o">.</span><span class="n">py</span>
<span class="n">examples</span><span class="o">/</span><span class="n">pbc</span><span class="o">/</span><span class="mi">21</span><span class="o">-</span><span class="n">k_points_all_electron_scf</span><span class="o">.</span><span class="n">py</span>
<span class="n">examples</span><span class="o">/</span><span class="n">pbc</span><span class="o">/</span><span class="mi">30</span><span class="o">-</span><span class="n">ao_integrals</span><span class="o">.</span><span class="n">py</span>
<span class="n">examples</span><span class="o">/</span><span class="n">pbc</span><span class="o">/</span><span class="mi">30</span><span class="o">-</span><span class="n">ao_value_on_grid</span><span class="o">.</span><span class="n">py</span>
<span class="n">examples</span><span class="o">/</span><span class="n">pbc</span><span class="o">/</span><span class="mi">30</span><span class="o">-</span><span class="n">mo_integrals</span><span class="o">.</span><span class="n">py</span>
<span class="n">examples</span><span class="o">/</span><span class="n">pbc</span><span class="o">/</span><span class="mi">31</span><span class="o">-</span><span class="n">low_dimensional_pbc</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
</div>
<div class="section" id="program-reference">
<h2>21.5.4. Program reference<a class="headerlink" href="#program-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="fftdf-class">
<h3>21.5.4.1. FFTDF class<a class="headerlink" href="#fftdf-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyscf.pbc.df.fft.FFTDF">
<em class="property">class </em><code class="descclassname">pyscf.pbc.df.fft.</code><code class="descname">FFTDF</code><span class="sig-paren">(</span><em>cell</em>, <em>kpts=array([[ 0.</em>, <em>0.</em>, <em>0.]])</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/df/fft.html#FFTDF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.df.fft.FFTDF" title="Permalink to this definition">¶</a></dt>
<dd><p>Density expansion on plane waves</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.pbc.df.fft_jk">
<span id="fftdf-helper-functions"></span><h3>21.5.4.2. FFTDF helper functions<a class="headerlink" href="#module-pyscf.pbc.df.fft_jk" title="Permalink to this headline">¶</a></h3>
<p>JK with discrete Fourier transformation</p>
<span class="target" id="module-pyscf.pbc.df.fft_ao2mo"></span><p>Integral transformation with FFT</p>
<dl class="docutils">
<dt>(ij|kl) = int dr1 dr2 i*(r1) j(r1) v(r12) k*(r2) l(r2)</dt>
<dd>= (ij|G) v(G) (G|kl)</dd>
<dt>i*(r) j(r) = 1/N sum_G e^{iGr}  (G|ij)</dt>
<dd>= 1/N sum_G e^{-iGr} (ij|G)</dd>
<dt>&#8220;forward&#8221; FFT:</dt>
<dd>(G|ij) = sum_r e^{-iGr} i*(r) j(r) = fft[ i*(r) j(r) ]</dd>
<dt>&#8220;inverse&#8221; FFT:</dt>
<dd><dl class="first last docutils">
<dt>(ij|G) = sum_r e^{iGr} i*(r) j(r) = N * ifft[ i*(r) j(r) ]</dt>
<dd>= conj[ sum_r e^{-iGr} j*(r) i(r) ]</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="aftdf-class">
<h3>21.5.4.3. AFTDF class<a class="headerlink" href="#aftdf-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyscf.pbc.df.aft.AFTDF">
<em class="property">class </em><code class="descclassname">pyscf.pbc.df.aft.</code><code class="descname">AFTDF</code><span class="sig-paren">(</span><em>cell</em>, <em>kpts=array([[ 0.</em>, <em>0.</em>, <em>0.]])</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/df/aft.html#AFTDF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.df.aft.AFTDF" title="Permalink to this definition">¶</a></dt>
<dd><p>Density expansion on plane waves</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.pbc.df.aft_jk">
<span id="aftdf-helper-functions"></span><h3>21.5.4.4. AFTDF helper functions<a class="headerlink" href="#module-pyscf.pbc.df.aft_jk" title="Permalink to this headline">¶</a></h3>
<p>JK with analytic Fourier transformation</p>
<span class="target" id="module-pyscf.pbc.df.aft_ao2mo"></span><p>Integral transformation with analytic Fourier transformation</p>
</div>
<div class="section" id="gdf-class">
<h3>21.5.4.5. GDF class<a class="headerlink" href="#gdf-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyscf.pbc.df.df.GDF">
<em class="property">class </em><code class="descclassname">pyscf.pbc.df.df.</code><code class="descname">GDF</code><span class="sig-paren">(</span><em>cell</em>, <em>kpts=array([[ 0.</em>, <em>0.</em>, <em>0.]])</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/df/df.html#GDF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.df.df.GDF" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian density fitting</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.pbc.df.df_jk">
<span id="gdf-helper-functions"></span><h3>21.5.4.6. GDF helper functions<a class="headerlink" href="#module-pyscf.pbc.df.df_jk" title="Permalink to this headline">¶</a></h3>
<p>Density fitting with Gaussian basis
Ref:
J. Chem. Phys. 147, 164119 (2017)</p>
<span class="target" id="module-pyscf.pbc.df.df_ao2mo"></span></div>
<div class="section" id="mdf-class">
<h3>21.5.4.7. MDF class<a class="headerlink" href="#mdf-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyscf.pbc.df.mdf.MDF">
<em class="property">class </em><code class="descclassname">pyscf.pbc.df.mdf.</code><code class="descname">MDF</code><span class="sig-paren">(</span><em>cell</em>, <em>kpts=array([[ 0.</em>, <em>0.</em>, <em>0.]])</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/df/mdf.html#MDF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.df.mdf.MDF" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian and planewaves mixed density fitting</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.pbc.df.mdf_jk">
<span id="mdf-helper-functions"></span><h3>21.5.4.8. MDF helper functions<a class="headerlink" href="#module-pyscf.pbc.df.mdf_jk" title="Permalink to this headline">¶</a></h3>
<p>Exact density fitting with Gaussian and planewaves
Ref:
J. Chem. Phys. 147, 164119 (2017)</p>
<span class="target" id="module-pyscf.pbc.df.mdf_ao2mo"></span></div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="tdscf.html" class="btn btn-neutral float-right" title="21.6. pbc.tdscf — PBC time dependent density functional theory" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dft.html" class="btn btn-neutral" title="21.4. pbc.dft — PBC density functional theory" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.7.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>