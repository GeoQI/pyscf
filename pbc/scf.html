

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>34.3. pbc.scf — Mean-field with periodic boundary condition &mdash; PySCF 1.7.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PySCF 1.7.0 documentation" href="../index.html"/>
        <link rel="up" title="34. pbc — Periodic boundary conditions" href="../pbc.html"/>
        <link rel="next" title="34.4. pbc.dft — PBC density functional theory" href="dft.html"/>
        <link rel="prev" title="34.2. pbc.ao2mo — PBC integral transformation" href="ao2mo.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../version.html">2. Version history</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code-rule.html">4. Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmark.html">5. Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">6. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gto.html">7. gto &#8212; Molecular structure and GTO basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ao2mo.html">8. ao2mo &#8212; Integral transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../df.html">9. df &#8212; Density fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symm.html">10. symm &#8211; Point group symmetry and spin symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scf.html">11. scf &#8212; Mean-field methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dft.html">12. dft &#8212; Density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dftd3.html">13. dftd3 &#8212; DFT plus Dispersion Correction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../grad.html">14. grad &#8212; Analytical nuclear gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hessian.html">15. hessian &#8212; Analytical nuclear Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="../soscf.html">16. soscf &#8212; Second order Hartree-Fock solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sgx.html">17. sgx &#8212; Pseudo-spectral methods (COSX, PS, SN-K)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tddft.html">18. tddft &#8212; Time dependent density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tdscf.html">19. tdscf &#8212; Time dependent SCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mp.html">20. mp &#8212; MP2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ci.html">21. ci &#8212; Configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doci.html">22. doci &#8212; Doubly occupied configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cc.html">23. cc &#8212; Coupled cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gw.html">24. gw &#8212; Molecular G0W0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fci.html">25. fci &#8212; Full configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hci.html">26. hci &#8212; Interface to Heat-Bath selective CI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cornell_shci.html">27. cornell_shci &#8212; Interface to Fast Semistochastic Heat Bath Configuration Interaction (SHCI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mcscf.html">28. mcscf &#8212; Multi-configurational self-consistent field</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dmrgscf.html">29. dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fciqmcscf.html">30. fciqmcscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mrpt.html">31. mrpt &#8212; Multi-reference perturbation theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../icmpspt.html">32. icmpspt &#8212; Internal-contracted MPS perturbation method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../x2c.html">33. x2c &#8212; exact-two-component approach</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../pbc.html">34. pbc &#8212; Periodic boundary conditions</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="gto.html">34.1. pbc.gto &#8212; Crystal cell structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="ao2mo.html">34.2. pbc.ao2mo &#8212; PBC integral transformation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">34.3. pbc.scf &#8212; Mean-field with periodic boundary condition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gamma-point-and-single-k-point-calculation">34.3.1. Gamma point and single k-point calculation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mixing-with-molecular-program-for-post-hf-methods">34.3.1.1. Mixing with molecular program for post-HF methods</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#k-point-sampling">34.3.2. k-point sampling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#smearing">34.3.2.1. Smearing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exchange-divergence-treatment">34.3.3. Exchange divergence treatment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gaussian-density-fitting">34.3.4. Gaussian density fitting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyscf.pbc.scf.hf">34.3.5. Program reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="dft.html">34.4. pbc.dft  &#8212; PBC density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="df.html">34.5. pbc.df &#8212; PBC denisty fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="tdscf.html">34.6. pbc.tdscf &#8212; PBC time dependent density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="mp.html">34.7. pbc.mp &#8212; PBC perturbation theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="ci.html">34.8. pbc.ci &#8212; PBC configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="cc.html">34.9. pbc.cc &#8212; PBC coupled cluster</a></li>
<li class="toctree-l2"><a class="reference internal" href="mpicc.html">34.10. pbc.mpicc &#8212; PBC coupled cluster for MPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">34.11. pbc.tools &#8212; PBC tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="mix_mol.html">34.12. Mixing PBC and molecular modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="prop.html">34.13. pbc.prop &#8212; PBC property</a></li>
<li class="toctree-l2"><a class="reference internal" href="gw.html">34.14. pbc.gw &#8212; GW with PBC</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../qmmm.html">35. qmmm &#8212; QM/MM interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../solvent.html">36. solvent &#8212; Solvent methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../semiempirical.html">37. semiempirical &#8212; Semiempirical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../geomopt.html">38. geomopt &#8212; Geometry optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lo.html">39. lo &#8212; Orbital localization and analysis tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools.html">40. tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced.html">41. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ccn.html">42. ccn &#8212; Auto-Generated Coupled-Cluster Equations of Arbitrary Order</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nao.html">43. nao &#8212; Numerical Atomic Orbitals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lib.html">44. <code class="docutils literal"><span class="pre">lib</span></code> &#8212; Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../prop.html">45. prop &#8212; Molecular properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">46. data &#8212; Data for constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../shciscf.html">47. shciscf &#8212; Semistochastic Heat Bath Configuration Interaction for SCF</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PySCF</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../pbc.html">34. pbc &#8212; Periodic boundary conditions</a> &raquo;</li>
        
      <li>34.3. pbc.scf &#8212; Mean-field with periodic boundary condition</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/pbc/scf.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pbc-scf-mean-field-with-periodic-boundary-condition">
<span id="pbc-scf"></span><h1>34.3. pbc.scf &#8212; Mean-field with periodic boundary condition<a class="headerlink" href="#pbc-scf-mean-field-with-periodic-boundary-condition" title="Permalink to this headline">¶</a></h1>
<p>This module is constructed to be analogous to the molecular <a class="reference internal" href="../scf.html#module-pyscf.scf" title="pyscf.scf"><code class="xref py py-mod docutils literal"><span class="pre">pyscf.scf</span></code></a> module to handle
mean-field calculations with periodic boundary conditions.</p>
<div class="section" id="gamma-point-and-single-k-point-calculation">
<h2>34.3.1. Gamma point and single k-point calculation<a class="headerlink" href="#gamma-point-and-single-k-point-calculation" title="Permalink to this headline">¶</a></h2>
<p>The usage of the Gamma point Hartree-Fock program is very close to that of the
molecular program.  In a PBC Gamma point calculation, one needs to initialize the
<code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object and the corresponding <code class="xref py py-class docutils literal"><span class="pre">pyscf.pbc.scf.hf.RHF</span></code> class:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;H     0.      0.      0.</span>
<span class="s1">              H     0.8917  0.8917  0.8917&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;sto3g&#39;</span><span class="p">,</span>
    <span class="n">h</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    0       1.7834  1.7834</span>
<span class="s1">    1.7834  0       1.7834</span>
<span class="s1">    1.7834  1.7834  0     &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">gs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>Compared to the <a class="reference internal" href="../scf.html#pyscf.scf.hf.RHF" title="pyscf.scf.hf.RHF"><code class="xref py py-class docutils literal"><span class="pre">pyscf.scf.hf.RHF</span></code></a> object for molecular calculations,
the PBC-HF calculation with <code class="xref py py-class docutils literal"><span class="pre">pyscf.pbc.scf.hf.RHF</span></code> or
<a class="reference internal" href="#pyscf.pbc.scf.uhf.UHF" title="pyscf.pbc.scf.uhf.UHF"><code class="xref py py-class docutils literal"><span class="pre">pyscf.pbc.scf.uhf.UHF</span></code></a> has three differences</p>
<ul>
<li><p class="first"><code class="xref py py-class docutils literal"><span class="pre">pyscf.pbc.scf.hf.RHF</span></code> is the single k-point PBC HF class.  By default,
it creates a Gamma point instance.  You can change to other (single) k-points by
setting the <code class="xref py py-attr docutils literal"><span class="pre">kpt</span></code> attribute:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kpt</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_abs_kpts</span><span class="p">([</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="o">.</span><span class="mi">25</span><span class="p">])</span>  <span class="c1"># convert from scaled kpts</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p class="first">The exchange integrals of the PBC Hartree-Fock method show a slow convergence
with respect to the number of k-points.  A proper treatment for the divergent
part of the exchange integral can improve the convergence.  The attribute
<code class="xref py py-attr docutils literal"><span class="pre">exxdiv</span></code> is used to control the method to handle the divergent exchange
term.  The default <code class="docutils literal"><span class="pre">exxdiv='ewald'</span></code> can be used for most scenarios.  However,
if molecular post-HF methods are mixed with the Gamma point mean-field methods (see
<a class="reference internal" href="#mix-to-mol"><span class="std std-ref">Mixing with molecular program for post-HF methods</span></a>, you will need to explicitly use <code class="docutils literal"><span class="pre">exxdiv=None</span></code> to obtain a consistent total
energy (see <a class="reference internal" href="#exxdiv"><span class="std std-ref">Exchange divergence treatment</span></a>). If PBC post-HF methods are used, the <code class="xref py py-mod docutils literal"><span class="pre">exxdiv</span></code> attribute
is always treated as <code class="docutils literal"><span class="pre">None</span></code> in the correlated calculation to obtain a consistent total energy.</p>
</li>
<li><p class="first">In PBC calculations there are different choices for how to
evaluate 2-electron integrals.  The default integral scheme (FFTDF) is accurate   for pseudo-potentials and fast for DFT calculations but
slow in other scenarios. A second integral
scheme which is a good balance of speed and accuracy for
Hartree-Fock, all-electron, and post-Hartree-Fock calculations, is
Gaussian density fitting. This can be used by setting the <code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code> attribute (see <a class="reference internal" href="df.html#pbc-df"><span class="std std-ref">pbc.df &#8212; PBC denisty fitting</span></a>) or, conveniently, by using the <code class="xref py py-func docutils literal"><span class="pre">density_fit()</span></code> function (see <span class="xref std std-ref">pbc_density_fit</span>). For</p>
</li>
</ul>
<dl class="docutils">
<dt>higher accuracy, you may wish to use</dt>
<dd>mixed density fitting (MDF) (see <span class="xref std std-ref">with_df</span>).  Here is an example to update <code class="xref py py-attr docutils literal"><span class="pre">with_df</span></code></dd>
</dl>
<div class="section" id="mixing-with-molecular-program-for-post-hf-methods">
<span id="mix-to-mol"></span><h3>34.3.1.1. Mixing with molecular program for post-HF methods<a class="headerlink" href="#mixing-with-molecular-program-for-post-hf-methods" title="Permalink to this headline">¶</a></h3>
<p>The Gamma point HF code adopts the same code structure, function and
method names and argument&#8217; conventions as the molecular SCF code.
This desgin allows one to mix PBC HF objects with the existing molecular post-HF
code for PBC electron correlation treatments.  A typical molecular post-HF
calculation starts from the finite-size HF method with the <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code>
object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">cc</span>
<span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>The PBC Gamma point post-HF calculation requires the <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object and
PBC HF object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span>
             <span class="n">h</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">gs</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">cc</span>
<span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>The differences are the <code class="docutils literal"><span class="pre">mol</span></code> or <code class="docutils literal"><span class="pre">cell</span></code> object to create and the
<code class="docutils literal"><span class="pre">scf</span></code> module to import.  With the system-specific mean-field object, one
can carry out various post-HF methods (MP2, Coupled cluster, CISD, TDHF,
TDDFT, ...) using the same code for finite-size and extended systems.
See <a class="reference internal" href="mix_mol.html#mix-mol"><span class="std std-ref">Mixing PBC and molecular modules</span></a> for more details of the interface between PBC and molecular
modules.</p>
</div>
</div>
<div class="section" id="k-point-sampling">
<h2>34.3.2. k-point sampling<a class="headerlink" href="#k-point-sampling" title="Permalink to this headline">¶</a></h2>
<p>An example demonstrating the use of k-points for a KRHF, KRKS calculation, and using the Newton (second-order SCF) solver.</p>
<div class="section" id="smearing">
<h3>34.3.2.1. Smearing<a class="headerlink" href="#smearing" title="Permalink to this headline">¶</a></h3>
<p>In many periodic systems, the HOMO-LUMO gap may become very small. In such a case, one needs to use occupation number smearing
to converge the SCF calculation, as illustrated here:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Cell</span><span class="p">()</span>
<span class="n">cell</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">He 0 0 1</span>
<span class="s1">He 1 0 1</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
<span class="n">cell</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">cell</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Use scf.addons.smearing_ function to modify the</span>
<span class="c1"># PBC (gamma-point or k-points) SCF object</span>
<span class="c1">#</span>
<span class="n">nks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">KRHF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">(</span><span class="n">nks</span><span class="p">))</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">smearing_</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fermi&#39;</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="exchange-divergence-treatment">
<span id="exxdiv"></span><h2>34.3.3. Exchange divergence treatment<a class="headerlink" href="#exchange-divergence-treatment" title="Permalink to this headline">¶</a></h2>
<p>The attribute <code class="xref py py-attr docutils literal"><span class="pre">exxdiv</span></code> controls the handling of the slow convergence
of the HF exchange integrals.
Generally, <code class="xref py py-attr docutils literal"><span class="pre">exxdiv</span></code> leads to a shift in the total energy that
can be thought of as a HF finite size-correction. It also modifies the spectrum of
the occupied orbitals. When a Gamma-point PBC mean-field calculation is mixed with a molecular post-HF implementation, setting this attribute to anything other than <code class="docutils literal"><span class="pre">None</span></code> will lead to an inconsistency in the total energy.</p>
<p>Possible values are <code class="docutils literal"><span class="pre">None</span></code>, <code class="docutils literal"><span class="pre">vcut_sph</span></code> (spherical cutoff), <code class="docutils literal"><span class="pre">vcut_ws</span></code> (Wigner-Seitz cutoff), <code class="docutils literal"><span class="pre">ewald</span></code> (probe-charge Ewald correction).
<code class="docutils literal"><span class="pre">vcut_sph</span></code> and <code class="docutils literal"><span class="pre">vcut_ws</span></code> are only available when using FFTDF. When using hybrid functionals, the exchange treatment will use the <code class="xref py py-attr docutils literal"><span class="pre">exxdiv</span></code> attribute.</p>
<p>Note that when calling <code class="xref py py-func docutils literal"><span class="pre">get_bands()</span></code>, the choice of <code class="xref py py-attr docutils literal"><span class="pre">exxdiv</span></code> affects the band structure. In particular, <code class="docutils literal"><span class="pre">vcut_sph</span></code> (spherical cutoff), <code class="docutils literal"><span class="pre">vcut_ws</span></code> (Wigner-Seitz cutoff) should be used to obtain smooth bands, otherwise, the band structure should be computed by twisting the
SCF calculation (i.e. redoing self-consistency at each k point).</p>
</div>
<div class="section" id="gaussian-density-fitting">
<h2>34.3.4. Gaussian density fitting<a class="headerlink" href="#gaussian-density-fitting" title="Permalink to this headline">¶</a></h2>
<p>This example uses the <code class="xref py py-func docutils literal"><span class="pre">density_fit()</span></code> function to enable Gaussian density fitting:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span> <span class="k">as</span> <span class="n">mol_gto</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">df</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Cell</span><span class="p">()</span>
<span class="n">cell</span><span class="o">.</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">C 0.000000000000   0.000000000000   0.000000000000</span>
<span class="s1">C 1.685068664391   1.685068664391   1.685068664391</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;gth-dzv&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">pseudo</span> <span class="o">=</span> <span class="s1">&#39;gth-pade&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">0.000000000, 3.370137329, 3.370137329</span>
<span class="s1">3.370137329, 0.000000000, 3.370137329</span>
<span class="s1">3.370137329, 3.370137329, 0.000000000&#39;&#39;&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;B&#39;</span>
<span class="n">cell</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">cell</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Default DF auxiliary basis is a set of even-tempered gaussian basis (with</span>
<span class="c1"># exponents alpha * beta**i, i = 1,..,N).  The even-tempered parameter alpha</span>
<span class="c1"># is determined automatically based on the orbital basis.  beta is set to 2.0</span>
<span class="c1">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="module-pyscf.pbc.scf.hf">
<span id="program-reference"></span><h2>34.3.5. Program reference<a class="headerlink" href="#module-pyscf.pbc.scf.hf" title="Permalink to this headline">¶</a></h2>
<p>Hartree-Fock for periodic systems at a single k-point</p>
<dl class="docutils">
<dt>See Also:</dt>
<dd>pyscf.pbc.scf.khf.py : Hartree-Fock for periodic systems with k-point sampling</dd>
</dl>
<dl class="class">
<dt id="pyscf.pbc.scf.hf.SCF">
<em class="property">class </em><code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">SCF</code><span class="sig-paren">(</span><em>cell</em>, <em>kpt=array([ 0.</em>, <em>0.</em>, <em>0.])</em>, <em>exxdiv='ewald'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#SCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class adapted for PBCs.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>kpt</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,) ndarray</span><dd>The AO k-point in Cartesian coordinates, in units of 1/Bohr.</dd>
<dt>exxdiv</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd><p class="first">Exchange divergence treatment, can be one of</p>
<div class="last line-block">
<div class="line">None : ignore G=0 contribution in exchange</div>
<div class="line">&#8216;ewald&#8217; : Ewald probe charge correction (JCP, 122, 234102)</div>
</div>
</dd>
<dt>with_df</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">density fitting object</span><dd>Default is the FFT based DF model. For all-electron calculation,
MDF model is favored for better accuracy.  See also <code class="xref py py-mod docutils literal"><span class="pre">pyscf.pbc.df</span></code>.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>When this flag is set to true, the J/K matrices will be computed
directly through the underlying with_df methods.  Otherwise,
depending the available memory, the 4-index integrals may be cached
and J/K matrices are computed based on the 4-index integrals.</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.dip_moment">
<code class="descname">dip_moment</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#SCF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell (is it well defined)?</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">cell : an instance of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></p>
<p class="last">dm (ndarray) : density matrix</p>
</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z components</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_bands">
<code class="descname">get_bands</code><span class="sig-paren">(</span><em>mf</em>, <em>kpts_band</em>, <em>cell=None</em>, <em>dm=None</em>, <em>kpt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) &#8216;band&#8217; k-points.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span><dd>Bands energies E_n(k)</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span><dd>Band orbitals psi_n(k)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_j">
<code class="descname">get_j</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>kpt=None</em>, <em>kpts_band=None</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#SCF.get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J matrix for the given density matrix and k-point (kpt).
When kpts_band is given, the J matrices on kpts_band are evaluated.</p>
<blockquote>
<div>J_{pq} = sum_{rs} (pq|rs) dm[s,r]</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_jk">
<code class="descname">get_jk</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>kpt=None</em>, <em>kpts_band=None</em>, <em>with_j=True</em>, <em>with_k=True</em>, <em>omega=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#SCF.get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Coulomb (J) and exchange (K) following <code class="xref py py-func docutils literal"><span class="pre">scf.hf.RHF.get_jk_()</span></code>.
for particular k-point (kpt).</p>
<p>When kpts_band is given, the J, K matrices on kpts_band are evaluated.</p>
<blockquote>
<div>J_{pq} = sum_{rs} (pq|rs) dm[s,r]
K_{pq} = sum_{rs} (pr|sq) dm[r,s]</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_jk_incore">
<code class="descname">get_jk_incore</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>kpt=None</em>, <em>omega=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#SCF.get_jk_incore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_jk_incore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Coulomb (J) and exchange (K) following <code class="xref py py-func docutils literal"><span class="pre">scf.hf.RHF.get_jk_()</span></code>.</p>
<p><em>Incore</em> version of Coulomb and exchange build only.
Currently RHF always uses PBC AO integrals (unlike RKS), since
exchange is currently computed by building PBC AO integrals.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_k">
<code class="descname">get_k</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>kpt=None</em>, <em>kpts_band=None</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#SCF.get_k"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute K matrix for the given density matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_rho">
<code class="descname">get_rho</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>grids=None</em>, <em>kpt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.get_veff">
<code class="descname">get_veff</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em>, <em>kpt=None</em>, <em>kpts_band=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#SCF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.to_ghf">
<code class="descname">to_ghf</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#SCF.to_ghf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.to_ghf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a GHF/GKS object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.to_rhf">
<code class="descname">to_rhf</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#SCF.to_rhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.to_rhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a RHF/ROHF/RKS/ROKS object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.hf.SCF.to_uhf">
<code class="descname">to_uhf</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#SCF.to_uhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.to_uhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a UHF/UKS object</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.dip_moment">
<code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">dip_moment</code><span class="sig-paren">(</span><em>cell</em>, <em>dm</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>grids=None</em>, <em>rho=None</em>, <em>kpt=array([ 0.</em>, <em>0.</em>, <em>0.])</em>, <em>origin=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell (is it well defined)?</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">cell : an instance of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></p>
<p class="last">dm (ndarray) : density matrix</p>
</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z components</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_bands">
<code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">get_bands</code><span class="sig-paren">(</span><em>mf</em>, <em>kpts_band</em>, <em>cell=None</em>, <em>dm=None</em>, <em>kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) &#8216;band&#8217; k-points.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span><dd>Bands energies E_n(k)</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span><dd>Band orbitals psi_n(k)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_hcore">
<code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">get_hcore</code><span class="sig-paren">(</span><em>cell</em>, <em>kpt=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#get_hcore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_hcore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the core Hamiltonian AO matrix.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_j">
<code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">get_j</code><span class="sig-paren">(</span><em>cell</em>, <em>dm</em>, <em>hermi=1</em>, <em>vhfopt=None</em>, <em>kpt=array([ 0.</em>, <em>0.</em>, <em>0.])</em>, <em>kpts_band=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Coulomb (J) AO matrix for the given density matrix.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Whether J, K matrix is hermitian
| 0 : no hermitian or symmetric
| 1 : hermitian
| 2 : anti-hermitian</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
<dt>kpt</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,) ndarray</span><dd>The &#8220;inner&#8221; dummy k-point at which the DM was evaluated (or
sampled).</dd>
<dt>kpts_band</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,) ndarray or (<a href="#id1"><span class="problematic" id="id2">*</span></a>,3) ndarray</span><dd>An arbitrary &#8220;band&#8221; k-point at which J is evaluated.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>The function returns one J matrix, corresponding to the input
density matrix (both order and shape).</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_jk">
<code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">get_jk</code><span class="sig-paren">(</span><em>mf</em>, <em>cell</em>, <em>dm</em>, <em>hermi=1</em>, <em>vhfopt=None</em>, <em>kpt=array([ 0.</em>, <em>0.</em>, <em>0.])</em>, <em>kpts_band=None</em>, <em>with_j=True</em>, <em>with_k=True</em>, <em>omega=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Coulomb (J) and exchange (K) AO matrices for the given density matrix.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Whether J, K matrix is hermitian
| 0 : no hermitian or symmetric
| 1 : hermitian
| 2 : anti-hermitian</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
<dt>kpt</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,) ndarray</span><dd>The &#8220;inner&#8221; dummy k-point at which the DM was evaluated (or
sampled).</dd>
<dt>kpts_band</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,) ndarray or (<a href="#id3"><span class="problematic" id="id4">*</span></a>,3) ndarray</span><dd>An arbitrary &#8220;band&#8221; k-point at which J and K are evaluated.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>The function returns one J and one K matrix, corresponding to the input
density matrix (both order and shape).</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_nuc">
<code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">get_nuc</code><span class="sig-paren">(</span><em>cell</em>, <em>kpt=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#get_nuc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_nuc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bare periodic nuc-el AO matrix, with G=0 removed.</p>
<p>See Martin (12.16)-(12.21).</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_ovlp">
<code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">get_ovlp</code><span class="sig-paren">(</span><em>cell</em>, <em>kpt=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#get_ovlp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the overlap AO matrix.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_rho">
<code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">get_rho</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>grids=None</em>, <em>kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#get_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.get_t">
<code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">get_t</code><span class="sig-paren">(</span><em>cell</em>, <em>kpt=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#get_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the kinetic energy AO matrix.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.init_guess_by_chkfile">
<code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em>cell</em>, <em>chkfile_name</em>, <em>project=None</em>, <em>kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal"><span class="pre">cell</span></code></p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, (nao,nao) ndarray</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.makov_payne_correction">
<code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">makov_payne_correction</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#makov_payne_correction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.makov_payne_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Makov-Payne correction (Phys. Rev. B, 51, 4014)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.hf.normalize_dm_">
<code class="descclassname">pyscf.pbc.scf.hf.</code><code class="descname">normalize_dm_</code><span class="sig-paren">(</span><em>mf</em>, <em>dm</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/hf.html#normalize_dm_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.normalize_dm_" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale density matrix to make it produce the correct number of electrons.</p>
</dd></dl>

<span class="target" id="module-pyscf.pbc.scf.uhf"></span><p>Unrestricted Hartree-Fock for periodic systems at a single k-point</p>
<dl class="docutils">
<dt>See Also:</dt>
<dd>pyscf/pbc/scf/khf.py : Hartree-Fock for periodic systems with k-point sampling</dd>
</dl>
<dl class="class">
<dt id="pyscf.pbc.scf.uhf.UHF">
<em class="property">class </em><code class="descclassname">pyscf.pbc.scf.uhf.</code><code class="descname">UHF</code><span class="sig-paren">(</span><em>cell</em>, <em>kpt=array([ 0.</em>, <em>0.</em>, <em>0.])</em>, <em>exxdiv='ewald'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/uhf.html#UHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF" title="Permalink to this definition">¶</a></dt>
<dd><p>UHF class for PBCs.</p>
<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.convert_from_">
<code class="descname">convert_from_</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/uhf.html#UHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to RHF/ROHF</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.dip_moment">
<code class="descname">dip_moment</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/uhf.html#UHF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">cell : an instance of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></p>
<p class="last">dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z components</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.energy_tot">
<code class="descname">energy_tot</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>h1e=None</em>, <em>vhf=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.energy_tot" title="Permalink to this definition">¶</a></dt>
<dd><p>Total Hartree-Fock energy, electronic part plus nuclear repulstion
See <code class="xref py py-func docutils literal"><span class="pre">scf.hf.energy_elec()</span></code> for the electron part</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_bands">
<code class="descname">get_bands</code><span class="sig-paren">(</span><em>kpts_band</em>, <em>cell=None</em>, <em>dm=None</em>, <em>kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/uhf.html#UHF.get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) &#8216;band&#8217; k-points.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span><dd>Bands energies E_n(k)</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span><dd>Band orbitals psi_n(k)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_j">
<code class="descname">get_j</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>kpt=None</em>, <em>kpts_band=None</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J matrix for the given density matrix and k-point (kpt).
When kpts_band is given, the J matrices on kpts_band are evaluated.</p>
<blockquote>
<div>J_{pq} = sum_{rs} (pq|rs) dm[s,r]</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_jk">
<code class="descname">get_jk</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>kpt=None</em>, <em>kpts_band=None</em>, <em>with_j=True</em>, <em>with_k=True</em>, <em>omega=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Coulomb (J) and exchange (K) following <code class="xref py py-func docutils literal"><span class="pre">scf.hf.RHF.get_jk_()</span></code>.
for particular k-point (kpt).</p>
<p>When kpts_band is given, the J, K matrices on kpts_band are evaluated.</p>
<blockquote>
<div>J_{pq} = sum_{rs} (pq|rs) dm[s,r]
K_{pq} = sum_{rs} (pr|sq) dm[r,s]</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_jk_incore">
<code class="descname">get_jk_incore</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>kpt=None</em>, <em>omega=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_jk_incore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Coulomb (J) and exchange (K) following <code class="xref py py-func docutils literal"><span class="pre">scf.hf.RHF.get_jk_()</span></code>.</p>
<p><em>Incore</em> version of Coulomb and exchange build only.
Currently RHF always uses PBC AO integrals (unlike RKS), since
exchange is currently computed by building PBC AO integrals.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_k">
<code class="descname">get_k</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>kpt=None</em>, <em>kpts_band=None</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute K matrix for the given density matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_rho">
<code class="descname">get_rho</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>grids=None</em>, <em>kpt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.make_rdm1">
<code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>mo_occ=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A list of 2D ndarrays for alpha and beta spins</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.uhf.UHF.stability">
<code class="descname">stability</code><span class="sig-paren">(</span><em>internal=True</em>, <em>external=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.stability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.stability" title="Permalink to this definition">¶</a></dt>
<dd><p>Stability analysis for RHF/RKS method.</p>
<p>See also pyscf.scf.stability.uhf_stability function.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mf : UHF or UKS object</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>internal</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Internal stability, within the UHF space.</dd>
<dt>external</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>External stability. Including the UHF -&gt; GHF and real -&gt; complex
stability analysis.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>New orbitals that are more close to the stable condition.  The return
value includes two set of orbitals.  The first corresponds to the
internal stablity and the second corresponds to the external stability.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.uhf.dip_moment">
<code class="descclassname">pyscf.pbc.scf.uhf.</code><code class="descname">dip_moment</code><span class="sig-paren">(</span><em>cell</em>, <em>dm</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>grids=None</em>, <em>rho=None</em>, <em>kpt=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/uhf.html#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">cell : an instance of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></p>
<p class="last">dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z components</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.uhf.init_guess_by_chkfile">
<code class="descclassname">pyscf.pbc.scf.uhf.</code><code class="descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em>cell</em>, <em>chkfile_name</em>, <em>project=None</em>, <em>kpt=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/uhf.html#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file and make the density matrix
for UHF initial guess.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, (nao,nao) ndarray</dd>
</dl>
</dd></dl>

<span class="target" id="module-pyscf.pbc.scf.khf"></span><p>Hartree-Fock for periodic systems with k-point sampling</p>
<dl class="docutils">
<dt>See Also:</dt>
<dd>hf.py : Hartree-Fock for periodic systems at a single k-point</dd>
</dl>
<dl class="class">
<dt id="pyscf.pbc.scf.khf.KSCF">
<em class="property">class </em><code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">KSCF</code><span class="sig-paren">(</span><em>cell</em>, <em>kpts=array([[ 0.</em>, <em>0.</em>, <em>0.]])</em>, <em>exxdiv='ewald'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#KSCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class with k-point sampling.</p>
<p>Compared to molecular SCF, some members such as mo_coeff, mo_occ
now have an additional first dimension for the k-points,
e.g. mo_coeff is (nkpts, nao, nao) ndarray</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>kpts</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nks,3) ndarray</span><dd>The sampling k-points in Cartesian coordinates, in units of 1/Bohr.</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.dip_moment">
<code class="descname">dip_moment</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#KSCF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell (is it well defined)?</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">cell : an instance of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></p>
<p class="last">dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z components</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.energy_elec">
<code class="descname">energy_elec</code><span class="sig-paren">(</span><em>mf</em>, <em>dm_kpts=None</em>, <em>h1e_kpts=None</em>, <em>vhf_kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_bands">
<code class="descname">get_bands</code><span class="sig-paren">(</span><em>kpts_band</em>, <em>cell=None</em>, <em>dm_kpts=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#KSCF.get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) &#8216;band&#8217; k-points.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span><dd>Bands energies E_n(k)</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span><dd>Band orbitals psi_n(k)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_fermi">
<code class="descname">get_fermi</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_energy_kpts=None</em>, <em>mo_occ_kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_fermi" title="Permalink to this definition">¶</a></dt>
<dd><p>Fermi level</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_grad">
<code class="descname">get_grad</code><span class="sig-paren">(</span><em>mo_coeff_kpts</em>, <em>mo_occ_kpts</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#KSCF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 1D array of gradients, like non K-pt version
note that occ and virt indices of different k pts now occur
in sequential patches of the 1D array</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_hcore">
<code class="descname">get_hcore</code><span class="sig-paren">(</span><em>mf</em>, <em>cell=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_hcore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the core Hamiltonian AO matrices at sampled k-points.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>kpts : (nkpts, 3) ndarray</dd>
<dt>Returns:</dt>
<dd>hcore : (nkpts, nao, nao) ndarray</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_occ">
<code class="descname">get_occ</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_energy_kpts=None</em>, <em>mo_coeff_kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_ovlp">
<code class="descname">get_ovlp</code><span class="sig-paren">(</span><em>mf</em>, <em>cell=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the overlap AO matrices at sampled k-points.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>kpts : (nkpts, 3) ndarray</dd>
<dt>Returns:</dt>
<dd>ovlp_kpts : (nkpts, nao, nao) ndarray</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_rho">
<code class="descname">get_rho</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>grids=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_veff">
<code class="descname">get_veff</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm_kpts=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em>, <em>kpts=None</em>, <em>kpts_band=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#KSCF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.to_ghf">
<code class="descname">to_ghf</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#KSCF.to_ghf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.to_ghf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a KGHF/KGKS object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.to_rhf">
<code class="descname">to_rhf</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#KSCF.to_rhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.to_rhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a KRHF/KROHF/KRKS/KROKS object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.khf.KSCF.to_uhf">
<code class="descname">to_uhf</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#KSCF.to_uhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.to_uhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a KUHF/KUKS object</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.analyze">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">analyze</code><span class="sig-paren">(</span><em>mf</em>, <em>verbose=5</em>, <em>with_meta_lowdin=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Dipole moment</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.dip_moment">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">dip_moment</code><span class="sig-paren">(</span><em>cell</em>, <em>dm_kpts</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>grids=None</em>, <em>rho=None</em>, <em>kpts=array([[ 0.</em>, <em>0.</em>, <em>0.]])</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell (is it well defined)?</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">cell : an instance of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></p>
<p class="last">dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z components</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.energy_elec">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">energy_elec</code><span class="sig-paren">(</span><em>mf</em>, <em>dm_kpts=None</em>, <em>h1e_kpts=None</em>, <em>vhf_kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#energy_elec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_fermi">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">get_fermi</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_energy_kpts=None</em>, <em>mo_occ_kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#get_fermi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_fermi" title="Permalink to this definition">¶</a></dt>
<dd><p>Fermi level</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_grad">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">get_grad</code><span class="sig-paren">(</span><em>mo_coeff_kpts</em>, <em>mo_occ_kpts</em>, <em>fock</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 1D array of gradients, like non K-pt version
note that occ and virt indices of different k pts now occur
in sequential patches of the 1D array</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_hcore">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">get_hcore</code><span class="sig-paren">(</span><em>mf</em>, <em>cell=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#get_hcore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_hcore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the core Hamiltonian AO matrices at sampled k-points.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>kpts : (nkpts, 3) ndarray</dd>
<dt>Returns:</dt>
<dd>hcore : (nkpts, nao, nao) ndarray</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_j">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">get_j</code><span class="sig-paren">(</span><em>mf</em>, <em>cell</em>, <em>dm_kpts</em>, <em>kpts</em>, <em>kpts_band=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Coulomb (J) AO matrix at sampled k-points.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>dm_kpts</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nkpts, nao, nao) ndarray or a list of (nkpts,nao,nao) ndarray</span><dd>Density matrix at each k-point.  If a list of k-point DMs, eg,
UHF alpha and beta DM, the alpha and beta DMs are contracted
separately.  It needs to be Hermitian.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>kpts_band</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(k,3) ndarray</span><dd>A list of arbitrary &#8220;band&#8221; k-points at which to evalute the matrix.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>vj : (nkpts, nao, nao) ndarray
or list of vj if the input dm_kpts is a list of DMs</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_jk">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">get_jk</code><span class="sig-paren">(</span><em>mf</em>, <em>cell</em>, <em>dm_kpts</em>, <em>kpts</em>, <em>kpts_band=None</em>, <em>with_j=True</em>, <em>with_k=True</em>, <em>omega=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Coulomb (J) and exchange (K) AO matrices at sampled k-points.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>dm_kpts</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nkpts, nao, nao) ndarray</span><dd>Density matrix at each k-point. It needs to be Hermitian.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>kpts_band</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,) ndarray</span><dd>A list of arbitrary &#8220;band&#8221; k-point at which to evalute the matrix.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>vj : (nkpts, nao, nao) ndarray
vk : (nkpts, nao, nao) ndarray
or list of vj and vk if the input dm_kpts is a list of DMs</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_occ">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">get_occ</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_energy_kpts=None</em>, <em>mo_coeff_kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#get_occ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_ovlp">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">get_ovlp</code><span class="sig-paren">(</span><em>mf</em>, <em>cell=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#get_ovlp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the overlap AO matrices at sampled k-points.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>kpts : (nkpts, 3) ndarray</dd>
<dt>Returns:</dt>
<dd>ovlp_kpts : (nkpts, nao, nao) ndarray</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.get_rho">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">get_rho</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>grids=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#get_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.init_guess_by_chkfile">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em>cell</em>, <em>chkfile_name</em>, <em>project=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the KHF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal"><span class="pre">cell</span></code></p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 3D ndarray</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.make_rdm1">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>mo_coeff_kpts</em>, <em>mo_occ_kpts</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One particle density matrices for all k-points.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>dm_kpts : (nkpts, nao, nao) ndarray</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.khf.mulliken_meta">
<code class="descclassname">pyscf.pbc.scf.khf.</code><code class="descname">mulliken_meta</code><span class="sig-paren">(</span><em>cell</em>, <em>dm_ao_kpts</em>, <em>verbose=5</em>, <em>pre_orth_method='ANO'</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/khf.html#mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>A modified Mulliken population analysis, based on meta-Lowdin AOs.</p>
<p>Note this function only computes the Mulliken population for the gamma
point density matrix.</p>
</dd></dl>

<span class="target" id="module-pyscf.pbc.scf.kuhf"></span><p>Hartree-Fock for periodic systems with k-point sampling</p>
<dl class="docutils">
<dt>See Also:</dt>
<dd>hf.py : Hartree-Fock for periodic systems at a single k-point</dd>
</dl>
<dl class="class">
<dt id="pyscf.pbc.scf.kuhf.KUHF">
<em class="property">class </em><code class="descclassname">pyscf.pbc.scf.kuhf.</code><code class="descname">KUHF</code><span class="sig-paren">(</span><em>cell</em>, <em>kpts=array([[ 0.</em>, <em>0.</em>, <em>0.]])</em>, <em>exxdiv='ewald'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#KUHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF" title="Permalink to this definition">¶</a></dt>
<dd><p>UHF class with k-point sampling.</p>
<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.canonicalize">
<code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff_kpts</em>, <em>mo_occ_kpts</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.convert_from_">
<code class="descname">convert_from_</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#KUHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to KUHF</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.dip_moment">
<code class="descname">dip_moment</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#KUHF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">cell : an instance of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></p>
<p class="last">dm_kpts (two lists of ndarrays) : KUHF density matrices of k-points</p>
</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z components</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.energy_elec">
<code class="descname">energy_elec</code><span class="sig-paren">(</span><em>mf</em>, <em>dm_kpts=None</em>, <em>h1e_kpts=None</em>, <em>vhf_kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_bands">
<code class="descname">get_bands</code><span class="sig-paren">(</span><em>kpts_band</em>, <em>cell=None</em>, <em>dm_kpts=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#KUHF.get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) &#8216;band&#8217; k-points.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span><dd>Bands energies E_n(k)</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span><dd>Band orbitals psi_n(k)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_fermi">
<code class="descname">get_fermi</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_energy_kpts=None</em>, <em>mo_occ_kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_fermi" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair of Fermi level for spin-up and spin-down orbitals</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_hcore">
<code class="descname">get_hcore</code><span class="sig-paren">(</span><em>mf</em>, <em>cell=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_hcore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the core Hamiltonian AO matrices at sampled k-points.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>kpts : (nkpts, 3) ndarray</dd>
<dt>Returns:</dt>
<dd>hcore : (nkpts, nao, nao) ndarray</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_occ">
<code class="descname">get_occ</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_energy_kpts=None</em>, <em>mo_coeff_kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_ovlp">
<code class="descname">get_ovlp</code><span class="sig-paren">(</span><em>mf</em>, <em>cell=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the overlap AO matrices at sampled k-points.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>kpts : (nkpts, 3) ndarray</dd>
<dt>Returns:</dt>
<dd>ovlp_kpts : (nkpts, nao, nao) ndarray</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_rho">
<code class="descname">get_rho</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>grids=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.mulliken_meta">
<code class="descname">mulliken_meta</code><span class="sig-paren">(</span><em>cell=None</em>, <em>dm=None</em>, <em>verbose=5</em>, <em>pre_orth_method='ANO'</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#KUHF.mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>A modified Mulliken population analysis, based on meta-Lowdin AOs.</p>
<p>Note this function only computes the Mulliken population for the gamma
point density matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.spin_square">
<code class="descname">spin_square</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#KUHF.spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square and multiplicity of UHF determinant</p>
<div class="math">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>There are two possibilities for <span class="math">\(S_+ S_-\)</span></dt>
<dd><ol class="first arabic simple">
<li>same electron <span class="math">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</li>
</ol>
<div class="math">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="last math">
\[\langle S_+ S_- \rangle = \langle ij|s_+ s_-|ij\rangle
                        - \langle ij|s_+ s_-|ji\rangle
                        = -\langle i^\alpha|j^\beta\rangle
                           \langle j^\beta|i^\alpha\rangle\]</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Similarly, for <span class="math">\(S_- S_+\)</span></dt>
<dd><ol class="first arabic simple">
<li>same electron</li>
</ol>
<div class="math">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li>different electrons</li>
</ol>
<div class="last math">
\[\langle S_- S_+ \rangle = -\langle i^\beta|j^\alpha\rangle
                           \langle j^\alpha|i^\beta\rangle\]</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>For <span class="math">\(S_z^2\)</span></dt>
<dd><ol class="first arabic simple">
<li>same electron</li>
</ol>
<div class="math">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li>different electrons</li>
</ol>
<div class="last math">
\[\begin{split}&amp;\frac{1}{2}\sum_{ij}(\langle ij|2s_{z1}s_{z2}|ij\rangle
                     -\langle ij|2s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}(n_\alpha^2 - n_\alpha n_\beta - n_\beta n_\alpha + n_\beta^2)
 -\frac{1}{4}(n_\alpha + n_\beta) \\
&amp;=\frac{1}{4}((n_\alpha-n_\beta)^2 - (n_\alpha+n_\beta))\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<p>In total</p>
<div class="math">
\[\begin{split}\langle S^2\rangle &amp;= \frac{1}{2}
(n_\alpha-\sum_{ij}\langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle
+n_\beta -\sum_{ij}\langle i^\beta|j^\alpha\rangle\langle j^\alpha|i^\beta\rangle)
+ \frac{1}{4}(n_\alpha-n_\beta)^2 \\\end{split}\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of 2 ndarrays</span><dd>Occupied alpha and occupied beta orbitals</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>s</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>AO overlap</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.canonicalize">
<code class="descclassname">pyscf.pbc.scf.kuhf.</code><code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff_kpts</em>, <em>mo_occ_kpts</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#canonicalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.dip_moment">
<code class="descclassname">pyscf.pbc.scf.kuhf.</code><code class="descname">dip_moment</code><span class="sig-paren">(</span><em>cell</em>, <em>dm_kpts</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>grids=None</em>, <em>rho=None</em>, <em>kpts=array([[ 0.</em>, <em>0.</em>, <em>0.]])</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">cell : an instance of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></p>
<p class="last">dm_kpts (two lists of ndarrays) : KUHF density matrices of k-points</p>
</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z components</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.energy_elec">
<code class="descclassname">pyscf.pbc.scf.kuhf.</code><code class="descname">energy_elec</code><span class="sig-paren">(</span><em>mf</em>, <em>dm_kpts=None</em>, <em>h1e_kpts=None</em>, <em>vhf_kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#energy_elec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.get_fermi">
<code class="descclassname">pyscf.pbc.scf.kuhf.</code><code class="descname">get_fermi</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_energy_kpts=None</em>, <em>mo_occ_kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#get_fermi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.get_fermi" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair of Fermi level for spin-up and spin-down orbitals</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.get_occ">
<code class="descclassname">pyscf.pbc.scf.kuhf.</code><code class="descname">get_occ</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_energy_kpts=None</em>, <em>mo_coeff_kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#get_occ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.init_guess_by_chkfile">
<code class="descclassname">pyscf.pbc.scf.kuhf.</code><code class="descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em>cell</em>, <em>chkfile_name</em>, <em>project=None</em>, <em>kpts=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the KHF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal"><span class="pre">cell</span></code></p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 3D ndarray</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.make_rdm1">
<code class="descclassname">pyscf.pbc.scf.kuhf.</code><code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>mo_coeff_kpts</em>, <em>mo_occ_kpts</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha and beta spin one particle density matrices for all k-points.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>dm_kpts : (2, nkpts, nao, nao) ndarray</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.pbc.scf.kuhf.mulliken_meta">
<code class="descclassname">pyscf.pbc.scf.kuhf.</code><code class="descname">mulliken_meta</code><span class="sig-paren">(</span><em>cell</em>, <em>dm_ao_kpts</em>, <em>verbose=5</em>, <em>pre_orth_method='ANO'</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/scf/kuhf.html#mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>A modified Mulliken population analysis, based on meta-Lowdin AOs.</p>
<p>Note this function only computes the Mulliken population for the gamma
point density matrix.</p>
</dd></dl>

</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dft.html" class="btn btn-neutral float-right" title="34.4. pbc.dft — PBC density functional theory" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ao2mo.html" class="btn btn-neutral" title="34.2. pbc.ao2mo — PBC integral transformation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.7.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>