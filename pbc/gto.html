

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>21.1. pbc.gto — Crystal cell structure &mdash; PySCF 1.7.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PySCF 1.7.0 documentation" href="../index.html"/>
        <link rel="up" title="21. pbc — Periodic boundary conditions" href="../pbc.html"/>
        <link rel="next" title="21.2. pbc.ao2mo — PBC integral transformation" href="ao2mo.html"/>
        <link rel="prev" title="21. pbc — Periodic boundary conditions" href="../pbc.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">2. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gto.html">4. gto &#8212; Molecular structure and GTO basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lib.html">5. <code class="docutils literal"><span class="pre">lib</span></code> &#8212; Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scf.html">6. scf &#8212; Mean-field methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ao2mo.html">7. ao2mo &#8212; Integral transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mcscf.html">8. mcscf &#8212; Multi-configurational self-consistent field</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fci.html">9. fci &#8212; Full configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symm.html">10. symm &#8211; Point group symmetry and spin symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="../df.html">11. df &#8212; Density fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dft.html">12. dft &#8212; Density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tddft.html">13. tddft &#8212; Time dependent density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cc.html">14. cc &#8212; Coupled cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ci.html">15. ci &#8212; Configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dmrgscf.html">16. dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fciqmcscf.html">17. fciqmcscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools.html">18. tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../grad.html">19. grad &#8212; Analytical nuclear gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hessian.html">20. hessian &#8212; Analytical nuclear Hessian</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../pbc.html">21. pbc &#8212; Periodic boundary conditions</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">21.1. pbc.gto &#8212; Crystal cell structure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cell-class">21.1.1. <code class="docutils literal"><span class="pre">Cell</span></code> class</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#attributes-and-methods">21.1.1.1. Attributes and methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#connection-to-mole-class">21.1.1.2. Connection to <code class="docutils literal"><span class="pre">Mole</span></code> class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#serialization">21.1.1.3. Serialization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#basis-set">21.1.2. Basis set</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pseudo-potential">21.1.3. Pseudo potential</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ao2mo.html">21.2. pbc.ao2mo &#8212; PBC integral transformation</a></li>
<li class="toctree-l2"><a class="reference internal" href="scf.html">21.3. pbc.scf &#8212; Mean-field with periodic boundary condition</a></li>
<li class="toctree-l2"><a class="reference internal" href="dft.html">21.4. pbc.dft  &#8212; PBC density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="df.html">21.5. pbc.df &#8212; PBC denisty fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="tdscf.html">21.6. pbc.tdscf &#8212; PBC time dependent density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="mp.html">21.7. pbc.mp &#8212; PBC perturbation theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="ci.html">21.8. pbc.ci &#8212; PBC configuration interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="cc.html">21.9. pbc.cc &#8212; PBC coupled cluster</a></li>
<li class="toctree-l2"><a class="reference internal" href="mpicc.html">21.10. pbc.mpicc &#8212; PBC coupled cluster for MPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">21.11. pbc.tools &#8212; PBC tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="mix_mol.html">21.12. Mixing PBC and molecular modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="prop.html">21.13. pbc.prop &#8212; PBC property</a></li>
<li class="toctree-l2"><a class="reference internal" href="gw.html">21.14. pbc.gw &#8212; GW with PBC</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../nao.html">22. nao &#8212; Numerical Atomic Orbitals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lo.html">23. lo &#8212; Orbital localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced.html">24. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../qmmm.html">25. qmmm &#8212; QM/MM interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mrpt.html">26. mrpt &#8212; Multi-reference perturbation theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmark.html">27. Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code-rule.html">28. Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../version.html">29. Version history</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gw.html">30. gw &#8212; Molecular G0W0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hci.html">31. hci &#8212; Interface to Heat-Bath selective CI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sgx.html">32. sgx &#8212; Pseudo-spectral methods (COSX, PS, SN-K)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../semiempirical.html">33. semiempirical &#8212; Semiempirical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mp.html">34. mp &#8212; MP2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../semiempirical.html">33. semiempirical &#8212; Semiempirical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../soscf.html">35. soscf &#8212; Second order Hartree-Fock solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../icmpspt.html">36. icmpspt &#8212; Internal-contracted MPS perturbation method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ccn.html">37. ccn &#8212; Auto-Generated Coupled-Cluster Equations of Arbitrary Order</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cornell_shci.html">38. cornell_shci &#8212; Interface to Fast Semistochastic Heat Bath Configuration Interaction (SHCI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dftd3.html">39. dftd3 &#8212; DFT plus Dispersion Correction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dmrgscf.html">16. dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doci.html">40. doci &#8212; Doubly occupied configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../geomopt.html">41. geomopt &#8212; Geometry optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../solvent.html">42. solvent &#8212; Solvent methods</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PySCF</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../pbc.html">21. pbc &#8212; Periodic boundary conditions</a> &raquo;</li>
        
      <li>21.1. pbc.gto &#8212; Crystal cell structure</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/pbc/gto.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pbc-gto-crystal-cell-structure">
<span id="pbc-gto"></span><h1>21.1. pbc.gto &#8212; Crystal cell structure<a class="headerlink" href="#pbc-gto-crystal-cell-structure" title="Permalink to this headline">¶</a></h1>
<p>This module provides functions to setup the basic information of a PBC calculation.  The
<code class="xref py py-mod docutils literal"><span class="pre">pyscf.pbc.gto</span></code> module is analogous to the basic molecular <code class="xref py py-mod docutils literal"><span class="pre">pyscf.gto</span></code> module.
The <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> class for crystal structure unit cells is defined in this module and is
analogous to the basic molecular <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> class.  Among other details, the basis set
and pseudopotentials are parsed in this module.</p>
<div class="section" id="cell-class">
<h2>21.1.1. <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> class<a class="headerlink" href="#cell-class" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#pyscf.pbc.gto.Cell" title="pyscf.pbc.gto.Cell"><code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></a> class is defined as an extension of the molecular
<a class="reference internal" href="../gto.html#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">pyscf.gto.mole.Mole</span></code></a> class.  The <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object offers much of the same
functionality as the <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> object.  For example, one can use the <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code>
object to access the atomic structure, basis functions, pseudopotentials, and certain
analytical periodic integrals.</p>
<p>Similar to the input in a molecular calculation, one first creates a <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object.
After assigning the crystal parameters, one calls <code class="xref py py-func docutils literal"><span class="pre">build()</span></code> to fully initialize the
<code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object.  A shortcut function <code class="xref py py-func docutils literal"><span class="pre">M()</span></code> is available at the module level to
simplify the input.</p>
<p>Beyond the basic parameters <code class="xref py py-attr docutils literal"><span class="pre">atom</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code>, one needs to set the unit cell
lattice vectors <code class="xref py py-attr docutils literal"><span class="pre">a</span></code> (a 3x3 array, where each row is a real-space primitive vector)
and the numbers of grid points in the FFT-mesh in each positive direction <code class="xref py py-attr docutils literal"><span class="pre">gs</span></code> (a
length-3 list or 1x3 array); the total number of grid points is 2 <code class="xref py py-attr docutils literal"><span class="pre">gs</span></code> +1.</p>
<p>In certain cases, it is convenient to choose the FFT-mesh density based on the kinetic
energy cutoff.  The <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> class offers an alternative attribute
<code class="xref py py-attr docutils literal"><span class="pre">ke_cutoff</span></code> that can be used to set the FFT-mesh.  If <code class="xref py py-attr docutils literal"><span class="pre">ke_cutoff</span></code> is set and
<code class="xref py py-attr docutils literal"><span class="pre">gs</span></code> is <code class="docutils literal"><span class="pre">None</span></code>, the <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> initialization function will convert the
<code class="xref py py-attr docutils literal"><span class="pre">ke_cutoff</span></code> to the equivalent FFT-mesh
according to the relation <span class="math">\(\mathbf{g} = \frac{\sqrt{2E_{\mathrm{cut}}}}{2\pi}\mathbf{a}^T\)</span>
and will overwrite the <code class="xref py py-attr docutils literal"><span class="pre">gs</span></code> attribute.</p>
<p>Many PBC calculations are best performed using pseudopotentials, which are set via
the <code class="xref py py-attr docutils literal"><span class="pre">pseudo</span></code> attribute.  Pseudopotentials alleviate the need for impractically
dense FFT-meshes, although they represent a potentially uncontrolled source of error.
See <a class="reference internal" href="#pseudo"><span class="std std-ref">Pseudo potential</span></a> for further details and a list of available pseudopotentials.</p>
<p>The input parameters <code class="docutils literal"><span class="pre">.a</span></code> and <code class="docutils literal"><span class="pre">.pseudo</span></code> are immutable in the <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object.  We
emphasize that the input format might be different from the internal format used by PySCF.
Similar to the convention in <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code>, an internal Python data layer is created to
hold the formatted <code class="docutils literal"><span class="pre">.a</span></code> and <code class="docutils literal"><span class="pre">.pseudo</span></code> parameters used as input.</p>
<dl class="docutils">
<dt>_pseudo</dt>
<dd>The internal format to hold PBC pseudo potential parameters.  It is
represented with nested Python lists only.</dd>
</dl>
<p>Nuclear-nuclear interaction energies are evaluated by means of Ewald summation, which
depends on three parameters: the truncation radius for real-space lattice sums
<code class="xref py py-attr docutils literal"><span class="pre">rcut</span></code>, the Gaussian model charge <code class="xref py py-attr docutils literal"><span class="pre">ew_eta</span></code>, and the energy cutoff
<code class="xref py py-attr docutils literal"><span class="pre">ew_cut</span></code>.  Although they can be set manually, these parameters are by default chosen
automatically according to the attribute <code class="xref py py-attr docutils literal"><span class="pre">precision</span></code>, which likewise can be set
manually or left to its default value.</p>
<p>Besides the methods and parameters provided by <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> class (see Chapter
<a class="reference internal" href="../gto.html#gto"><span class="std std-ref">gto &#8212; Molecular structure and GTO basis</span></a>), there are some parameters frequently used in the code to access the
information of the crystal.</p>
<dl class="docutils">
<dt>kpts</dt>
<dd><p class="first">The scaled or absolute k-points (nkpts x 3 array). This variable is not held as an
attribute in <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object; instead, the <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object provides functions
to generate the k-points and convert the k-points between the scaled (fractional) value
and absolute value:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Generate k-points</span>
<span class="n">n_kpts_each_direction</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">abs_kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">(</span><span class="n">n_kpts_each_direction</span><span class="p">)</span>

<span class="c1"># Convert k-points between two convention, the scaled and the absoulte values</span>
<span class="n">scaled_kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_scaled_kpts</span><span class="p">(</span><span class="n">abs_kpts</span><span class="p">)</span>
<span class="n">abs_kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_abs_kpts</span><span class="p">(</span><span class="n">scaled_kpts</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>Gv</dt>
<dd>The (N x 3) array of plane waves associated to <code class="xref py py-attr docutils literal"><span class="pre">gs</span></code>.  <code class="xref py py-attr docutils literal"><span class="pre">gs</span></code> defines
the number of FFT grids in each direction.  <code class="xref py py-meth docutils literal"><span class="pre">Cell.Gv()</span></code> or <code class="xref py py-meth docutils literal"><span class="pre">get_Gv()</span></code>
convert the FFT-mesh to the plane waves.  <code class="docutils literal"><span class="pre">Gv</span></code> are the the plane wave bases
of 3D-FFT transformation.  Given <code class="docutils literal"><span class="pre">gs</span> <span class="pre">=</span> <span class="pre">[nx,ny,nz]</span></code>, the number of vectors in
<code class="docutils literal"><span class="pre">Gv</span></code> is <code class="docutils literal"><span class="pre">(2*nx+1)*(2*ny+1)*(2*nz+1)</span></code>.</dd>
<dt>vol</dt>
<dd><code class="xref py py-attr docutils literal"><span class="pre">Cell.vol</span></code> gives the volume of the unit cell (in atomic unit).</dd>
<dt>reciprocal_vectors</dt>
<dd>A 3x3 array.  Each row is a reciprocal space primitive vector.</dd>
<dt>energy_nuc</dt>
<dd>Similar to the <code class="xref py py-func docutils literal"><span class="pre">energy_nuc()</span></code> provided by <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> class, this
function also return the energy associated to the nuclear repulsion.  The
nuclear repulsion energy is computed with Ewald summation technique.  The
background contribution is removed from the nuclear repulsion energy otherwise
this term is divergent.</dd>
<dt>pbc_intor</dt>
<dd>PBC analytic integral driver.  It allows user to compute the PBC integral
array in bulk, for given integral descriptor <code class="docutils literal"><span class="pre">intor</span></code> (see also
<code class="xref py py-meth docutils literal"><span class="pre">Mole.intor()</span></code> function <a class="reference internal" href="../gto.html#gto-moleintor"><span class="std std-ref">moleintor</span></a>).  In the <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object,
we didn&#8217;t overload the <code class="xref py py-meth docutils literal"><span class="pre">intor()</span></code> method.  So one can access both the
periodic integrals and free-boundary integrals within the <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code>
object.  It allows you to input the cell object into the molecule program to
run the free-boundary calculation (see <a class="reference internal" href="#cell-to-mol"><span class="std std-ref">Connection to Mole class</span></a>).</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">pbc_intor()</span></code> does not support Coulomb type integrals.  Calling pbc_intor
with Coulomb type integral descriptor such as <code class="docutils literal"><span class="pre">cint1e_nuc_sph</span></code> leads to
divergent integrals.  The Coulomb type PBC integrals should be evaluated with
density fitting technique (see Chapter <a class="reference internal" href="df.html#pbc-df"><span class="std std-ref">pbc.df &#8212; PBC denisty fitting</span></a>).</p>
</div>
<div class="section" id="attributes-and-methods">
<h3>21.1.1.1. Attributes and methods<a class="headerlink" href="#attributes-and-methods" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyscf.pbc.gto.Cell">
<em class="property">class </em><code class="descclassname">pyscf.pbc.gto.</code><code class="descname">Cell</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell" title="Permalink to this definition">¶</a></dt>
<dd><p>A Cell object holds the basic information of a crystal.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first docutils">
<dt>a</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,3) ndarray</span><dd>Lattice primitive vectors. Each row represents a lattice vector
Reciprocal lattice vectors are given by  b1,b2,b3 = 2 pi inv(a).T</dd>
<dt>mesh</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,) list of ints</span><dd>The number G-vectors along each direction.
The default value is estimated based on <code class="xref py py-attr docutils literal"><span class="pre">precision</span></code></dd>
<dt>pseudo</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>To define pseudopotential.</dd>
<dt>precision</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>To control Ewald sums and lattice sums accuracy</dd>
<dt>rcut</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Cutoff radius (unit Bohr) in lattice summation. The default value
is estimated based on the required <code class="xref py py-attr docutils literal"><span class="pre">precision</span></code>.</dd>
<dt>ke_cutoff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>If set, defines a spherical cutoff of planewaves, with .5 * G**2 &lt; ke_cutoff
The default value is estimated based on <code class="xref py py-attr docutils literal"><span class="pre">precision</span></code></dd>
<dt>dimension</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Default is 3</dd>
</dl>
<p>** Following attributes (for experts) are automatically generated. **</p>
<dl class="last docutils">
<dt>ew_eta, ew_cut</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>The Ewald &#8216;eta&#8217; and &#8216;cut&#8217; parameters.  See <code class="xref py py-func docutils literal"><span class="pre">get_ewald_params()</span></code></dd>
</dl>
</dd>
</dl>
<p>(See other attributes in <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code>)</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">Mole</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cl</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cl</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s1">&#39;3 0 0; 0 3 0; 0 0 3&#39;</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;C 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">C</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.pbc.gto.Cell.bas_rcut">
<code class="descname">bas_rcut</code><span class="sig-paren">(</span><em>cell</em>, <em>bas_id</em>, <em>precision=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.bas_rcut" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the largest distance between the function and its image to
reach the precision in overlap</p>
<p>precision ~ int g(r-0) g(r-R)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.build">
<code class="descname">build</code><span class="sig-paren">(</span><em>dump_input=True</em>, <em>parse_arg=True</em>, <em>a=None</em>, <em>mesh=None</em>, <em>ke_cutoff=None</em>, <em>precision=None</em>, <em>nimgs=None</em>, <em>ew_eta=None</em>, <em>ew_cut=None</em>, <em>pseudo=None</em>, <em>basis=None</em>, <em>h=None</em>, <em>dimension=None</em>, <em>rcut=None</em>, <em>ecp=None</em>, <em>low_dim_ft_type=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.build"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup Mole molecule and Cell and initialize some control parameters.
Whenever you change the value of the attributes of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code>,
you need call this function to refresh the internal data of Cell.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>a</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,3) ndarray</span><dd>The real-space unit cell lattice vectors. Each row represents
a lattice vector.</dd>
<dt>mesh</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,) ndarray of ints</span><dd>The number of <em>positive</em> G-vectors along each direction.</dd>
<dt>pseudo</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>To define pseudopotential.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Cell.pseudo</span></code></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.dumps">
<code class="descname">dumps</code><span class="sig-paren">(</span><em>cell</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Cell object to a JSON formatted str.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.energy_nuc">
<code class="descname">energy_nuc</code><span class="sig-paren">(</span><em>cell</em>, <em>ew_eta=None</em>, <em>ew_cut=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.energy_nuc" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>The Ewald energy consisting of overlap, self, and G-space sum.</dd>
</dl>
</dd>
<dt>See Also:</dt>
<dd>pyscf.pbc.gto.get_ewald_params</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.eval_ao">
<code class="descname">eval_ao</code><span class="sig-paren">(</span><em>eval_name</em>, <em>coords</em>, <em>comp=None</em>, <em>kpts=None</em>, <em>kpt=None</em>, <em>shls_slice=None</em>, <em>non0tab=None</em>, <em>ao_loc=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.eval_ao" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">eval_name : str</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Expression</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8220;GTOval_sph&#8221;</td>
<td>sum_T exp(ik*T) <a href="#id1"><span class="problematic" id="id2">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_sph&#8221;</td>
<td>nabla sum_T exp(ik*T) <a href="#id3"><span class="problematic" id="id4">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_cart&#8221;</td>
<td>sum_T exp(ik*T) <a href="#id5"><span class="problematic" id="id6">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_cart&#8221;</td>
<td>nabla sum_T exp(ik*T) <a href="#id7"><span class="problematic" id="id8">|</span></a>AO&gt;</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="last docutils">
<dt>atm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>bas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>env</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float64 ndarray</span><dd>libcint integral function argument</dd>
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>The coordinates of the grids.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>shls_slice</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2-element list</span><dd>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</dd>
<dt>non0tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D bool array</span><dd>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">dft.gen_grid.make_mask()</span></code></dd>
<dt>out</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If provided, results are written into this array.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 100, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.eval_gto">
<code class="descname">eval_gto</code><span class="sig-paren">(</span><em>eval_name</em>, <em>coords</em>, <em>comp=None</em>, <em>kpts=None</em>, <em>kpt=None</em>, <em>shls_slice=None</em>, <em>non0tab=None</em>, <em>ao_loc=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.eval_gto"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.eval_gto" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">eval_name : str</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Expression</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8220;GTOval_sph&#8221;</td>
<td>sum_T exp(ik*T) <a href="#id9"><span class="problematic" id="id10">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_sph&#8221;</td>
<td>nabla sum_T exp(ik*T) <a href="#id11"><span class="problematic" id="id12">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_cart&#8221;</td>
<td>sum_T exp(ik*T) <a href="#id13"><span class="problematic" id="id14">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_cart&#8221;</td>
<td>nabla sum_T exp(ik*T) <a href="#id15"><span class="problematic" id="id16">|</span></a>AO&gt;</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="last docutils">
<dt>atm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>bas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>env</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float64 ndarray</span><dd>libcint integral function argument</dd>
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>The coordinates of the grids.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>shls_slice</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2-element list</span><dd>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</dd>
<dt>non0tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D bool array</span><dd>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">dft.gen_grid.make_mask()</span></code></dd>
<dt>out</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If provided, results are written into this array.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 100, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.ewald">
<code class="descname">ewald</code><span class="sig-paren">(</span><em>cell</em>, <em>ew_eta=None</em>, <em>ew_cut=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.ewald" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>The Ewald energy consisting of overlap, self, and G-space sum.</dd>
</dl>
</dd>
<dt>See Also:</dt>
<dd>pyscf.pbc.gto.get_ewald_params</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.format_basis">
<code class="descname">format_basis</code><span class="sig-paren">(</span><em>basis_tab</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.format_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.format_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal"><span class="pre">Cell.basis</span></code> to the internal data format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="p">((</span><span class="o">-</span><span class="n">exp</span><span class="p">,</span> <span class="n">c_1</span><span class="p">,</span> <span class="n">c_2</span><span class="p">,</span> <span class="o">..</span><span class="p">),</span> <span class="n">nprim</span><span class="p">,</span> <span class="n">nctr</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-</span><span class="n">exps</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-</span><span class="n">contraction</span><span class="o">-</span><span class="n">coeff</span><span class="p">)),</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>basis_tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>Similar to <code class="xref py py-attr docutils literal"><span class="pre">Cell.basis</span></code>, it <strong>cannot</strong> be a str</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pbc</span><span class="o">.</span><span class="n">format_basis</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;gth-szv&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[0,</span>
<span class="go">    (8.3744350009, -0.0283380461),</span>
<span class="go">    (1.8058681460, -0.1333810052),</span>
<span class="go">    (0.4852528328, -0.3995676063),</span>
<span class="go">    (0.1658236932, -0.5531027541)]]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.format_pseudo">
<code class="descname">format_pseudo</code><span class="sig-paren">(</span><em>pseudo_tab</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.format_pseudo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.format_pseudo" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal"><span class="pre">Cell.pseudo</span></code> (dict) to the internal data format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span> <span class="p">(</span><span class="n">nelec_s</span><span class="p">,</span> <span class="n">nele_p</span><span class="p">,</span> <span class="n">nelec_d</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>
         <span class="n">rloc</span><span class="p">,</span> <span class="n">nexp</span><span class="p">,</span> <span class="p">(</span><span class="n">cexp_1</span><span class="p">,</span> <span class="n">cexp_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">cexp_nexp</span><span class="p">),</span>
         <span class="n">nproj_types</span><span class="p">,</span>
         <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">nproj1</span><span class="p">,</span> <span class="p">(</span> <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
                        <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
                        <span class="o">...</span>
                        <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="n">nproj1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="n">nproj1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span>        <span class="p">)</span> <span class="p">)),</span>
         <span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">nproj2</span><span class="p">,</span> <span class="p">(</span> <span class="p">(</span><span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
         <span class="o">...</span> <span class="p">)</span> <span class="p">)</span>
         <span class="p">)</span>
 <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>pseudo_tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>Similar to <code class="xref py py-attr docutils literal"><span class="pre">Cell.pseudo</span></code> (a dict), it <strong>cannot</strong> be a str</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Formatted <code class="xref py py-attr docutils literal"><span class="pre">pseudo</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pbc</span><span class="o">.</span><span class="n">format_pseudo</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;gth-blyp&#39;</span><span class="p">,</span> <span class="s1">&#39;He&#39;</span><span class="p">:</span> <span class="s1">&#39;gth-pade&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[1],</span>
<span class="go">    0.2, 2, [-4.19596147, 0.73049821], 0],</span>
<span class="go"> &#39;He&#39;: [[2],</span>
<span class="go">    0.2, 2, [-9.1120234, 1.69836797], 0]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.from_ase">
<code class="descname">from_ase</code><span class="sig-paren">(</span><em>ase_atom</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.from_ase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.from_ase" title="Permalink to this definition">¶</a></dt>
<dd><p>Update cell based on given ase atom object</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ase.lattice</span> <span class="k">import</span> <span class="n">bulk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">from_ase</span><span class="p">(</span><span class="n">bulk</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;diamond&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">LATTICE_CONST</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.gen_uniform_grids">
<code class="descname">gen_uniform_grids</code><span class="sig-paren">(</span><em>cell</em>, <em>mesh=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.gen_uniform_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a uniform real-space grid consistent w/ samp thm; see MH (3.19).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>cell : instance of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(ngx*ngy*ngz, 3) ndarray</span><dd>The real-space grid point coordinates.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.get_Gv">
<code class="descname">get_Gv</code><span class="sig-paren">(</span><em>cell</em>, <em>mesh=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.get_Gv" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate three-dimensional G-vectors for the cell; see MH (3.8).</p>
<p>Indices along each direction go as [0...N-1, -N...-1] to follow FFT convention.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>cell : instance of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Gv</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(ngrids, 3) ndarray of floats</span><dd>The array of G-vectors.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.get_Gv_weights">
<code class="descname">get_Gv_weights</code><span class="sig-paren">(</span><em>cell</em>, <em>mesh=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.get_Gv_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate G-vectors and weights.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Gv</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(ngris, 3) ndarray of floats</span><dd>The array of G-vectors.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.get_SI">
<code class="descname">get_SI</code><span class="sig-paren">(</span><em>cell</em>, <em>Gv=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.get_SI" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the structure factor (0D, 1D, 2D, 3D) for all atoms; see MH (3.34).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">cell : instance of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></p>
<dl class="last docutils">
<dt>Gv</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(N,3) array</span><dd>G vectors</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>SI</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(natm, ngrids) ndarray, dtype=np.complex128</span><dd>The structure factor for each atom at each G-vector.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.get_abs_kpts">
<code class="descname">get_abs_kpts</code><span class="sig-paren">(</span><em>scaled_kpts</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.get_abs_kpts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.get_abs_kpts" title="Permalink to this definition">¶</a></dt>
<dd><p>Get absolute k-points (in 1/Bohr), given &#8220;scaled&#8221; k-points in
fractions of lattice vectors.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>scaled_kpts : (nkpts, 3) ndarray of floats</dd>
<dt>Returns:</dt>
<dd>abs_kpts : (nkpts, 3) ndarray of floats</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.get_bounding_sphere">
<code class="descname">get_bounding_sphere</code><span class="sig-paren">(</span><em>cell</em>, <em>rcut</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.get_bounding_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all the lattice points within a sphere of radius rcut.</p>
<p>Defines a parallelipiped given by -N_x &lt;= n_x &lt;= N_x, with x in [1,3]
See Martin p. 85</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>rcut</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">number</span><dd>real space cut-off for interaction</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>cut : ndarray of 3 ints defining N_x</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.get_ewald_params">
<code class="descname">get_ewald_params</code><span class="sig-paren">(</span><em>cell</em>, <em>precision=1e-08</em>, <em>mesh=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.get_ewald_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose a reasonable value of Ewald &#8216;eta&#8217; and &#8216;cut&#8217; parameters.
eta^2 is the exponent coefficient of the model Gaussian charge for nucleus
at R:  frac{eta^3}{pi^1.5} e^{-eta^2 (r-R)^2}</p>
<p>Choice is based on largest G vector and desired relative precision.</p>
<p>The relative error in the G-space sum is given by</p>
<blockquote>
<div>precision ~ 4pi Gmax^2 e^{(-Gmax^2)/(4 eta^2)}</div></blockquote>
<p>which determines eta. Then, real-space cutoff is determined by (exp.
factors only)</p>
<blockquote>
<div>precision ~ erfc(eta*rcut) / rcut ~ e^{(-eta**2 rcut*2)}</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>ew_eta, ew_cut</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>The Ewald &#8216;eta&#8217; and &#8216;cut&#8217; parameters.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.get_kpts">
<code class="descname">get_kpts</code><span class="sig-paren">(</span><em>cell</em>, <em>nks</em>, <em>wrap_around=False</em>, <em>with_gamma_point=True</em>, <em>scaled_center=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.get_kpts" title="Permalink to this definition">¶</a></dt>
<dd><p>Given number of kpoints along x,y,z , generate kpoints</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>nks : (3,) ndarray</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>wrap_around</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>To ensure all kpts are in first Brillouin zone.</dd>
<dt>with_gamma_point</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to shift Monkhorst-pack grid to include gamma-point.</dd>
<dt>scaled_center</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,) array</span><dd>Shift all points in the Monkhorst-pack grid to be centered on
scaled_center, given as the zeroth index of the returned kpts.
Scaled meaning that the k-points are scaled to a grid from 
[-1,1] x [-1,1] x [-1,1]</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>kpts in absolute value (unit 1/Bohr).  Gamma point is placed at the
first place in the k-points list</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.get_lattice_Ls">
<code class="descname">get_lattice_Ls</code><span class="sig-paren">(</span><em>cell</em>, <em>nimgs=None</em>, <em>rcut=None</em>, <em>dimension=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.get_lattice_Ls" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the (Cartesian, unitful) lattice translation vectors for nearby images.
The translation vectors can be used for the lattice summation.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.get_nimgs">
<code class="descname">get_nimgs</code><span class="sig-paren">(</span><em>cell</em>, <em>precision=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.get_nimgs" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose number of basis function images in lattice sums
to include for given precision in overlap, using</p>
<p>precision ~ int r^l e^{-alpha r^2} (r-rcut)^l e^{-alpha (r-rcut)^2}
~ (rcut^2/(2alpha))^l e^{alpha/2 rcut^2}</p>
<p>where alpha is the smallest exponent in the basis. Note
that assumes an isolated exponent in the middle of the box, so
it adds one additional lattice vector to be safe.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.get_scaled_kpts">
<code class="descname">get_scaled_kpts</code><span class="sig-paren">(</span><em>abs_kpts</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.get_scaled_kpts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.get_scaled_kpts" title="Permalink to this definition">¶</a></dt>
<dd><p>Get scaled k-points, given absolute k-points in 1/Bohr.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>abs_kpts : (nkpts, 3) ndarray of floats</dd>
<dt>Returns:</dt>
<dd>scaled_kpts : (nkpts, 3) ndarray of floats</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.get_uniform_grids">
<code class="descname">get_uniform_grids</code><span class="sig-paren">(</span><em>cell</em>, <em>mesh=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.get_uniform_grids" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a uniform real-space grid consistent w/ samp thm; see MH (3.19).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>cell : instance of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(ngx*ngy*ngz, 3) ndarray</span><dd>The real-space grid point coordinates.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.has_ecp">
<code class="descname">has_ecp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.has_ecp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.has_ecp" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether pseudo potential is used in the system.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.kernel">
<code class="descname">kernel</code><span class="sig-paren">(</span><em>dump_input=True</em>, <em>parse_arg=True</em>, <em>a=None</em>, <em>mesh=None</em>, <em>ke_cutoff=None</em>, <em>precision=None</em>, <em>nimgs=None</em>, <em>ew_eta=None</em>, <em>ew_cut=None</em>, <em>pseudo=None</em>, <em>basis=None</em>, <em>h=None</em>, <em>dimension=None</em>, <em>rcut=None</em>, <em>ecp=None</em>, <em>low_dim_ft_type=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup Mole molecule and Cell and initialize some control parameters.
Whenever you change the value of the attributes of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code>,
you need call this function to refresh the internal data of Cell.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>a</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,3) ndarray</span><dd>The real-space unit cell lattice vectors. Each row represents
a lattice vector.</dd>
<dt>mesh</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,) ndarray of ints</span><dd>The number of <em>positive</em> G-vectors along each direction.</dd>
<dt>pseudo</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>To define pseudopotential.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Cell.pseudo</span></code></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.lattice_vectors">
<code class="descname">lattice_vectors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.lattice_vectors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.lattice_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the primitive lattice vectors.</p>
<p>Return 3x3 array in which each row represents one direction of the
lattice vectors (unit in Bohr)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>molstr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.loads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialize a str containing a JSON document to a Cell object.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.make_kpts">
<code class="descname">make_kpts</code><span class="sig-paren">(</span><em>cell</em>, <em>nks</em>, <em>wrap_around=False</em>, <em>with_gamma_point=True</em>, <em>scaled_center=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.make_kpts" title="Permalink to this definition">¶</a></dt>
<dd><p>Given number of kpoints along x,y,z , generate kpoints</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>nks : (3,) ndarray</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>wrap_around</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>To ensure all kpts are in first Brillouin zone.</dd>
<dt>with_gamma_point</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to shift Monkhorst-pack grid to include gamma-point.</dd>
<dt>scaled_center</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(3,) array</span><dd>Shift all points in the Monkhorst-pack grid to be centered on
scaled_center, given as the zeroth index of the returned kpts.
Scaled meaning that the k-points are scaled to a grid from 
[-1,1] x [-1,1] x [-1,1]</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>kpts in absolute value (unit 1/Bohr).  Gamma point is placed at the
first place in the k-points list</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.pack">
<code class="descname">pack</code><span class="sig-paren">(</span><em>cell</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.pack" title="Permalink to this definition">¶</a></dt>
<dd><p>Pack the input args of <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> to a dict, which can be serialized
with <code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.pbc_eval_ao">
<code class="descname">pbc_eval_ao</code><span class="sig-paren">(</span><em>eval_name</em>, <em>coords</em>, <em>comp=None</em>, <em>kpts=None</em>, <em>kpt=None</em>, <em>shls_slice=None</em>, <em>non0tab=None</em>, <em>ao_loc=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.pbc_eval_ao" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">eval_name : str</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Expression</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8220;GTOval_sph&#8221;</td>
<td>sum_T exp(ik*T) <a href="#id17"><span class="problematic" id="id18">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_sph&#8221;</td>
<td>nabla sum_T exp(ik*T) <a href="#id19"><span class="problematic" id="id20">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_cart&#8221;</td>
<td>sum_T exp(ik*T) <a href="#id21"><span class="problematic" id="id22">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_cart&#8221;</td>
<td>nabla sum_T exp(ik*T) <a href="#id23"><span class="problematic" id="id24">|</span></a>AO&gt;</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="last docutils">
<dt>atm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>bas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>env</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float64 ndarray</span><dd>libcint integral function argument</dd>
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>The coordinates of the grids.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>shls_slice</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2-element list</span><dd>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</dd>
<dt>non0tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D bool array</span><dd>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">dft.gen_grid.make_mask()</span></code></dd>
<dt>out</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If provided, results are written into this array.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 100, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.pbc_eval_gto">
<code class="descname">pbc_eval_gto</code><span class="sig-paren">(</span><em>eval_name</em>, <em>coords</em>, <em>comp=None</em>, <em>kpts=None</em>, <em>kpt=None</em>, <em>shls_slice=None</em>, <em>non0tab=None</em>, <em>ao_loc=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.pbc_eval_gto"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.pbc_eval_gto" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">eval_name : str</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Expression</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8220;GTOval_sph&#8221;</td>
<td>sum_T exp(ik*T) <a href="#id25"><span class="problematic" id="id26">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_sph&#8221;</td>
<td>nabla sum_T exp(ik*T) <a href="#id27"><span class="problematic" id="id28">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_cart&#8221;</td>
<td>sum_T exp(ik*T) <a href="#id29"><span class="problematic" id="id30">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_cart&#8221;</td>
<td>nabla sum_T exp(ik*T) <a href="#id31"><span class="problematic" id="id32">|</span></a>AO&gt;</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="last docutils">
<dt>atm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>bas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>env</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float64 ndarray</span><dd>libcint integral function argument</dd>
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>The coordinates of the grids.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>shls_slice</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2-element list</span><dd>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</dd>
<dt>non0tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D bool array</span><dd>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">dft.gen_grid.make_mask()</span></code></dd>
<dt>out</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If provided, results are written into this array.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 100, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.pbc_intor">
<code class="descname">pbc_intor</code><span class="sig-paren">(</span><em>intor</em>, <em>comp=None</em>, <em>hermi=0</em>, <em>kpts=None</em>, <em>kpt=None</em>, <em>shls_slice=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.pbc_intor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.pbc_intor" title="Permalink to this definition">¶</a></dt>
<dd><p>One-electron integrals with PBC.</p>
<div class="math">
\[\sum_T \int \mu(r) * [intor] * \nu (r-T) dr\]</div>
<p>See also Mole.intor</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.reciprocal_vectors">
<code class="descname">reciprocal_vectors</code><span class="sig-paren">(</span><em>norm_to=6.283185307179586</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.reciprocal_vectors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.reciprocal_vectors" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[\begin{split}\begin{align}
\mathbf{b_1} &amp;= 2\pi \frac{\mathbf{a_2} \times \mathbf{a_3}}{\mathbf{a_1} \cdot (\mathbf{a_2} \times \mathbf{a_3})} \\
\mathbf{b_2} &amp;= 2\pi \frac{\mathbf{a_3} \times \mathbf{a_1}}{\mathbf{a_2} \cdot (\mathbf{a_3} \times \mathbf{a_1})} \\
\mathbf{b_3} &amp;= 2\pi \frac{\mathbf{a_1} \times \mathbf{a_2}}{\mathbf{a_3} \cdot (\mathbf{a_1} \times \mathbf{a_2})}
\end{align}\end{split}\]</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.to_mol">
<code class="descname">to_mol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.to_mol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.to_mol" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Mole object using the same atoms and basis functions as
the Cell object.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.tot_electrons">
<code class="descname">tot_electrons</code><span class="sig-paren">(</span><em>cell</em>, <em>nkpts=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.gto.Cell.tot_electrons" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of electrons</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.pbc.gto.Cell.unpack">
<code class="descname">unpack</code><span class="sig-paren">(</span><em>moldic</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/pbc/gto/cell.html#Cell.unpack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.gto.Cell.unpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="connection-to-mole-class">
<span id="cell-to-mol"></span><h3>21.1.1.2. Connection to <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> class<a class="headerlink" href="#connection-to-mole-class" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#pyscf.pbc.gto.Cell" title="pyscf.pbc.gto.Cell"><code class="xref py py-class docutils literal"><span class="pre">Cell</span></code></a> class is compatible with the molecule
<a class="reference internal" href="../gto.html#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">pyscf.gto.mole.Mole</span></code></a> class.  They shared most data structure and
methods.  It gives the freedom to mix the finite size calculation and the PBC
calculation.  If you feed the cell object to molecule module/functions, the
molecule program will not check whether the given <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> object is the
true <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> or not.  It simply treats the <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object as the
<code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> object and run the finite size calculations.  Because the same
module names were used in PBC program and molecule program, you should be
careful with the imported modules since no error message will be raised if you
by mistake input the <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object into the molecule program.</p>
<p>Although we reserve the flexibility to mix the <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> and <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code>
objects in the same code, it should be noted that the serialization methods of
the two objects are not completely compatible.  When you dumps/loads the cell
object in the molecule program, informations of the <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> object or the
faked <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> object may be lost.</p>
</div>
<div class="section" id="serialization">
<h3>21.1.1.3. Serialization<a class="headerlink" href="#serialization" title="Permalink to this headline">¶</a></h3>
<p><code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> class has two set of functions to serialize Cell object in
different formats.</p>
<ul class="simple">
<li>JSON format is the default serialization format used by <code class="xref py py-mod docutils literal"><span class="pre">pyscf.lib.chkfile</span></code>
module.  It can be serialized by <code class="xref py py-func docutils literal"><span class="pre">Cell.dumps()</span></code> function and deserialized
by <code class="xref py py-func docutils literal"><span class="pre">Cell.loads()</span></code> function.</li>
<li>In the old version, <code class="xref py py-func docutils literal"><span class="pre">Mole.pack()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">Mole.unpack()</span></code> functions are
used to convert the <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> object to and from Python dict.  The Python
dict is then serialized by pickle module.  This serialization method is not
used anymore in the new PySCF code.  To keep the backward compatibility, the
two methods are defined in <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> class.</li>
</ul>
</div>
</div>
<div class="section" id="basis-set">
<h2>21.1.2. Basis set<a class="headerlink" href="#basis-set" title="Permalink to this headline">¶</a></h2>
<p>The pbc module supports all-electron calculation.  The all-electron basis sets
developed by quantum chemistry community can be directly used in the pbc
calculation.  The <code class="xref py py-class docutils literal"><span class="pre">Cell</span></code> class supports to mix the QC all-electron basis
and PBC basis in the same calculation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The default PBC Coulomb type integrals are computed using FFT transformation.
If the all-electron basis are used, you might need very high energy cutoff to
converge the integrals.  It is recommended to use mixed density fitting
technique (<a class="reference internal" href="df.html#pbc-df"><span class="std std-ref">pbc.df &#8212; PBC denisty fitting</span></a>) to handle the all-electron calculations.</p>
</div>
</div>
<div class="section" id="pseudo-potential">
<span id="pseudo"></span><h2>21.1.3. Pseudo potential<a class="headerlink" href="#pseudo-potential" title="Permalink to this headline">¶</a></h2>
<p>Quantum chemistry community developed a wide range of pseudo potentials (which
are called ECP, effective core potential) for heavy elements.  ECP works quite
successful in finite system.  It has high flexibility to choose different core
size and relevant basis sets to satisfy different requirements on accuracy,
efficiency in different simulation scenario.  Extending ECP to PBC code enriches
the pseudo potential database.  PySCF PBC program supports both the PBC
conventional pseudo potential and ECP and the mix of the two kinds of potentials
in the same calculation.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ao2mo.html" class="btn btn-neutral float-right" title="21.2. pbc.ao2mo — PBC integral transformation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../pbc.html" class="btn btn-neutral" title="21. pbc — Periodic boundary conditions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.7.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>