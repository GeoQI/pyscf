

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6. scf — Mean-field methods &mdash; PySCF 1.7.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PySCF 1.7.0 documentation" href="index.html"/>
        <link rel="next" title="7. ao2mo — Integral transformations" href="ao2mo.html"/>
        <link rel="prev" title="5. lib — Helper functions, parameters, and C extensions" href="lib.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">2. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="gto.html">4. gto &#8212; Molecular structure and GTO basis</a></li>
<li class="toctree-l1"><a class="reference internal" href="lib.html">5. <code class="docutils literal"><span class="pre">lib</span></code> &#8212; Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. scf &#8212; Mean-field methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#stability-analysis">6.1. Stability analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="#addons">6.2. Addons</a></li>
<li class="toctree-l2"><a class="reference internal" href="#caching-two-electron-integrals">6.3. Caching two-electron integrals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#customizing-hamiltonian">6.4. Customizing Hamiltonian</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pyscf.scf">6.5. Program reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#hartree-fock">6.5.1. Hartree-Fock</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-relativistic-hartree-fock">6.5.2. Non-relativistic Hartree-Fock</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyscf.scf.dhf">6.5.3. Relativistic Hartree-Fock</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">6.5.4. addons</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ao2mo.html">7. ao2mo &#8212; Integral transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="mcscf.html">8. mcscf &#8212; Multi-configurational self-consistent field</a></li>
<li class="toctree-l1"><a class="reference internal" href="fci.html">9. fci &#8212; Full configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="symm.html">10. symm &#8211; Point group symmetry and spin symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="df.html">11. df &#8212; Density fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="dft.html">12. dft &#8212; Density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="tddft.html">13. tddft &#8212; Time dependent density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="cc.html">14. cc &#8212; Coupled cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">15. ci &#8212; Configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dmrgscf.html">16. dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="fciqmcscf.html">17. fciqmcscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">18. tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="grad.html">19. grad &#8212; Analytical nuclear gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="hessian.html">20. hessian &#8212; Analytical nuclear Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="pbc.html">21. pbc &#8212; Periodic boundary conditions</a></li>
<li class="toctree-l1"><a class="reference internal" href="nao.html">22. nao &#8212; Numerical Atomic Orbitals</a></li>
<li class="toctree-l1"><a class="reference internal" href="lo.html">23. lo &#8212; Orbital localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">24. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="qmmm.html">25. qmmm &#8212; QM/MM interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrpt.html">26. mrpt &#8212; Multi-reference perturbation theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmark.html">27. Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="code-rule.html">28. Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">29. Version history</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PySCF</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>6. scf &#8212; Mean-field methods</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/scf.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-scf">
<span id="scf-mean-field-methods"></span><h1>6. scf &#8212; Mean-field methods<a class="headerlink" href="#module-scf" title="Permalink to this headline">¶</a></h1>
<div class="section" id="stability-analysis">
<h2>6.1. Stability analysis<a class="headerlink" href="#stability-analysis" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="addons">
<h2>6.2. Addons<a class="headerlink" href="#addons" title="Permalink to this headline">¶</a></h2>
<p>Special treatments may be required to the SCF methods in some situations.  These
special treatments cannot be universally applied for all SCF models.  They were
defined in the <code class="xref py py-mod docutils literal"><span class="pre">scf.addons</span></code> module. For example, in an UHF calculation, we
may want the <span class="math">\(S_z\)</span> value to be changed (the numbers of alpha and beta
electrons not conserved) during SCF iteration while conserving the total number
of electrons.  <code class="xref py py-func docutils literal"><span class="pre">scf.addons.dynamic_sz_()</span></code> can provide this functionality:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; O 0 0 1&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">verbose</span><span class="o">=</span><span class="mi">4</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">dynamic_sz_</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%s</span><span class="s1">, 2S+1 = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mf</span><span class="o">.</span><span class="n">spin_square</span><span class="p">())</span>
</pre></div>
</div>
<p>This function automatically converges the ground sate of oxygen molecule to
triplet state although we didn&#8217;t specify spin state in the <code class="xref py py-attr docutils literal"><span class="pre">mol</span></code> object.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Function <code class="xref py py-func docutils literal"><span class="pre">scf.addons.dynamic_sz_()</span></code> has side effects.  It changes
the underlying mean-field object.</p>
</div>
<p>The <cite>addons</cite> mechanism increases the flexibility of PySCf program.  You can
define various addons to customize the default behaviour of pyscf program.  For
example, if you&#8217;d like to track the changes of the density (the diagonal
term of density matrix) of certain basis during the SCF iteration, you can write
the following addon to output the required density:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">output_density</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">basis_label</span><span class="p">):</span>
    <span class="n">ao_labels</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">ao_labels</span><span class="p">()</span>
    <span class="n">old_make_rdm1</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">make_rdm1</span>
    <span class="k">def</span> <span class="nf">make_rdm1</span><span class="p">(</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mo_occ</span><span class="p">):</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="n">old_make_rdm1</span><span class="p">(</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mo_occ</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;AO         alpha             beta&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ao_labels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">basis_label</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">],</span> <span class="n">dm</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dm</span>
    <span class="n">mf</span><span class="o">.</span><span class="n">make_rdm1</span> <span class="o">=</span> <span class="n">make_rdm1</span>
    <span class="k">return</span> <span class="n">mf</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; O 0 0 1&#39;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">verbose</span><span class="o">=</span><span class="mi">4</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">dynamic_sz_</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">output_density</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="s1">&#39;O 2p&#39;</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="caching-two-electron-integrals">
<h2>6.3. Caching two-electron integrals<a class="headerlink" href="#caching-two-electron-integrals" title="Permalink to this headline">¶</a></h2>
<p>When memory is enough (specified by the <code class="xref py py-attr docutils literal"><span class="pre">max_memory</span></code> of SCF object), the
SCF object generates all two-electron integrals in memory and cache them in
<code class="xref py py-attr docutils literal"><span class="pre">_eri</span></code> array.  The default <code class="xref py py-attr docutils literal"><span class="pre">max_memory</span></code> (defined in
<code class="xref py py-data docutils literal"><span class="pre">lib.parameters.MAX_MEMORY</span></code>, see <a class="reference internal" href="lib.html#max-mem"><span class="std std-ref">Maximum memory</span></a>) is 4 GB.  It roughly
corresponds to two-electron real integrals for 250 orbitals.  For small systems,
the cached integrals usually provide the best performance.  If you have enough
main memory in your computer, you can increase the <code class="xref py py-attr docutils literal"><span class="pre">max_memory</span></code> of SCF
object to cache the integrals in memory.</p>
<p>The cached integrals <code class="xref py py-attr docutils literal"><span class="pre">_eri</span></code> are treated as a dense tensor.  When system
becomes larger and the two-electron integral tensor becomes sparse, caching
integrals may lose performance advantage.  This is mainly due to the fact that
the implementation of J/K build for the cached integrals did not utilize the
sparsity of the integral tensor.  Also, the data locality was not considered in
the implementation which sometimes leads to bad OpenMP multi-threading speed up.
For large system, the AO-driven direct SCF method is more favorable.</p>
</div>
<div class="section" id="customizing-hamiltonian">
<span id="customize-h"></span><h2>6.4. Customizing Hamiltonian<a class="headerlink" href="#customizing-hamiltonian" title="Permalink to this headline">¶</a></h2>
<p>This integral object <code class="xref py py-attr docutils literal"><span class="pre">_eri</span></code> is not merely used by the mean-field
calculation.  Along with the <code class="xref py py-meth docutils literal"><span class="pre">get_hcore()</span></code> method, this two-electron
integral object will be treated as the Hamiltonian in the post-SCF code whenever
possible.  This mechanism provides a way to model arbitrary fermion system in
PySCF.  You can customize a system by changing the 1-electron Hamiltonian and
the mean-field <code class="xref py py-attr docutils literal"><span class="pre">_eri</span></code> attribute.  For example, the following code solves a
model system:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">ao2mo</span><span class="p">,</span> <span class="n">ccsd</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
<span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># anti-PBC</span>
<span class="n">eri</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">eri</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.0</span>

<span class="n">mf</span><span class="o">.</span><span class="n">get_hcore</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">t</span>
<span class="n">mf</span><span class="o">.</span><span class="n">get_ovlp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="c1"># ao2mo.restore(8, eri, n) to get 8-fold symmetry of the integrals</span>
<span class="c1"># ._eri only supports the 2-electron integrals in 4-fold or 8-fold symmetry.</span>
<span class="n">mf</span><span class="o">.</span><span class="n">_eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">eri</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="n">mycc</span> <span class="o">=</span> <span class="n">ccsd</span><span class="o">.</span><span class="n">RCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">e</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;IP = &#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="n">e</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eaccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;EA = &#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>Some post-SCF methods require the 4-index MO integrals.  Depending the available
memory (affected by the value of <code class="xref py py-attr docutils literal"><span class="pre">max_memory</span></code> in each class), these
methods may not use the &#8220;AO integrals&#8221; cached in <code class="xref py py-attr docutils literal"><span class="pre">_eri</span></code>.  To ensure the
post mean-field methods to use the <code class="xref py py-attr docutils literal"><span class="pre">_eri</span></code> integrals no matter whether the
actual memory usage is over the <code class="xref py py-attr docutils literal"><span class="pre">max_memory</span></code> limite, you can set the flag
<code class="xref py py-attr docutils literal"><span class="pre">incore_anyway</span></code> in <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> class to <code class="docutils literal"><span class="pre">True</span></code> before calling the
<code class="xref py py-meth docutils literal"><span class="pre">kernel()</span></code> function of the post-SCF methods.  In the following example,
without setting <code class="docutils literal"><span class="pre">incore_anyway=True</span></code>, the CCSD calculations may crash:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">ao2mo</span><span class="p">,</span> <span class="n">ccsd</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">=</span> <span class="n">n</span>
<span class="n">mol</span><span class="o">.</span><span class="n">max_memory</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
<span class="n">eri</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">eri</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.0</span>

<span class="n">mf</span><span class="o">.</span><span class="n">get_hcore</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">t</span>
<span class="n">mf</span><span class="o">.</span><span class="n">get_ovlp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">_eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">eri</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="n">mol</span><span class="o">.</span><span class="n">incore_anyway</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">ccsd</span><span class="o">.</span><span class="n">RCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">e</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;IP = &#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="n">e</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eaccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;EA = &#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>Holding the entire two-particle interactions matrix elements in memory often
leads to high memory usage.  In the SCF calculation, the memory usage can be
optimized if <code class="xref py py-attr docutils literal"><span class="pre">_eri</span></code> is sparse.  The SCF iterations requires only the Fock
matrix which in turn calls the J/K build function <code class="xref py py-meth docutils literal"><span class="pre">SCF.get_jk()</span></code> to compute
the Coulomb and HF-exchange matrix.  Overwriting the <code class="xref py py-meth docutils literal"><span class="pre">SCF.get_jk()</span></code> function
can reduce the memory footprint of the SCF part in the above example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">ao2mo</span><span class="p">,</span> <span class="n">ccsd</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">=</span> <span class="n">n</span>
<span class="n">mol</span><span class="o">.</span><span class="n">max_memory</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>

<span class="n">mf</span><span class="o">.</span><span class="n">get_hcore</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">t</span>
<span class="n">mf</span><span class="o">.</span><span class="n">get_ovlp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dm</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span> <span class="o">*</span> <span class="mf">4.</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">dm</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span> <span class="o">*</span> <span class="mf">4.</span>
    <span class="k">return</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span>
<span class="n">mf</span><span class="o">.</span><span class="n">get_jk</span> <span class="o">=</span> <span class="n">get_jk</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>Another way to handle the two-particle interactions of large model system is to
use the density fitting/Cholesky decomposed integrals.  See also
<a class="reference internal" href="df.html#sl-cderi"><span class="std std-ref">Saving/Loading DF integral tensor</span></a>.</p>
</div>
<div class="section" id="module-pyscf.scf">
<span id="program-reference"></span><h2>6.5. Program reference<a class="headerlink" href="#module-pyscf.scf" title="Permalink to this headline">¶</a></h2>
<div class="section" id="hartree-fock">
<h3>6.5.1. Hartree-Fock<a class="headerlink" href="#hartree-fock" title="Permalink to this headline">¶</a></h3>
<p>Simple usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal"><span class="pre">scf.RHF()</span></code> returns an instance of SCF class.  There are some parameters
to control the SCF method.</p>
<blockquote>
<div><dl class="docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-10</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>DIIS</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">class listed in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code></span><dd>Default is <code class="xref py py-class docutils literal"><span class="pre">diis.SCF_DIIS</span></code>. Set it to None/False to turn off DIIS.</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>whether to do DIIS.  Default is True.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 0.</dd>
<dt>level_shift_factor</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
<dt>nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(int,int), for UHF/ROHF class</span><dd>freeze the number of (alpha,beta) electrons.</dd>
<dt>irrep_nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict, for symmetry- RHF/ROHF/UHF class only</span><dd>to indicate the number of electrons for each irreps.
In RHF, give {&#8216;ir_name&#8217;:int, ...} ;
In ROHF/UHF, give {&#8216;ir_name&#8217;:(int,int), ...} .
It is effective when <code class="xref py py-attr docutils literal"><span class="pre">Mole.symmetry</span></code> is set <code class="docutils literal"><span class="pre">True</span></code>.</dd>
<dt>auxbasis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str, for density fitting SCF only</span><dd><p class="first">Auxiliary basis for density fitting.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">density_fit</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
</pre></div>
</div>
<p class="last">Density fitting can be applied to all non-relativistic HF class.</p>
</dd>
<dt>with_ssss</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool, for Dirac-Hartree-Fock only</span><dd>If False, ignore small component integrals (SS|SS).  Default is True.</dd>
<dt>with_gaunt</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool, for Dirac-Hartree-Fock only</span><dd>If False, ignore Gaunt interaction.  Default is False.</dd>
</dl>
</div></blockquote>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier"></span><dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="non-relativistic-hartree-fock">
<h3>6.5.2. Non-relativistic Hartree-Fock<a class="headerlink" href="#non-relativistic-hartree-fock" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pyscf.scf.hf.SCF">
<em class="property">class </em><code class="descclassname">pyscf.scf.hf.</code><code class="descname">SCF</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-9</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.  Default is sqrt(conv_tol)</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>DIIS</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">DIIS class</span><dd>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code>.</span><dd>Default is the object associated to the attribute <code class="xref py py-attr docutils literal"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is inialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS informations (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 1.</dd>
<dt>diis_file: &#8216;str&#8217;</dt>
<dd>File to store DIIS vectors and error vectors.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
<dt>check_convergence</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs) =&gt; bool</span><dd>A hook for overloading convergence criteria in SCF iterations.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy :</dt>
<dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.scf.hf.SCF.QMMM">
<code class="descname">QMMM</code><span class="sig-paren">(</span><em>scf_method</em>, <em>coords</em>, <em>charges</em>, <em>unit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.QMMM" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify the QM method using the (non-relativistic) potential generated
by MM charges. Note the static Coulomb interactions of the background
charges are not included in the total energy.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">scf_method : a HF or DFT object</p>
<dl class="last docutils">
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>MM particle coordinates</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>MM particle charges</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>unit</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Bohr, AU, Ang (case insensitive). Default is the same to mol.unit</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Same method object as the input scf_method with modified 1e Hamiltonian</dd>
<dt>Note:</dt>
<dd>1. if MM charge and X2C correction are used together, function mm_charge
needs to be applied after X2C decoration (.x2c method), eg
mf = mm_charge(scf.RHF(mol).x2c()), [(0.5,0.6,0.8)], [-0.5]).
2. Once mm_charge function is applied on the SCF object, it
affects all the post-HF calculations eg MP2, CCSD, MCSCF etc</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">mm_charge</span><span class="p">(</span><span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">),</span> <span class="p">[(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.6</span><span class="p">,</span><span class="mf">0.8</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-101.940495711284</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.analyze">
<code class="descname">analyze</code><span class="sig-paren">(</span><em>verbose=None</em>, <em>with_meta_lowdin=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.as_scanner">
<code class="descname">as_scanner</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner/solver for HF PES.</p>
<p>The returned solver is a function. This function requires one argument
&#8220;mol&#8221; as input and returns total HF energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
SCF object (DIIS, conv_tol, max_memory etc) are automatically applied in
the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, ...) during calculation.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">))</span>
<span class="go">-98.552190448277955</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.5&#39;</span><span class="p">))</span>
<span class="go">-98.414750424294368</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.canonicalize">
<code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix within occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.dip_moment">
<code class="descname">dip_moment</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment calculation</p>
<div class="math">
\[\begin{split}\mu_x = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|x|\mu) + \sum_A Q_A X_A\\
\mu_y = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|y|\mu) + \sum_A Q_A Y_A\\
\mu_z = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|z|\mu) + \sum_A Q_A Z_A\end{split}\]</div>
<p>where <span class="math">\(\mu_x, \mu_y, \mu_z\)</span> are the x, y and z components of dipole
moment</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mol: an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code>
dm : a 2D ndarrays density matrices</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z component</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.eig">
<code class="descname">eig</code><span class="sig-paren">(</span><em>h</em>, <em>s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math">
\[HC = SCE\]</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.energy_elec">
<code class="descname">energy_elec</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>h1e=None</em>, <em>vhf=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Electronic part of Hartree-Fock energy, for given core hamiltonian and
HF potential</p>
<p>... math:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> \<span class="n">sum_</span><span class="p">{</span><span class="n">ij</span><span class="p">}</span><span class="n">h_</span><span class="p">{</span><span class="n">ij</span><span class="p">}</span> \<span class="n">gamma_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span>
  <span class="o">+</span> \<span class="n">frac</span><span class="p">{</span><span class="mi">1</span><span class="p">}{</span><span class="mi">2</span><span class="p">}</span>\<span class="n">sum_</span><span class="p">{</span><span class="n">ijkl</span><span class="p">}</span> \<span class="n">gamma_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span>\<span class="n">gamma_</span><span class="p">{</span><span class="n">lk</span><span class="p">}</span> \<span class="n">langle</span> <span class="n">ik</span><span class="o">||</span><span class="n">jl</span>\<span class="n">rangle</span>
</pre></div>
</div>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mf : an instance of SCF class</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>one-partical density matrix</dd>
<dt>h1e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Core hamiltonian</dd>
<dt>vhf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>HF potential</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Hartree-Fock electronic energy and the Coulomb energy</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.energy_tot">
<code class="descname">energy_tot</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>h1e=None</em>, <em>vhf=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.energy_tot" title="Permalink to this definition">¶</a></dt>
<dd><p>Total Hartree-Fock energy, electronic part plus nuclear repulstion
See <code class="xref py py-func docutils literal"><span class="pre">scf.hf.energy_elec()</span></code> for the electron part</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.from_chk">
<code class="descname">from_chk</code><span class="sig-paren">(</span><em>chkfile=None</em>, <em>project=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.from_chk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.from_chk" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal"><span class="pre">mol</span></code></p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.get_fock">
<code class="descname">get_fock</code><span class="sig-paren">(</span><em>mf</em>, <em>h1e=None</em>, <em>s1e=None</em>, <em>vhf=None</em>, <em>dm=None</em>, <em>cycle=-1</em>, <em>diis=None</em>, <em>diis_start_cycle=None</em>, <em>level_shift_factor=None</em>, <em>damp_factor=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.get_fock" title="Permalink to this definition">¶</a></dt>
<dd><p>F = h^{core} + V^{HF}</p>
<p>Special treatment (damping, DIIS, or level shift) will be applied to the
Fock matrix if diis and cycle is specified (The two parameters are passed
to get_fock function during the SCF iteration)</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>h1e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Core hamiltonian</dd>
<dt>s1e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Overlap matrix, for DIIS</dd>
<dt>vhf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>HF potential matrix</dd>
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Density matrix, for DIIS</dd>
<dt>cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Then present SCF iteration step, for DIIS</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an object of <code class="xref py py-attr docutils literal"><span class="pre">SCF.DIIS</span></code> class</span><dd>DIIS object to hold intermediate Fock and error vectors</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 0.</dd>
<dt>level_shift_factor</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.get_grad">
<code class="descname">get_grad</code><span class="sig-paren">(</span><em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Obital coefficients</dd>
<dt>mo_occ</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span><dd>Orbital occupancy</dd>
<dt>fock_ao</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Fock matrix in AO representation</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Gradients in MO representation.  It&#8217;s a num_occ*num_vir vector.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.get_j">
<code class="descname">get_j</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J matrices for all input density matrices</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.get_jk">
<code class="descname">get_jk</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>with_j=True</em>, <em>with_k=True</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
<dt>with_j</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to compute J matrices</dd>
<dt>with_k</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to compute K matrices</dd>
<dt>omega</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Parameter of range-seperated Coulomb operator: erf( omega * r12 ) / r12.
If specified, integration are evaluated based on the long-range
part of the range-seperated Coulomb operator.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.get_k">
<code class="descname">get_k</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.get_k"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute K matrices for all input density matrices</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.get_occ">
<code class="descname">get_occ</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_energy=None</em>, <em>mo_coeff=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span><dd>Obital energies</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Obital coefficients</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 0, 2, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.get_veff">
<code class="descname">get_veff</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</dd>
<dt>vhf_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The reference HF potential matrix.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf0</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">dm_last</span><span class="o">=</span><span class="n">dm0</span><span class="p">,</span> <span class="n">vhf_last</span><span class="o">=</span><span class="n">vhf0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vhf1</span><span class="p">,</span> <span class="n">vhf2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.init_guess_by_1e">
<code class="descname">init_guess_by_1e</code><span class="sig-paren">(</span><em>mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.init_guess_by_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.init_guess_by_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.init_guess_by_atom">
<code class="descname">init_guess_by_atom</code><span class="sig-paren">(</span><em>mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.init_guess_by_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.init_guess_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.init_guess_by_chkfile">
<code class="descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em>chkfile=None</em>, <em>project=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal"><span class="pre">mol</span></code></p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.init_guess_by_minao">
<code class="descname">init_guess_by_minao</code><span class="sig-paren">(</span><em>mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.init_guess_by_minao"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.init_guess_by_minao" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix based on ANO basis, then project
the density matrix to the basis set defined by <code class="docutils literal"><span class="pre">mol</span></code></p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">init_guess_by_minao</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">array([[ 0.94758917,  0.09227308],</span>
<span class="go">       [ 0.09227308,  0.94758917]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.kernel">
<code class="descname">kernel</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF main driver</p>
<blockquote>
<div><dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If given, it will be used as the initial guess density matrix</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.make_rdm1">
<code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>mo_occ=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix in AO representation</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Orbital coefficients. Each column is one orbital.</dd>
<dt>mo_occ</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span><dd>Occupancy</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.mulliken_meta">
<code class="descname">mulliken_meta</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>verbose=5</em>, <em>pre_orth_method='ANO'</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or 2-item list of ndarray</span><dd>Density matrix.  ROHF dm is a 2-item list of 2D array</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><p class="first">verbose : int or instance of <a class="reference internal" href="lib.html#lib.logger.Logger" title="lib.logger.Logger"><code class="xref py py-class docutils literal"><span class="pre">lib.logger.Logger</span></code></a></p>
<dl class="last docutils">
<dt>pre_orth_method</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd><p class="first">Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="last line-block">
<div class="line">&#8216;ano&#8217;   : Project GTOs to ANO basis</div>
<div class="line">&#8216;minao&#8217; : Project GTOs to MINAO basis</div>
<div class="line">&#8216;scf&#8217;   : Fraction-averaged RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">A list : pop, charges</p>
<dl class="last docutils">
<dt>pop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken population on each atomic orbitals</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken charges</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.mulliken_pop">
<code class="descname">mulliken_pop</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>s=None</em>, <em>verbose=5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.mulliken_pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.mulliken_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">A list : pop, charges</p>
<dl class="last docutils">
<dt>pop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken population on each atomic orbitals</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken charges</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.mulliken_pop_meta_lowdin_ao">
<code class="descname">mulliken_pop_meta_lowdin_ao</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.mulliken_pop_meta_lowdin_ao" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or 2-item list of ndarray</span><dd>Density matrix.  ROHF dm is a 2-item list of 2D array</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><p class="first">verbose : int or instance of <a class="reference internal" href="lib.html#lib.logger.Logger" title="lib.logger.Logger"><code class="xref py py-class docutils literal"><span class="pre">lib.logger.Logger</span></code></a></p>
<dl class="last docutils">
<dt>pre_orth_method</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd><p class="first">Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="last line-block">
<div class="line">&#8216;ano&#8217;   : Project GTOs to ANO basis</div>
<div class="line">&#8216;minao&#8217; : Project GTOs to MINAO basis</div>
<div class="line">&#8216;scf&#8217;   : Fraction-averaged RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">A list : pop, charges</p>
<dl class="last docutils">
<dt>pop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken population on each atomic orbitals</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken charges</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.nuc_grad_method">
<code class="descname">nuc_grad_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.nuc_grad_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.nuc_grad_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or 2-item list of ndarray</span><dd>Density matrix.  ROHF dm is a 2-item list of 2D array</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><p class="first">verbose : int or instance of <a class="reference internal" href="lib.html#lib.logger.Logger" title="lib.logger.Logger"><code class="xref py py-class docutils literal"><span class="pre">lib.logger.Logger</span></code></a></p>
<dl class="last docutils">
<dt>pre_orth_method</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd><p class="first">Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="last line-block">
<div class="line">&#8216;ano&#8217;   : Project GTOs to ANO basis</div>
<div class="line">&#8216;minao&#8217; : Project GTOs to MINAO basis</div>
<div class="line">&#8216;scf&#8217;   : Fraction-averaged RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">A list : pop, charges</p>
<dl class="last docutils">
<dt>pop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken population on each atomic orbitals</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken charges</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><em>mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset mol and clean up relevant attributes for scanner mode</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.scf">
<code class="descname">scf</code><span class="sig-paren">(</span><em>dm0=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.scf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.scf" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF main driver</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If given, it will be used as the initial guess density matrix</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.to_ghf">
<code class="descname">to_ghf</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.to_ghf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.to_ghf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a GHF/GKS object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.to_rhf">
<code class="descname">to_rhf</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.to_rhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.to_rhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a RHF/ROHF/RKS/ROKS object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.to_uhf">
<code class="descname">to_uhf</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.to_uhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.to_uhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a UHF/UKS object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>chkfile=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It&#8217;s an alias of function <a href="#id4"><span class="problematic" id="id5">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.update_">
<code class="descname">update_</code><span class="sig-paren">(</span><em>chkfile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.update_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.update_" title="Permalink to this definition">¶</a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It&#8217;s an alias of function <a href="#id6"><span class="problematic" id="id7">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.update_from_chk">
<code class="descname">update_from_chk</code><span class="sig-paren">(</span><em>chkfile=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.update_from_chk" title="Permalink to this definition">¶</a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It&#8217;s an alias of function <a href="#id8"><span class="problematic" id="id9">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.SCF.update_from_chk_">
<code class="descname">update_from_chk_</code><span class="sig-paren">(</span><em>chkfile=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.update_from_chk_" title="Permalink to this definition">¶</a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It&#8217;s an alias of function <a href="#id10"><span class="problematic" id="id11">update_from_chk_</span></a>.</p>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="pyscf.scf.hf.RHF">
<em class="property">class </em><code class="descclassname">pyscf.scf.hf.</code><code class="descname">RHF</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#RHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.RHF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-9</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.  Default is sqrt(conv_tol)</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>DIIS</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">DIIS class</span><dd>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code>.</span><dd>Default is the object associated to the attribute <code class="xref py py-attr docutils literal"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is inialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS informations (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 1.</dd>
<dt>diis_file: &#8216;str&#8217;</dt>
<dd>File to store DIIS vectors and error vectors.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
<dt>check_convergence</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs) =&gt; bool</span><dd>A hook for overloading convergence criteria in SCF iterations.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy :</dt>
<dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.scf.hf.RHF.CASCI">
<code class="descname">CASCI</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.CASCI" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mf_or_mol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">SCF object or Mole object</span><dd>SCF or Mole to define the problem size.</dd>
<dt>ncas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of active orbitals.</dd>
<dt>nelecas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or a pair of int</span><dd>Number of electrons in active space.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>ncore</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code>.</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code>.</dd>
<dt>ncas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Active space size.</dd>
<dt>nelecas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">tuple of int</span><dd>Active (nelec_alpha, nelec_beta)</dd>
<dt>ncore</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of int</span><dd>Core electron number.  In UHF-CASSCF, it&#8217;s a tuple to indicate the different core eletron numbers.</dd>
<dt>natorb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to transform natural orbital in active space.  Be cautious
of this parameter when CASCI/CASSCF are combined with DMRG solver
or selected CI solver because DMRG and selected CI are not invariant
to the rotation in active space.
False by default.</dd>
<dt>canonicalization</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to canonicalize orbitals. Note that canonicalization does
not change the orbitals in active space by default. It only
diagonalizes core and external space of the general Fock matirx.
To get the natural orbitals in active space, attribute natorb
need to be enabled.
True by default.</dd>
<dt>sorting_mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</dd>
<dt>fcisolver</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">FCISolver</span></code></span><dd><p class="first">The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p class="last">For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total MCSCF energy (electronic energy plus nuclear repulsion)</dd>
<dt>e_cas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>CAS space FCI energy</dd>
<dt>ci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>CAS space FCI coefficients</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitls.</dd>
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Diagonal elements of general Fock matrix (in mo_coeff
representation).</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.RHF.CASSCF">
<code class="descname">CASSCF</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.CASSCF" title="Permalink to this definition">¶</a></dt>
<dd><p>CASCI</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mf_or_mol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">SCF object or Mole object</span><dd>SCF or Mole to define the problem size.</dd>
<dt>ncas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of active orbitals.</dd>
<dt>nelecas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or a pair of int</span><dd>Number of electrons in active space.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>ncore</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code>.</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code>.</dd>
<dt>ncas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Active space size.</dd>
<dt>nelecas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">tuple of int</span><dd>Active (nelec_alpha, nelec_beta)</dd>
<dt>ncore</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of int</span><dd>Core electron number.  In UHF-CASSCF, it&#8217;s a tuple to indicate the different core eletron numbers.</dd>
<dt>natorb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to transform natural orbital in active space.  Be cautious
of this parameter when CASCI/CASSCF are combined with DMRG solver
or selected CI solver because DMRG and selected CI are not invariant
to the rotation in active space.
False by default.</dd>
<dt>canonicalization</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to canonicalize orbitals. Note that canonicalization does
not change the orbitals in active space by default. It only
diagonalizes core and external space of the general Fock matirx.
To get the natural orbitals in active space, attribute natorb
need to be enabled.
True by default.</dd>
<dt>sorting_mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</dd>
<dt>fcisolver</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">FCISolver</span></code></span><dd><p class="first">The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p class="last">For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total MCSCF energy (electronic energy plus nuclear repulsion)</dd>
<dt>e_cas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>CAS space FCI energy</dd>
<dt>ci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>CAS space FCI coefficients</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitls.</dd>
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Diagonal elements of general Fock matrix (in mo_coeff
representation).</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
<span class="go">CASSCF</span>
</pre></div>
</div>
<p>Extra attributes for CASSCF:</p>
<blockquote>
<div><dl class="docutils">
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Converge threshold.  Default is 1e-7</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Converge threshold for CI gradients and orbital rotation gradients.
Default is 1e-4</dd>
<dt>max_stepsize</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>The step size for orbital rotation.  Small step (0.005 - 0.05) is prefered.
Default is 0.03.</dd>
<dt>max_cycle_macro</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Max number of macro iterations.  Default is 50.</dd>
<dt>max_cycle_micro</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Max number of micro iterations in each macro iteration.  Depending on
systems, increasing this value might reduce the total macro
iterations.  Generally, 2 - 5 steps should be enough.  Default is 3.</dd>
<dt>ah_level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float, for AH solver.</span><dd>Level shift for the Davidson diagonalization in AH solver.  Default is 1e-8.</dd>
<dt>ah_conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float, for AH solver.</span><dd>converge threshold for AH solver.  Default is 1e-12.</dd>
<dt>ah_max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float, for AH solver.</span><dd>Max number of iterations allowd in AH solver.  Default is 30.</dd>
<dt>ah_lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float, for AH solver.</span><dd>Linear dependence threshold for AH solver.  Default is 1e-14.</dd>
<dt>ah_start_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">flat, for AH solver.</span><dd>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 0.2.</dd>
<dt>ah_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int, for AH solver.</span><dd><p class="first">In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 2.</p>
<p><code class="docutils literal"><span class="pre">ah_conv_tol</span></code>, <code class="docutils literal"><span class="pre">ah_max_cycle</span></code>, <code class="docutils literal"><span class="pre">ah_lindep</span></code>, <code class="docutils literal"><span class="pre">ah_start_tol</span></code> and <code class="docutils literal"><span class="pre">ah_start_cycle</span></code>
can affect the accuracy and performance of CASSCF solver.  Lower
<code class="docutils literal"><span class="pre">ah_conv_tol</span></code> and <code class="docutils literal"><span class="pre">ah_lindep</span></code> might improve the accuracy of CASSCF
optimization, but decrease the performance.</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401898486001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401887945668</span>
</pre></div>
</div>
</dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Checkpoint file to save the intermediate orbitals during the CASSCF optimization.
Default is the checkpoint file of mean field object.</dd>
<dt>ci_response_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>subspace size to solve the CI vector response.  Default is 3.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>scale_restoration</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>When a step of orbital rotation moves out of trust region, the
orbital optimization will be restored to previous state and the
step size of the orbital rotation needs to be reduced.
scale_restoration controls how much to scale down the step size.</dd>
</dl>
</div></blockquote>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total MCSCF energy (electronic energy plus nuclear repulsion)</dd>
<dt>e_cas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>CAS space FCI energy</dd>
<dt>ci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>CAS space FCI coefficients</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Optimized CASSCF orbitals coefficients. When canonicalization is
specified, the returned orbitals make the general Fock matrix
(Fock operator on top of MCSCF 1-particle density matrix)
diagonalized within each subspace (core, active, external).
If natorb (natural orbitals in active space) is specified,
the active segment of the mo_coeff is natural orbitls.</dd>
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Diagonal elements of general Fock matrix (in mo_coeff
representation).</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401882238134</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.RHF.Gradients">
<code class="descname">Gradients</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.Gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-relativistic restricted Hartree-Fock gradients</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.RHF.Hessian">
<code class="descname">Hessian</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.Hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-relativistic restricted Hartree-Fock hessian</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.RHF.TDA">
<code class="descname">TDA</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.TDA" title="Permalink to this definition">¶</a></dt>
<dd><p>Tamm-Dancoff approximation</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Diagonalization convergence tolerance.  Default is 1e-9.</dd>
<dt>nstates</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of TD states to be computed. Default is 3.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Diagonalization converged or not</dd>
<dt>e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>excitation energy for each excited state.</dd>
<dt>xy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">A list of two 2D arrays</span><dd>The two 2D arrays are Excitation coefficients X (shape [nocc,nvir])
and de-excitation coefficients Y (shape [nocc,nvir]) for each
excited state.  (X,Y) are normalized to 1/2 in RHF/RKS methods and
normalized to 1 for UHF/UKS methods. In the TDA calculation, Y = 0.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.RHF.TDHF">
<code class="descname">TDHF</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.TDHF" title="Permalink to this definition">¶</a></dt>
<dd><p>Time-dependent Hartree-Fock</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Diagonalization convergence tolerance.  Default is 1e-9.</dd>
<dt>nstates</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of TD states to be computed. Default is 3.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Diagonalization converged or not</dd>
<dt>e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>excitation energy for each excited state.</dd>
<dt>xy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">A list of two 2D arrays</span><dd>The two 2D arrays are Excitation coefficients X (shape [nocc,nvir])
and de-excitation coefficients Y (shape [nocc,nvir]) for each
excited state.  (X,Y) are normalized to 1/2 in RHF/RKS methods and
normalized to 1 for UHF/UKS methods. In the TDA calculation, Y = 0.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.RHF.convert_from_">
<code class="descname">convert_from_</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#RHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to RHF/ROHF</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.RHF.get_jk">
<code class="descname">get_jk</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>with_j=True</em>, <em>with_k=True</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#RHF.get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
<dt>with_j</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to compute J matrices</dd>
<dt>with_k</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to compute K matrices</dd>
<dt>omega</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Parameter of range-seperated Coulomb operator: erf( omega * r12 ) / r12.
If specified, integration are evaluated based on the long-range
part of the range-seperated Coulomb operator.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.RHF.get_veff">
<code class="descname">get_veff</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#RHF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</dd>
<dt>vhf_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The reference HF potential matrix.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf0</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">dm_last</span><span class="o">=</span><span class="n">dm0</span><span class="p">,</span> <span class="n">vhf_last</span><span class="o">=</span><span class="n">vhf0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vhf1</span><span class="p">,</span> <span class="n">vhf2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.RHF.spin_square">
<code class="descname">spin_square</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#RHF.spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square and multiplicity of RHF determinant</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf.RHF.stability">
<code class="descname">stability</code><span class="sig-paren">(</span><em>internal=True</em>, <em>external=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#RHF.stability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.stability" title="Permalink to this definition">¶</a></dt>
<dd><p>RHF/RKS stability analysis.</p>
<p>See also pyscf.scf.stability.rhf_stability function.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>internal</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Internal stability, within the RHF optimization space.</dd>
<dt>external</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>External stability. Including the RHF -&gt; UHF and real -&gt; complex
stability analysis.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>New orbitals that are more close to the stable condition.  The return
value includes two set of orbitals.  The first corresponds to the
internal stablity and the second corresponds to the external stability.</dd>
</dl>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="pyscf.scf.rohf.ROHF">
<em class="property">class </em><code class="descclassname">pyscf.scf.rohf.</code><code class="descname">ROHF</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/rohf.html#ROHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-9</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.  Default is sqrt(conv_tol)</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>DIIS</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">DIIS class</span><dd>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code>.</span><dd>Default is the object associated to the attribute <code class="xref py py-attr docutils literal"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is inialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS informations (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 1.</dd>
<dt>diis_file: &#8216;str&#8217;</dt>
<dd>File to store DIIS vectors and error vectors.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
<dt>check_convergence</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs) =&gt; bool</span><dd>A hook for overloading convergence criteria in SCF iterations.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy :</dt>
<dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.CASCI">
<code class="descname">CASCI</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.CASCI" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mf_or_mol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">SCF object or Mole object</span><dd>SCF or Mole to define the problem size.</dd>
<dt>ncas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of active orbitals.</dd>
<dt>nelecas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or a pair of int</span><dd>Number of electrons in active space.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>ncore</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code>.</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code>.</dd>
<dt>ncas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Active space size.</dd>
<dt>nelecas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">tuple of int</span><dd>Active (nelec_alpha, nelec_beta)</dd>
<dt>ncore</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of int</span><dd>Core electron number.  In UHF-CASSCF, it&#8217;s a tuple to indicate the different core eletron numbers.</dd>
<dt>natorb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to transform natural orbital in active space.  Be cautious
of this parameter when CASCI/CASSCF are combined with DMRG solver
or selected CI solver because DMRG and selected CI are not invariant
to the rotation in active space.
False by default.</dd>
<dt>canonicalization</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to canonicalize orbitals. Note that canonicalization does
not change the orbitals in active space by default. It only
diagonalizes core and external space of the general Fock matirx.
To get the natural orbitals in active space, attribute natorb
need to be enabled.
True by default.</dd>
<dt>sorting_mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</dd>
<dt>fcisolver</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">FCISolver</span></code></span><dd><p class="first">The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p class="last">For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total MCSCF energy (electronic energy plus nuclear repulsion)</dd>
<dt>e_cas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>CAS space FCI energy</dd>
<dt>ci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>CAS space FCI coefficients</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitls.</dd>
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Diagonal elements of general Fock matrix (in mo_coeff
representation).</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.CASSCF">
<code class="descname">CASSCF</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.CASSCF" title="Permalink to this definition">¶</a></dt>
<dd><p>CASCI</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mf_or_mol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">SCF object or Mole object</span><dd>SCF or Mole to define the problem size.</dd>
<dt>ncas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of active orbitals.</dd>
<dt>nelecas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or a pair of int</span><dd>Number of electrons in active space.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>ncore</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code>.</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code>.</dd>
<dt>ncas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Active space size.</dd>
<dt>nelecas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">tuple of int</span><dd>Active (nelec_alpha, nelec_beta)</dd>
<dt>ncore</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of int</span><dd>Core electron number.  In UHF-CASSCF, it&#8217;s a tuple to indicate the different core eletron numbers.</dd>
<dt>natorb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to transform natural orbital in active space.  Be cautious
of this parameter when CASCI/CASSCF are combined with DMRG solver
or selected CI solver because DMRG and selected CI are not invariant
to the rotation in active space.
False by default.</dd>
<dt>canonicalization</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to canonicalize orbitals. Note that canonicalization does
not change the orbitals in active space by default. It only
diagonalizes core and external space of the general Fock matirx.
To get the natural orbitals in active space, attribute natorb
need to be enabled.
True by default.</dd>
<dt>sorting_mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</dd>
<dt>fcisolver</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">FCISolver</span></code></span><dd><p class="first">The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p class="last">For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total MCSCF energy (electronic energy plus nuclear repulsion)</dd>
<dt>e_cas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>CAS space FCI energy</dd>
<dt>ci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>CAS space FCI coefficients</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitls.</dd>
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Diagonal elements of general Fock matrix (in mo_coeff
representation).</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
<span class="go">CASSCF</span>
</pre></div>
</div>
<p>Extra attributes for CASSCF:</p>
<blockquote>
<div><dl class="docutils">
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Converge threshold.  Default is 1e-7</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Converge threshold for CI gradients and orbital rotation gradients.
Default is 1e-4</dd>
<dt>max_stepsize</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>The step size for orbital rotation.  Small step (0.005 - 0.05) is prefered.
Default is 0.03.</dd>
<dt>max_cycle_macro</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Max number of macro iterations.  Default is 50.</dd>
<dt>max_cycle_micro</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Max number of micro iterations in each macro iteration.  Depending on
systems, increasing this value might reduce the total macro
iterations.  Generally, 2 - 5 steps should be enough.  Default is 3.</dd>
<dt>ah_level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float, for AH solver.</span><dd>Level shift for the Davidson diagonalization in AH solver.  Default is 1e-8.</dd>
<dt>ah_conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float, for AH solver.</span><dd>converge threshold for AH solver.  Default is 1e-12.</dd>
<dt>ah_max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float, for AH solver.</span><dd>Max number of iterations allowd in AH solver.  Default is 30.</dd>
<dt>ah_lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float, for AH solver.</span><dd>Linear dependence threshold for AH solver.  Default is 1e-14.</dd>
<dt>ah_start_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">flat, for AH solver.</span><dd>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 0.2.</dd>
<dt>ah_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int, for AH solver.</span><dd><p class="first">In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 2.</p>
<p><code class="docutils literal"><span class="pre">ah_conv_tol</span></code>, <code class="docutils literal"><span class="pre">ah_max_cycle</span></code>, <code class="docutils literal"><span class="pre">ah_lindep</span></code>, <code class="docutils literal"><span class="pre">ah_start_tol</span></code> and <code class="docutils literal"><span class="pre">ah_start_cycle</span></code>
can affect the accuracy and performance of CASSCF solver.  Lower
<code class="docutils literal"><span class="pre">ah_conv_tol</span></code> and <code class="docutils literal"><span class="pre">ah_lindep</span></code> might improve the accuracy of CASSCF
optimization, but decrease the performance.</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401898486001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401887945668</span>
</pre></div>
</div>
</dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Checkpoint file to save the intermediate orbitals during the CASSCF optimization.
Default is the checkpoint file of mean field object.</dd>
<dt>ci_response_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>subspace size to solve the CI vector response.  Default is 3.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>scale_restoration</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>When a step of orbital rotation moves out of trust region, the
orbital optimization will be restored to previous state and the
step size of the orbital rotation needs to be reduced.
scale_restoration controls how much to scale down the step size.</dd>
</dl>
</div></blockquote>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total MCSCF energy (electronic energy plus nuclear repulsion)</dd>
<dt>e_cas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>CAS space FCI energy</dd>
<dt>ci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>CAS space FCI coefficients</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Optimized CASSCF orbitals coefficients. When canonicalization is
specified, the returned orbitals make the general Fock matrix
(Fock operator on top of MCSCF 1-particle density matrix)
diagonalized within each subspace (core, active, external).
If natorb (natural orbitals in active space) is specified,
the active segment of the mo_coeff is natural orbitls.</dd>
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Diagonal elements of general Fock matrix (in mo_coeff
representation).</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401882238134</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.Gradients">
<code class="descname">Gradients</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.Gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-relativistic ROHF gradients</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.analyze">
<code class="descname">analyze</code><span class="sig-paren">(</span><em>verbose=None</em>, <em>with_meta_lowdin=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/rohf.html#ROHF.analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.canonicalize">
<code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix within occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.check_sanity">
<code class="descname">check_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.check_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
&#8220;_&#8221;.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.eig">
<code class="descname">eig</code><span class="sig-paren">(</span><em>fock</em>, <em>s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/rohf.html#ROHF.eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math">
\[HC = SCE\]</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.get_fock">
<code class="descname">get_fock</code><span class="sig-paren">(</span><em>mf</em>, <em>h1e=None</em>, <em>s1e=None</em>, <em>vhf=None</em>, <em>dm=None</em>, <em>cycle=-1</em>, <em>diis=None</em>, <em>diis_start_cycle=None</em>, <em>level_shift_factor=None</em>, <em>damp_factor=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.get_fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Build fock matrix based on Roothaan&#8217;s effective fock.
See also <code class="xref py py-func docutils literal"><span class="pre">get_roothaan_fock()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.get_grad">
<code class="descname">get_grad</code><span class="sig-paren">(</span><em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/rohf.html#ROHF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>ROHF gradients is the off-diagonal block [co + cv + ov], where
[ cc co cv ]
[ oc oo ov ]
[ vc vo vv ]</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.get_occ">
<code class="descname">get_occ</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_energy=None</em>, <em>mo_coeff=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital.
NOTE the occupancies are not assigned based on the orbital energy ordering.
The first N orbitals are assigned to be occupied orbitals.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; O 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 2, 2, 1, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.get_veff">
<code class="descname">get_veff</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/rohf.html#ROHF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Unrestricted Hartree-Fock potential matrix of alpha and beta spins,
for the given density matrix</p>
<div class="math">
\[\begin{split}V_{ij}^\alpha &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\alpha \\
V_{ij}^\beta  &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\beta\end{split}\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of ndarrays</span><dd>A list of density matrices, stored as (alpha,alpha,...,beta,beta,...)</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The density matrix baseline.  When it is not 0, this function computes
the increment of HF potential w.r.t. the reference HF potential matrix.</dd>
<dt>vhf_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The reference HF potential matrix.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><span class="math">\(V_{hf} = (V^\alpha, V^\beta)\)</span>.  <span class="math">\(V^\alpha\)</span> (and <span class="math">\(V^\beta\)</span>)
can be a list matrices, corresponding to the input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dmsa</span><span class="p">,</span><span class="n">dmsb</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="p">,</span> <span class="n">vhfb</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">uhf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfb</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.make_rdm1">
<code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>mo_occ=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/rohf.html#ROHF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle densit matrix.  mo_occ is a 1D array, with occupancy 1 or 2.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.spin_square">
<code class="descname">spin_square</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/rohf.html#ROHF.spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square and multiplicity of RHF determinant</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.rohf.ROHF.stability">
<code class="descname">stability</code><span class="sig-paren">(</span><em>internal=True</em>, <em>external=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/rohf.html#ROHF.stability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.stability" title="Permalink to this definition">¶</a></dt>
<dd><p>ROHF/ROKS stability analysis.</p>
<p>See also pyscf.scf.stability.rohf_stability function.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>internal</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Internal stability, within the RHF optimization space.</dd>
<dt>external</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>External stability. It is not available in current version.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>The return value includes two set of orbitals which are more close to
the required stable condition.</dd>
</dl>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="pyscf.scf.uhf.UHF">
<em class="property">class </em><code class="descclassname">pyscf.scf.uhf.</code><code class="descname">UHF</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-9</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.  Default is sqrt(conv_tol)</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>DIIS</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">DIIS class</span><dd>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code>.</span><dd>Default is the object associated to the attribute <code class="xref py py-attr docutils literal"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is inialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS informations (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 1.</dd>
<dt>diis_file: &#8216;str&#8217;</dt>
<dd>File to store DIIS vectors and error vectors.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
<dt>check_convergence</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs) =&gt; bool</span><dd>A hook for overloading convergence criteria in SCF iterations.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy :</dt>
<dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Attributes for UHF:</dt>
<dd><dl class="first last docutils">
<dt>nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(int, int)</span><dd>If given, freeze the number of (alpha,beta) electrons to the given value.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">number or two-element list</span><dd>level shift (in Eh) for alpha and beta Fock if two-element list is given.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mf</span><span class="o">.</span><span class="n">spin_square</span><span class="p">())</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.scf.uhf.UHF.Gradients">
<code class="descname">Gradients</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.Gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-relativistic unrestricted Hartree-Fock gradients</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf.UHF.Hessian">
<code class="descname">Hessian</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.Hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-relativistic UHF hessian</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf.UHF.canonicalize">
<code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf.UHF.convert_from_">
<code class="descname">convert_from_</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Create UHF object based on the RHF/ROHF object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf.UHF.det_ovlp">
<code class="descname">det_ovlp</code><span class="sig-paren">(</span><em>mo1</em>, <em>mo2</em>, <em>occ1</em>, <em>occ2</em>, <em>ovlp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.det_ovlp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.det_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the overlap between two different determinants. It is the product
of single values of molecular orbital overlap matrix.</p>
<div class="math">
\[S_{12} = \langle \Psi_A | \Psi_B \rangle
= (\mathrm{det}\mathbf{U}) (\mathrm{det}\mathbf{V^\dagger})\prod\limits_{i=1}\limits^{2N} \lambda_{ii}\]</div>
<p>where <span class="math">\(\mathbf{U}, \mathbf{V}, \lambda\)</span> are unitary matrices and single
values generated by single value decomposition(SVD) of the overlap matrix
<span class="math">\(\mathbf{O}\)</span> which is the overlap matrix of two sets of molecular orbitals:</p>
<div class="math">
\[\mathbf{U}^\dagger \mathbf{O} \mathbf{V} = \mathbf{\Lambda}\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo1, mo2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarrays</span><dd>Molecualr orbital coefficients</dd>
<dt>occ1, occ2: 2D ndarrays</dt>
<dd>occupation numbers</dd>
</dl>
</dd>
<dt>Return:</dt>
<dd><dl class="first last docutils">
<dt>A list: the product of single values: float</dt>
<dd>x_a, x_b: 1D ndarrays
<span class="math">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>
They are used to calculate asymmetric density matrix</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf.UHF.energy_elec">
<code class="descname">energy_elec</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>h1e=None</em>, <em>vhf=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Electronic energy of Unrestricted Hartree-Fock</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Hartree-Fock electronic energy and the 2-electron part contribution</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf.UHF.get_jk">
<code class="descname">get_jk</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>with_j=True</em>, <em>with_k=True</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Coulomb (J) and exchange (K)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of 2D arrays or a list of 3D arrays</span><dd>(alpha_dm, beta_dm) or (alpha_dms, beta_dms)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf.UHF.get_veff">
<code class="descname">get_veff</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Unrestricted Hartree-Fock potential matrix of alpha and beta spins,
for the given density matrix</p>
<div class="math">
\[\begin{split}V_{ij}^\alpha &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\alpha \\
V_{ij}^\beta  &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\beta\end{split}\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of ndarrays</span><dd>A list of density matrices, stored as (alpha,alpha,...,beta,beta,...)</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The density matrix baseline.  When it is not 0, this function computes
the increment of HF potential w.r.t. the reference HF potential matrix.</dd>
<dt>vhf_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The reference HF potential matrix.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><span class="math">\(V_{hf} = (V^\alpha, V^\beta)\)</span>.  <span class="math">\(V^\alpha\)</span> (and <span class="math">\(V^\beta\)</span>)
can be a list matrices, corresponding to the input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dmsa</span><span class="p">,</span><span class="n">dmsb</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="p">,</span> <span class="n">vhfb</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">uhf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfb</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf.UHF.init_guess_by_minao">
<code class="descname">init_guess_by_minao</code><span class="sig-paren">(</span><em>mol=None</em>, <em>breaksym=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.init_guess_by_minao"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.init_guess_by_minao" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess in terms of the overlap to minimal basis.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf.UHF.make_asym_dm">
<code class="descname">make_asym_dm</code><span class="sig-paren">(</span><em>mo1</em>, <em>mo2</em>, <em>occ1</em>, <em>occ2</em>, <em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.make_asym_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.make_asym_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle asymmetric density matrix</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo1, mo2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarrays</span><dd>Molecualr orbital coefficients</dd>
<dt>occ1, occ2: 2D ndarrays</dt>
<dd>Occupation numbers</dd>
<dt>x: 2D ndarrays</dt>
<dd><span class="math">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>.
See also <code class="xref py py-func docutils literal"><span class="pre">det_ovlp()</span></code></dd>
</dl>
</dd>
<dt>Return:</dt>
<dd>A list of 2D ndarrays for alpha and beta spin</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.3&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.4&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">intor_cross</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">det</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">det_ovlp</span><span class="p">(</span><span class="n">mf1</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adm</span> <span class="o">=</span> <span class="n">make_asym_dm</span><span class="p">(</span><span class="n">mf1</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adm</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 19, 19)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf.UHF.make_rdm1">
<code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>mo_occ=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A list of 2D ndarrays for alpha and beta spins</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf.UHF.spin_square">
<code class="descname">spin_square</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square and multiplicity of UHF determinant</p>
<div class="math">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>There are two possibilities for <span class="math">\(S_+ S_-\)</span></dt>
<dd><ol class="first arabic simple">
<li>same electron <span class="math">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</li>
</ol>
<div class="math">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="last math">
\[\langle S_+ S_- \rangle = \langle ij|s_+ s_-|ij\rangle
                        - \langle ij|s_+ s_-|ji\rangle
                        = -\langle i^\alpha|j^\beta\rangle
                           \langle j^\beta|i^\alpha\rangle\]</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Similarly, for <span class="math">\(S_- S_+\)</span></dt>
<dd><ol class="first arabic simple">
<li>same electron</li>
</ol>
<div class="math">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li>different electrons</li>
</ol>
<div class="last math">
\[\langle S_- S_+ \rangle = -\langle i^\beta|j^\alpha\rangle
                           \langle j^\alpha|i^\beta\rangle\]</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>For <span class="math">\(S_z^2\)</span></dt>
<dd><ol class="first arabic simple">
<li>same electron</li>
</ol>
<div class="math">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li>different electrons</li>
</ol>
<div class="last math">
\[\begin{split}&amp;\frac{1}{2}\sum_{ij}(\langle ij|2s_{z1}s_{z2}|ij\rangle
                     -\langle ij|2s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}(n_\alpha^2 - n_\alpha n_\beta - n_\beta n_\alpha + n_\beta^2)
 -\frac{1}{4}(n_\alpha + n_\beta) \\
&amp;=\frac{1}{4}((n_\alpha-n_\beta)^2 - (n_\alpha+n_\beta))\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<p>In total</p>
<div class="math">
\[\begin{split}\langle S^2\rangle &amp;= \frac{1}{2}
(n_\alpha-\sum_{ij}\langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle
+n_\beta -\sum_{ij}\langle i^\beta|j^\alpha\rangle\langle j^\alpha|i^\beta\rangle)
+ \frac{1}{4}(n_\alpha-n_\beta)^2 \\\end{split}\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of 2 ndarrays</span><dd>Occupied alpha and occupied beta orbitals</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>s</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>AO overlap</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf.UHF.stability">
<code class="descname">stability</code><span class="sig-paren">(</span><em>internal=True</em>, <em>external=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.stability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.stability" title="Permalink to this definition">¶</a></dt>
<dd><p>Stability analysis for RHF/RKS method.</p>
<p>See also pyscf.scf.stability.uhf_stability function.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mf : UHF or UKS object</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>internal</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Internal stability, within the UHF space.</dd>
<dt>external</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>External stability. Including the UHF -&gt; GHF and real -&gt; complex
stability analysis.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>New orbitals that are more close to the stable condition.  The return
value includes two set of orbitals.  The first corresponds to the
internal stablity and the second corresponds to the external stability.</dd>
</dl>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<span class="target" id="module-pyscf.scf.hf"></span><p>Hartree-Fock</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">pyscf.scf.hf.</code><code class="descname">RHF</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#RHF"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-9</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.  Default is sqrt(conv_tol)</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>DIIS</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">DIIS class</span><dd>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code>.</span><dd>Default is the object associated to the attribute <code class="xref py py-attr docutils literal"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is inialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS informations (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 1.</dd>
<dt>diis_file: &#8216;str&#8217;</dt>
<dd>File to store DIIS vectors and error vectors.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
<dt>check_convergence</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs) =&gt; bool</span><dd>A hook for overloading convergence criteria in SCF iterations.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy :</dt>
<dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="method">
<dt>
<code class="descname">CASCI</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mf_or_mol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">SCF object or Mole object</span><dd>SCF or Mole to define the problem size.</dd>
<dt>ncas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of active orbitals.</dd>
<dt>nelecas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or a pair of int</span><dd>Number of electrons in active space.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>ncore</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code>.</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code>.</dd>
<dt>ncas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Active space size.</dd>
<dt>nelecas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">tuple of int</span><dd>Active (nelec_alpha, nelec_beta)</dd>
<dt>ncore</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of int</span><dd>Core electron number.  In UHF-CASSCF, it&#8217;s a tuple to indicate the different core eletron numbers.</dd>
<dt>natorb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to transform natural orbital in active space.  Be cautious
of this parameter when CASCI/CASSCF are combined with DMRG solver
or selected CI solver because DMRG and selected CI are not invariant
to the rotation in active space.
False by default.</dd>
<dt>canonicalization</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to canonicalize orbitals. Note that canonicalization does
not change the orbitals in active space by default. It only
diagonalizes core and external space of the general Fock matirx.
To get the natural orbitals in active space, attribute natorb
need to be enabled.
True by default.</dd>
<dt>sorting_mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</dd>
<dt>fcisolver</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">FCISolver</span></code></span><dd><p class="first">The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p class="last">For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total MCSCF energy (electronic energy plus nuclear repulsion)</dd>
<dt>e_cas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>CAS space FCI energy</dd>
<dt>ci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>CAS space FCI coefficients</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitls.</dd>
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Diagonal elements of general Fock matrix (in mo_coeff
representation).</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">CASSCF</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>CASCI</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mf_or_mol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">SCF object or Mole object</span><dd>SCF or Mole to define the problem size.</dd>
<dt>ncas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of active orbitals.</dd>
<dt>nelecas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or a pair of int</span><dd>Number of electrons in active space.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>ncore</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code>.</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code>.</dd>
<dt>ncas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Active space size.</dd>
<dt>nelecas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">tuple of int</span><dd>Active (nelec_alpha, nelec_beta)</dd>
<dt>ncore</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of int</span><dd>Core electron number.  In UHF-CASSCF, it&#8217;s a tuple to indicate the different core eletron numbers.</dd>
<dt>natorb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to transform natural orbital in active space.  Be cautious
of this parameter when CASCI/CASSCF are combined with DMRG solver
or selected CI solver because DMRG and selected CI are not invariant
to the rotation in active space.
False by default.</dd>
<dt>canonicalization</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to canonicalize orbitals. Note that canonicalization does
not change the orbitals in active space by default. It only
diagonalizes core and external space of the general Fock matirx.
To get the natural orbitals in active space, attribute natorb
need to be enabled.
True by default.</dd>
<dt>sorting_mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</dd>
<dt>fcisolver</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">FCISolver</span></code></span><dd><p class="first">The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p class="last">For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total MCSCF energy (electronic energy plus nuclear repulsion)</dd>
<dt>e_cas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>CAS space FCI energy</dd>
<dt>ci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>CAS space FCI coefficients</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitls.</dd>
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Diagonal elements of general Fock matrix (in mo_coeff
representation).</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
<span class="go">CASSCF</span>
</pre></div>
</div>
<p>Extra attributes for CASSCF:</p>
<blockquote>
<div><dl class="docutils">
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Converge threshold.  Default is 1e-7</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Converge threshold for CI gradients and orbital rotation gradients.
Default is 1e-4</dd>
<dt>max_stepsize</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>The step size for orbital rotation.  Small step (0.005 - 0.05) is prefered.
Default is 0.03.</dd>
<dt>max_cycle_macro</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Max number of macro iterations.  Default is 50.</dd>
<dt>max_cycle_micro</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Max number of micro iterations in each macro iteration.  Depending on
systems, increasing this value might reduce the total macro
iterations.  Generally, 2 - 5 steps should be enough.  Default is 3.</dd>
<dt>ah_level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float, for AH solver.</span><dd>Level shift for the Davidson diagonalization in AH solver.  Default is 1e-8.</dd>
<dt>ah_conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float, for AH solver.</span><dd>converge threshold for AH solver.  Default is 1e-12.</dd>
<dt>ah_max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float, for AH solver.</span><dd>Max number of iterations allowd in AH solver.  Default is 30.</dd>
<dt>ah_lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float, for AH solver.</span><dd>Linear dependence threshold for AH solver.  Default is 1e-14.</dd>
<dt>ah_start_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">flat, for AH solver.</span><dd>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 0.2.</dd>
<dt>ah_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int, for AH solver.</span><dd><p class="first">In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 2.</p>
<p><code class="docutils literal"><span class="pre">ah_conv_tol</span></code>, <code class="docutils literal"><span class="pre">ah_max_cycle</span></code>, <code class="docutils literal"><span class="pre">ah_lindep</span></code>, <code class="docutils literal"><span class="pre">ah_start_tol</span></code> and <code class="docutils literal"><span class="pre">ah_start_cycle</span></code>
can affect the accuracy and performance of CASSCF solver.  Lower
<code class="docutils literal"><span class="pre">ah_conv_tol</span></code> and <code class="docutils literal"><span class="pre">ah_lindep</span></code> might improve the accuracy of CASSCF
optimization, but decrease the performance.</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401898486001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401887945668</span>
</pre></div>
</div>
</dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Checkpoint file to save the intermediate orbitals during the CASSCF optimization.
Default is the checkpoint file of mean field object.</dd>
<dt>ci_response_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>subspace size to solve the CI vector response.  Default is 3.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>scale_restoration</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>When a step of orbital rotation moves out of trust region, the
orbital optimization will be restored to previous state and the
step size of the orbital rotation needs to be reduced.
scale_restoration controls how much to scale down the step size.</dd>
</dl>
</div></blockquote>
<p>Saved results</p>
<blockquote>
<div><dl class="docutils">
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total MCSCF energy (electronic energy plus nuclear repulsion)</dd>
<dt>e_cas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>CAS space FCI energy</dd>
<dt>ci</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>CAS space FCI coefficients</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Optimized CASSCF orbitals coefficients. When canonicalization is
specified, the returned orbitals make the general Fock matrix
(Fock operator on top of MCSCF 1-particle density matrix)
diagonalized within each subspace (core, active, external).
If natorb (natural orbitals in active space) is specified,
the active segment of the mo_coeff is natural orbitls.</dd>
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Diagonal elements of general Fock matrix (in mo_coeff
representation).</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401882238134</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">Gradients</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Non-relativistic restricted Hartree-Fock gradients</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">Hessian</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Non-relativistic restricted Hartree-Fock hessian</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">TDA</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Tamm-Dancoff approximation</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Diagonalization convergence tolerance.  Default is 1e-9.</dd>
<dt>nstates</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of TD states to be computed. Default is 3.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Diagonalization converged or not</dd>
<dt>e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>excitation energy for each excited state.</dd>
<dt>xy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">A list of two 2D arrays</span><dd>The two 2D arrays are Excitation coefficients X (shape [nocc,nvir])
and de-excitation coefficients Y (shape [nocc,nvir]) for each
excited state.  (X,Y) are normalized to 1/2 in RHF/RKS methods and
normalized to 1 for UHF/UKS methods. In the TDA calculation, Y = 0.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">TDHF</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Time-dependent Hartree-Fock</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Diagonalization convergence tolerance.  Default is 1e-9.</dd>
<dt>nstates</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of TD states to be computed. Default is 3.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Diagonalization converged or not</dd>
<dt>e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>excitation energy for each excited state.</dd>
<dt>xy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">A list of two 2D arrays</span><dd>The two 2D arrays are Excitation coefficients X (shape [nocc,nvir])
and de-excitation coefficients Y (shape [nocc,nvir]) for each
excited state.  (X,Y) are normalized to 1/2 in RHF/RKS methods and
normalized to 1 for UHF/UKS methods. In the TDA calculation, Y = 0.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">convert_from_</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#RHF.convert_from_"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Convert the input mean-field object to RHF/ROHF</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_jk</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>with_j=True</em>, <em>with_k=True</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#RHF.get_jk"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
<dt>with_j</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to compute J matrices</dd>
<dt>with_k</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to compute K matrices</dd>
<dt>omega</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Parameter of range-seperated Coulomb operator: erf( omega * r12 ) / r12.
If specified, integration are evaluated based on the long-range
part of the range-seperated Coulomb operator.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_veff</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#RHF.get_veff"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</dd>
<dt>vhf_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The reference HF potential matrix.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf0</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">dm_last</span><span class="o">=</span><span class="n">dm0</span><span class="p">,</span> <span class="n">vhf_last</span><span class="o">=</span><span class="n">vhf0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vhf1</span><span class="p">,</span> <span class="n">vhf2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">spin_square</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#RHF.spin_square"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Spin square and multiplicity of RHF determinant</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">stability</code><span class="sig-paren">(</span><em>internal=True</em>, <em>external=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#RHF.stability"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>RHF/RKS stability analysis.</p>
<p>See also pyscf.scf.stability.rhf_stability function.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>internal</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Internal stability, within the RHF optimization space.</dd>
<dt>external</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>External stability. Including the RHF -&gt; UHF and real -&gt; complex
stability analysis.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>New orbitals that are more close to the stable condition.  The return
value includes two set of orbitals.  The first corresponds to the
internal stablity and the second corresponds to the external stability.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">pyscf.scf.hf.</code><code class="descname">SCF</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-9</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.  Default is sqrt(conv_tol)</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>DIIS</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">DIIS class</span><dd>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code>.</span><dd>Default is the object associated to the attribute <code class="xref py py-attr docutils literal"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is inialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS informations (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 1.</dd>
<dt>diis_file: &#8216;str&#8217;</dt>
<dd>File to store DIIS vectors and error vectors.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
<dt>check_convergence</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs) =&gt; bool</span><dd>A hook for overloading convergence criteria in SCF iterations.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy :</dt>
<dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="method">
<dt>
<code class="descname">QMMM</code><span class="sig-paren">(</span><em>scf_method</em>, <em>coords</em>, <em>charges</em>, <em>unit=None</em><span class="sig-paren">)</span></dt>
<dd><p>Modify the QM method using the (non-relativistic) potential generated
by MM charges. Note the static Coulomb interactions of the background
charges are not included in the total energy.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">scf_method : a HF or DFT object</p>
<dl class="last docutils">
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>MM particle coordinates</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>MM particle charges</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>unit</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Bohr, AU, Ang (case insensitive). Default is the same to mol.unit</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Same method object as the input scf_method with modified 1e Hamiltonian</dd>
<dt>Note:</dt>
<dd>1. if MM charge and X2C correction are used together, function mm_charge
needs to be applied after X2C decoration (.x2c method), eg
mf = mm_charge(scf.RHF(mol).x2c()), [(0.5,0.6,0.8)], [-0.5]).
2. Once mm_charge function is applied on the SCF object, it
affects all the post-HF calculations eg MP2, CCSD, MCSCF etc</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">mm_charge</span><span class="p">(</span><span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">),</span> <span class="p">[(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.6</span><span class="p">,</span><span class="mf">0.8</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-101.940495711284</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">analyze</code><span class="sig-paren">(</span><em>verbose=None</em>, <em>with_meta_lowdin=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.analyze"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">as_scanner</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span></dt>
<dd><p>Generating a scanner/solver for HF PES.</p>
<p>The returned solver is a function. This function requires one argument
&#8220;mol&#8221; as input and returns total HF energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
SCF object (DIIS, conv_tol, max_memory etc) are automatically applied in
the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, ...) during calculation.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">))</span>
<span class="go">-98.552190448277955</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.5&#39;</span><span class="p">))</span>
<span class="go">-98.414750424294368</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix within occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">dip_moment</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.dip_moment"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Dipole moment calculation</p>
<div class="math">
\[\begin{split}\mu_x = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|x|\mu) + \sum_A Q_A X_A\\
\mu_y = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|y|\mu) + \sum_A Q_A Y_A\\
\mu_z = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|z|\mu) + \sum_A Q_A Z_A\end{split}\]</div>
<p>where <span class="math">\(\mu_x, \mu_y, \mu_z\)</span> are the x, y and z components of dipole
moment</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mol: an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code>
dm : a 2D ndarrays density matrices</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z component</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">eig</code><span class="sig-paren">(</span><em>h</em>, <em>s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.eig"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math">
\[HC = SCE\]</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">energy_elec</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>h1e=None</em>, <em>vhf=None</em><span class="sig-paren">)</span></dt>
<dd><p>Electronic part of Hartree-Fock energy, for given core hamiltonian and
HF potential</p>
<p>... math:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> \<span class="n">sum_</span><span class="p">{</span><span class="n">ij</span><span class="p">}</span><span class="n">h_</span><span class="p">{</span><span class="n">ij</span><span class="p">}</span> \<span class="n">gamma_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span>
  <span class="o">+</span> \<span class="n">frac</span><span class="p">{</span><span class="mi">1</span><span class="p">}{</span><span class="mi">2</span><span class="p">}</span>\<span class="n">sum_</span><span class="p">{</span><span class="n">ijkl</span><span class="p">}</span> \<span class="n">gamma_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span>\<span class="n">gamma_</span><span class="p">{</span><span class="n">lk</span><span class="p">}</span> \<span class="n">langle</span> <span class="n">ik</span><span class="o">||</span><span class="n">jl</span>\<span class="n">rangle</span>
</pre></div>
</div>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mf : an instance of SCF class</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>one-partical density matrix</dd>
<dt>h1e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Core hamiltonian</dd>
<dt>vhf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>HF potential</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Hartree-Fock electronic energy and the Coulomb energy</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">energy_tot</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>h1e=None</em>, <em>vhf=None</em><span class="sig-paren">)</span></dt>
<dd><p>Total Hartree-Fock energy, electronic part plus nuclear repulstion
See <code class="xref py py-func docutils literal"><span class="pre">scf.hf.energy_elec()</span></code> for the electron part</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">from_chk</code><span class="sig-paren">(</span><em>chkfile=None</em>, <em>project=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.from_chk"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal"><span class="pre">mol</span></code></p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_fock</code><span class="sig-paren">(</span><em>mf</em>, <em>h1e=None</em>, <em>s1e=None</em>, <em>vhf=None</em>, <em>dm=None</em>, <em>cycle=-1</em>, <em>diis=None</em>, <em>diis_start_cycle=None</em>, <em>level_shift_factor=None</em>, <em>damp_factor=None</em><span class="sig-paren">)</span></dt>
<dd><p>F = h^{core} + V^{HF}</p>
<p>Special treatment (damping, DIIS, or level shift) will be applied to the
Fock matrix if diis and cycle is specified (The two parameters are passed
to get_fock function during the SCF iteration)</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>h1e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Core hamiltonian</dd>
<dt>s1e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Overlap matrix, for DIIS</dd>
<dt>vhf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>HF potential matrix</dd>
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Density matrix, for DIIS</dd>
<dt>cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Then present SCF iteration step, for DIIS</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an object of <code class="xref py py-attr docutils literal"><span class="pre">SCF.DIIS</span></code> class</span><dd>DIIS object to hold intermediate Fock and error vectors</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 0.</dd>
<dt>level_shift_factor</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_grad</code><span class="sig-paren">(</span><em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.get_grad"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Obital coefficients</dd>
<dt>mo_occ</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span><dd>Orbital occupancy</dd>
<dt>fock_ao</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Fock matrix in AO representation</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Gradients in MO representation.  It&#8217;s a num_occ*num_vir vector.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_j</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.get_j"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Compute J matrices for all input density matrices</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_jk</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>with_j=True</em>, <em>with_k=True</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.get_jk"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
<dt>with_j</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to compute J matrices</dd>
<dt>with_k</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to compute K matrices</dd>
<dt>omega</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Parameter of range-seperated Coulomb operator: erf( omega * r12 ) / r12.
If specified, integration are evaluated based on the long-range
part of the range-seperated Coulomb operator.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_k</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.get_k"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Compute K matrices for all input density matrices</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_occ</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_energy=None</em>, <em>mo_coeff=None</em><span class="sig-paren">)</span></dt>
<dd><p>Label the occupancies for each orbital</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span><dd>Obital energies</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Obital coefficients</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 0, 2, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_veff</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.get_veff"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</dd>
<dt>vhf_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The reference HF potential matrix.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf0</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">dm_last</span><span class="o">=</span><span class="n">dm0</span><span class="p">,</span> <span class="n">vhf_last</span><span class="o">=</span><span class="n">vhf0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vhf1</span><span class="p">,</span> <span class="n">vhf2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">init_guess_by_1e</code><span class="sig-paren">(</span><em>mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.init_guess_by_1e"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">init_guess_by_atom</code><span class="sig-paren">(</span><em>mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.init_guess_by_atom"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em>chkfile=None</em>, <em>project=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal"><span class="pre">mol</span></code></p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">init_guess_by_minao</code><span class="sig-paren">(</span><em>mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.init_guess_by_minao"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Generate initial guess density matrix based on ANO basis, then project
the density matrix to the basis set defined by <code class="docutils literal"><span class="pre">mol</span></code></p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">init_guess_by_minao</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">array([[ 0.94758917,  0.09227308],</span>
<span class="go">       [ 0.09227308,  0.94758917]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">kernel</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>SCF main driver</p>
<blockquote>
<div><dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If given, it will be used as the initial guess density matrix</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>mo_occ=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.make_rdm1"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>One-particle density matrix in AO representation</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Orbital coefficients. Each column is one orbital.</dd>
<dt>mo_occ</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span><dd>Occupancy</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">mulliken_meta</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>verbose=5</em>, <em>pre_orth_method='ANO'</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.mulliken_meta"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or 2-item list of ndarray</span><dd>Density matrix.  ROHF dm is a 2-item list of 2D array</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><p class="first">verbose : int or instance of <a class="reference internal" href="lib.html#lib.logger.Logger" title="lib.logger.Logger"><code class="xref py py-class docutils literal"><span class="pre">lib.logger.Logger</span></code></a></p>
<dl class="last docutils">
<dt>pre_orth_method</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd><p class="first">Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="last line-block">
<div class="line">&#8216;ano&#8217;   : Project GTOs to ANO basis</div>
<div class="line">&#8216;minao&#8217; : Project GTOs to MINAO basis</div>
<div class="line">&#8216;scf&#8217;   : Fraction-averaged RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">A list : pop, charges</p>
<dl class="last docutils">
<dt>pop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken population on each atomic orbitals</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken charges</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">mulliken_pop</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>s=None</em>, <em>verbose=5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.mulliken_pop"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">A list : pop, charges</p>
<dl class="last docutils">
<dt>pop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken population on each atomic orbitals</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken charges</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">mulliken_pop_meta_lowdin_ao</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or 2-item list of ndarray</span><dd>Density matrix.  ROHF dm is a 2-item list of 2D array</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><p class="first">verbose : int or instance of <a class="reference internal" href="lib.html#lib.logger.Logger" title="lib.logger.Logger"><code class="xref py py-class docutils literal"><span class="pre">lib.logger.Logger</span></code></a></p>
<dl class="last docutils">
<dt>pre_orth_method</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd><p class="first">Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="last line-block">
<div class="line">&#8216;ano&#8217;   : Project GTOs to ANO basis</div>
<div class="line">&#8216;minao&#8217; : Project GTOs to MINAO basis</div>
<div class="line">&#8216;scf&#8217;   : Fraction-averaged RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">A list : pop, charges</p>
<dl class="last docutils">
<dt>pop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken population on each atomic orbitals</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken charges</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">nuc_grad_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.nuc_grad_method"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">pop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.pop"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or 2-item list of ndarray</span><dd>Density matrix.  ROHF dm is a 2-item list of 2D array</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><p class="first">verbose : int or instance of <a class="reference internal" href="lib.html#lib.logger.Logger" title="lib.logger.Logger"><code class="xref py py-class docutils literal"><span class="pre">lib.logger.Logger</span></code></a></p>
<dl class="last docutils">
<dt>pre_orth_method</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd><p class="first">Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="last line-block">
<div class="line">&#8216;ano&#8217;   : Project GTOs to ANO basis</div>
<div class="line">&#8216;minao&#8217; : Project GTOs to MINAO basis</div>
<div class="line">&#8216;scf&#8217;   : Fraction-averaged RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">A list : pop, charges</p>
<dl class="last docutils">
<dt>pop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken population on each atomic orbitals</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken charges</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">reset</code><span class="sig-paren">(</span><em>mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.reset"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Reset mol and clean up relevant attributes for scanner mode</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">scf</code><span class="sig-paren">(</span><em>dm0=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.scf"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>SCF main driver</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If given, it will be used as the initial guess density matrix</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">to_ghf</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.to_ghf"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Convert the input mean-field object to a GHF/GKS object</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">to_rhf</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.to_rhf"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Convert the input mean-field object to a RHF/ROHF/RKS/ROKS object</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">to_uhf</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.to_uhf"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Convert the input mean-field object to a UHF/UKS object</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">update</code><span class="sig-paren">(</span><em>chkfile=None</em><span class="sig-paren">)</span></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It&#8217;s an alias of function <a href="#id12"><span class="problematic" id="id13">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">update_</code><span class="sig-paren">(</span><em>chkfile=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#SCF.update_"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It&#8217;s an alias of function <a href="#id14"><span class="problematic" id="id15">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">update_from_chk</code><span class="sig-paren">(</span><em>chkfile=None</em><span class="sig-paren">)</span></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It&#8217;s an alias of function <a href="#id16"><span class="problematic" id="id17">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">update_from_chk_</code><span class="sig-paren">(</span><em>chkfile=None</em><span class="sig-paren">)</span></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It&#8217;s an alias of function <a href="#id18"><span class="problematic" id="id19">update_from_chk_</span></a>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.analyze">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">analyze</code><span class="sig-paren">(</span><em>mf</em>, <em>verbose=5</em>, <em>with_meta_lowdin=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.as_scanner">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">as_scanner</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#as_scanner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner/solver for HF PES.</p>
<p>The returned solver is a function. This function requires one argument
&#8220;mol&#8221; as input and returns total HF energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
SCF object (DIIS, conv_tol, max_memory etc) are automatically applied in
the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, ...) during calculation.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">))</span>
<span class="go">-98.552190448277955</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.5&#39;</span><span class="p">))</span>
<span class="go">-98.414750424294368</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.canonicalize">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#canonicalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix within occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.dip_moment">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">dip_moment</code><span class="sig-paren">(</span><em>mol</em>, <em>dm</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment calculation</p>
<div class="math">
\[\begin{split}\mu_x = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|x|\mu) + \sum_A Q_A X_A\\
\mu_y = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|y|\mu) + \sum_A Q_A Y_A\\
\mu_z = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|z|\mu) + \sum_A Q_A Z_A\end{split}\]</div>
<p>where <span class="math">\(\mu_x, \mu_y, \mu_z\)</span> are the x, y and z components of dipole
moment</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mol: an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code>
dm : a 2D ndarrays density matrices</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z component</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.dot_eri_dm">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">dot_eri_dm</code><span class="sig-paren">(</span><em>eri</em>, <em>dm</em>, <em>hermi=0</em>, <em>with_j=True</em>, <em>with_k=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#dot_eri_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.dot_eri_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J, K matrices in terms of the given 2-electron integrals and
density matrix:</p>
<p>J ~ numpy.einsum(&#8216;pqrs,qp-&gt;rs&#8217;, eri, dm)
K ~ numpy.einsum(&#8216;pqrs,qr-&gt;ps&#8217;, eri, dm)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>eri</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>8-fold or 4-fold ERIs or complex integral array with N^4 elements
(N is the number of orbitals)</dd>
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eri</span> <span class="o">=</span> <span class="n">_vhf</span><span class="o">.</span><span class="n">int2e_sph</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_env</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">dot_eri_dm</span><span class="p">(</span><span class="n">eri</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.eig">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">eig</code><span class="sig-paren">(</span><em>h</em>, <em>s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math">
\[HC = SCE\]</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.energy_elec">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">energy_elec</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>h1e=None</em>, <em>vhf=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#energy_elec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Electronic part of Hartree-Fock energy, for given core hamiltonian and
HF potential</p>
<p>... math:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> \<span class="n">sum_</span><span class="p">{</span><span class="n">ij</span><span class="p">}</span><span class="n">h_</span><span class="p">{</span><span class="n">ij</span><span class="p">}</span> \<span class="n">gamma_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span>
  <span class="o">+</span> \<span class="n">frac</span><span class="p">{</span><span class="mi">1</span><span class="p">}{</span><span class="mi">2</span><span class="p">}</span>\<span class="n">sum_</span><span class="p">{</span><span class="n">ijkl</span><span class="p">}</span> \<span class="n">gamma_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span>\<span class="n">gamma_</span><span class="p">{</span><span class="n">lk</span><span class="p">}</span> \<span class="n">langle</span> <span class="n">ik</span><span class="o">||</span><span class="n">jl</span>\<span class="n">rangle</span>
</pre></div>
</div>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mf : an instance of SCF class</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>one-partical density matrix</dd>
<dt>h1e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Core hamiltonian</dd>
<dt>vhf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>HF potential</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Hartree-Fock electronic energy and the Coulomb energy</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.energy_tot">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">energy_tot</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>h1e=None</em>, <em>vhf=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#energy_tot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.energy_tot" title="Permalink to this definition">¶</a></dt>
<dd><p>Total Hartree-Fock energy, electronic part plus nuclear repulstion
See <code class="xref py py-func docutils literal"><span class="pre">scf.hf.energy_elec()</span></code> for the electron part</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.get_fock">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">get_fock</code><span class="sig-paren">(</span><em>mf</em>, <em>h1e=None</em>, <em>s1e=None</em>, <em>vhf=None</em>, <em>dm=None</em>, <em>cycle=-1</em>, <em>diis=None</em>, <em>diis_start_cycle=None</em>, <em>level_shift_factor=None</em>, <em>damp_factor=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#get_fock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.get_fock" title="Permalink to this definition">¶</a></dt>
<dd><p>F = h^{core} + V^{HF}</p>
<p>Special treatment (damping, DIIS, or level shift) will be applied to the
Fock matrix if diis and cycle is specified (The two parameters are passed
to get_fock function during the SCF iteration)</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>h1e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Core hamiltonian</dd>
<dt>s1e</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Overlap matrix, for DIIS</dd>
<dt>vhf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>HF potential matrix</dd>
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Density matrix, for DIIS</dd>
<dt>cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Then present SCF iteration step, for DIIS</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an object of <code class="xref py py-attr docutils literal"><span class="pre">SCF.DIIS</span></code> class</span><dd>DIIS object to hold intermediate Fock and error vectors</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 0.</dd>
<dt>level_shift_factor</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.get_grad">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">get_grad</code><span class="sig-paren">(</span><em>mo_coeff</em>, <em>mo_occ</em>, <em>fock_ao</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Obital coefficients</dd>
<dt>mo_occ</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span><dd>Orbital occupancy</dd>
<dt>fock_ao</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Fock matrix in AO representation</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Gradients in MO representation.  It&#8217;s a num_occ*num_vir vector.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.get_hcore">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">get_hcore</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#get_hcore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.get_hcore" title="Permalink to this definition">¶</a></dt>
<dd><p>Core Hamiltonian</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_hcore</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">array([[-0.93767904, -0.59316327],</span>
<span class="go">       [-0.59316327, -0.93767904]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.get_init_guess">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">get_init_guess</code><span class="sig-paren">(</span><em>mol</em>, <em>key='minao'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#get_init_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.get_init_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate density matrix for initial guess</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>key</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>One of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.get_jk">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">get_jk</code><span class="sig-paren">(</span><em>mol</em>, <em>dm</em>, <em>hermi=1</em>, <em>vhfopt=None</em>, <em>with_j=True</em>, <em>with_k=True</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
<dt>with_j</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to compute J matrices</dd>
<dt>with_k</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to compute K matrices</dd>
<dt>omega</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Parameter of range-seperated Coulomb operator: erf( omega * r12 ) / r12.
If specified, integration are evaluated based on the long-range
part of the range-seperated Coulomb operator.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.get_occ">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">get_occ</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_energy=None</em>, <em>mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#get_occ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span><dd>Obital energies</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Obital coefficients</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 0, 2, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.get_ovlp">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">get_ovlp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#get_ovlp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.get_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlap matrix</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.get_veff">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">get_veff</code><span class="sig-paren">(</span><em>mol</em>, <em>dm</em>, <em>dm_last=None</em>, <em>vhf_last=None</em>, <em>hermi=1</em>, <em>vhfopt=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or list of ndarrays</span><dd>A density matrix or a list of density matrices</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</dd>
<dt>vhf_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The reference HF potential matrix.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="k">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf0</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">dm_last</span><span class="o">=</span><span class="n">dm0</span><span class="p">,</span> <span class="n">vhf_last</span><span class="o">=</span><span class="n">vhf0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vhf1</span><span class="p">,</span> <span class="n">vhf2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.init_guess_by_1e">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">init_guess_by_1e</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#init_guess_by_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.init_guess_by_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.init_guess_by_atom">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">init_guess_by_atom</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#init_guess_by_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.init_guess_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.init_guess_by_chkfile">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em>mol</em>, <em>chkfile_name</em>, <em>project=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal"><span class="pre">mol</span></code></p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.init_guess_by_minao">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">init_guess_by_minao</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#init_guess_by_minao"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.init_guess_by_minao" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix based on ANO basis, then project
the density matrix to the basis set defined by <code class="docutils literal"><span class="pre">mol</span></code></p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrix, 2D ndarray</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">init_guess_by_minao</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">array([[ 0.94758917,  0.09227308],</span>
<span class="go">       [ 0.09227308,  0.94758917]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.kernel">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">kernel</code><span class="sig-paren">(</span><em>mf</em>, <em>conv_tol=1e-10</em>, <em>conv_tol_grad=None</em>, <em>dump_chk=True</em>, <em>dm0=None</em>, <em>callback=None</em>, <em>conv_check=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>kernel: the SCF driver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of SCF class</span><dd><p class="first">mf object holds all parameters to control SCF.  One can modify its
member functions to change the behavior of SCF.  The member
functions which are called in kernel are</p>
<div class="last line-block">
<div class="line">mf.get_init_guess</div>
<div class="line">mf.get_hcore</div>
<div class="line">mf.get_ovlp</div>
<div class="line">mf.get_veff</div>
<div class="line">mf.get_fock</div>
<div class="line">mf.get_grad</div>
<div class="line">mf.eig</div>
<div class="line">mf.get_occ</div>
<div class="line">mf.make_rdm1</div>
<div class="line">mf.energy_tot</div>
<div class="line">mf.dump_chk</div>
</div>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.</dd>
<dt>dump_chk</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to save SCF intermediate results in the checkpoint file</dd>
<dt>dm0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>Initial guess density matrix.  If not given (the default), the kernel
takes the density matrix generated by <code class="docutils literal"><span class="pre">mf.get_init_guess</span></code>.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">A list :   scf_conv, e_tot, mo_energy, mo_coeff, mo_occ</p>
<dl class="last docutils">
<dt>scf_conv</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>True means SCF converged</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Hartree-Fock energy of last iteration</dd>
<dt>mo_energy</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D float array</span><dd>Orbital energies.  Depending the eig function provided by mf
object, the orbital energies may NOT be sorted.</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span><dd>Orbital coefficients.</dd>
<dt>mo_occ</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span><dd>Orbital occupancies.  The occupancies may NOT be sorted from large
to small.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conv</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">mo_e</span><span class="p">,</span> <span class="n">mo</span><span class="p">,</span> <span class="n">mo_occ</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">),</span> <span class="n">dm0</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;conv = </span><span class="si">%s</span><span class="s1">, E(HF) = </span><span class="si">%.12f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">conv</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
<span class="go">conv = True, E(HF) = -1.081170784378</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.level_shift">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">level_shift</code><span class="sig-paren">(</span><em>s</em>, <em>d</em>, <em>f</em>, <em>factor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#level_shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.level_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply level shift <span class="math">\(\Delta\)</span> to virtual orbitals</p>
<div class="math">
\begin{align}
  FC &amp;= SCE \\
  F &amp;= F + SC \Lambda C^\dagger S \\
  \Lambda_{ij} &amp;=
  \begin{cases}
     \delta_{ij}\Delta &amp; i \in \text{virtual} \\
     0 &amp; \text{otherwise}
  \end{cases}
\end{align}</div><dl class="docutils">
<dt>Returns:</dt>
<dd>New Fock matrix, 2D ndarray</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.make_rdm1">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>mo_coeff</em>, <em>mo_occ</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix in AO representation</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Orbital coefficients. Each column is one orbital.</dd>
<dt>mo_occ</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span><dd>Occupancy</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.mulliken_meta">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">mulliken_meta</code><span class="sig-paren">(</span><em>mol</em>, <em>dm</em>, <em>verbose=5</em>, <em>pre_orth_method='ANO'</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or 2-item list of ndarray</span><dd>Density matrix.  ROHF dm is a 2-item list of 2D array</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><p class="first">verbose : int or instance of <a class="reference internal" href="lib.html#lib.logger.Logger" title="lib.logger.Logger"><code class="xref py py-class docutils literal"><span class="pre">lib.logger.Logger</span></code></a></p>
<dl class="last docutils">
<dt>pre_orth_method</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd><p class="first">Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="last line-block">
<div class="line">&#8216;ano&#8217;   : Project GTOs to ANO basis</div>
<div class="line">&#8216;minao&#8217; : Project GTOs to MINAO basis</div>
<div class="line">&#8216;scf&#8217;   : Fraction-averaged RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">A list : pop, charges</p>
<dl class="last docutils">
<dt>pop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken population on each atomic orbitals</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken charges</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.mulliken_pop">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">mulliken_pop</code><span class="sig-paren">(</span><em>mol</em>, <em>dm</em>, <em>s=None</em>, <em>verbose=5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#mulliken_pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.mulliken_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">A list : pop, charges</p>
<dl class="last docutils">
<dt>pop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken population on each atomic orbitals</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken charges</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.mulliken_pop_meta_lowdin_ao">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">mulliken_pop_meta_lowdin_ao</code><span class="sig-paren">(</span><em>mol</em>, <em>dm</em>, <em>verbose=5</em>, <em>pre_orth_method='ANO'</em>, <em>s=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.mulliken_pop_meta_lowdin_ao" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or 2-item list of ndarray</span><dd>Density matrix.  ROHF dm is a 2-item list of 2D array</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><p class="first">verbose : int or instance of <a class="reference internal" href="lib.html#lib.logger.Logger" title="lib.logger.Logger"><code class="xref py py-class docutils literal"><span class="pre">lib.logger.Logger</span></code></a></p>
<dl class="last docutils">
<dt>pre_orth_method</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd><p class="first">Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="last line-block">
<div class="line">&#8216;ano&#8217;   : Project GTOs to ANO basis</div>
<div class="line">&#8216;minao&#8217; : Project GTOs to MINAO basis</div>
<div class="line">&#8216;scf&#8217;   : Fraction-averaged RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><p class="first">A list : pop, charges</p>
<dl class="last docutils">
<dt>pop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken population on each atomic orbitals</dd>
<dt>charges</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">nparray</span><dd>Mulliken charges</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.pack_uniq_var">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">pack_uniq_var</code><span class="sig-paren">(</span><em>x</em>, <em>mo_occ</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#pack_uniq_var"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.pack_uniq_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the unique variables from the full orbital-gradients (or
orbital-rotation) matrix</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.uniq_var_indices">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">uniq_var_indices</code><span class="sig-paren">(</span><em>mo_occ</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#uniq_var_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.uniq_var_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicies of the unique variables for the orbital-gradients (or
orbital-rotation) matrix.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf.unpack_uniq_var">
<code class="descclassname">pyscf.scf.hf.</code><code class="descname">unpack_uniq_var</code><span class="sig-paren">(</span><em>dx</em>, <em>mo_occ</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf.html#unpack_uniq_var"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf.unpack_uniq_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the full orbital-gradients (or orbital-rotation) matrix with the
unique variables.</p>
</dd></dl>

<hr class="docutils" />
<span class="target" id="module-pyscf.scf.uhf"></span><dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">pyscf.scf.uhf.</code><code class="descname">UHF</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-9</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.  Default is sqrt(conv_tol)</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>DIIS</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">DIIS class</span><dd>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code>.</span><dd>Default is the object associated to the attribute <code class="xref py py-attr docutils literal"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is inialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS informations (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 1.</dd>
<dt>diis_file: &#8216;str&#8217;</dt>
<dd>File to store DIIS vectors and error vectors.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
<dt>check_convergence</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs) =&gt; bool</span><dd>A hook for overloading convergence criteria in SCF iterations.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy :</dt>
<dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Attributes for UHF:</dt>
<dd><dl class="first last docutils">
<dt>nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(int, int)</span><dd>If given, freeze the number of (alpha,beta) electrons to the given value.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">number or two-element list</span><dd>level shift (in Eh) for alpha and beta Fock if two-element list is given.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mf</span><span class="o">.</span><span class="n">spin_square</span><span class="p">())</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
<dl class="method">
<dt>
<code class="descname">Gradients</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Non-relativistic unrestricted Hartree-Fock gradients</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">Hessian</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Non-relativistic UHF hessian</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">convert_from_</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.convert_from_"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Create UHF object based on the RHF/ROHF object</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">det_ovlp</code><span class="sig-paren">(</span><em>mo1</em>, <em>mo2</em>, <em>occ1</em>, <em>occ2</em>, <em>ovlp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.det_ovlp"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Calculate the overlap between two different determinants. It is the product
of single values of molecular orbital overlap matrix.</p>
<div class="math">
\[S_{12} = \langle \Psi_A | \Psi_B \rangle
= (\mathrm{det}\mathbf{U}) (\mathrm{det}\mathbf{V^\dagger})\prod\limits_{i=1}\limits^{2N} \lambda_{ii}\]</div>
<p>where <span class="math">\(\mathbf{U}, \mathbf{V}, \lambda\)</span> are unitary matrices and single
values generated by single value decomposition(SVD) of the overlap matrix
<span class="math">\(\mathbf{O}\)</span> which is the overlap matrix of two sets of molecular orbitals:</p>
<div class="math">
\[\mathbf{U}^\dagger \mathbf{O} \mathbf{V} = \mathbf{\Lambda}\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo1, mo2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarrays</span><dd>Molecualr orbital coefficients</dd>
<dt>occ1, occ2: 2D ndarrays</dt>
<dd>occupation numbers</dd>
</dl>
</dd>
<dt>Return:</dt>
<dd><dl class="first last docutils">
<dt>A list: the product of single values: float</dt>
<dd>x_a, x_b: 1D ndarrays
<span class="math">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>
They are used to calculate asymmetric density matrix</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">energy_elec</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>h1e=None</em>, <em>vhf=None</em><span class="sig-paren">)</span></dt>
<dd><p>Electronic energy of Unrestricted Hartree-Fock</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Hartree-Fock electronic energy and the 2-electron part contribution</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_jk</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>hermi=1</em>, <em>with_j=True</em>, <em>with_k=True</em>, <em>omega=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.get_jk"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Coulomb (J) and exchange (K)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of 2D arrays or a list of 3D arrays</span><dd>(alpha_dm, beta_dm) or (alpha_dms, beta_dms)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_veff</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.get_veff"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Unrestricted Hartree-Fock potential matrix of alpha and beta spins,
for the given density matrix</p>
<div class="math">
\[\begin{split}V_{ij}^\alpha &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\alpha \\
V_{ij}^\beta  &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\beta\end{split}\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of ndarrays</span><dd>A list of density matrices, stored as (alpha,alpha,...,beta,beta,...)</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The density matrix baseline.  When it is not 0, this function computes
the increment of HF potential w.r.t. the reference HF potential matrix.</dd>
<dt>vhf_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The reference HF potential matrix.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><span class="math">\(V_{hf} = (V^\alpha, V^\beta)\)</span>.  <span class="math">\(V^\alpha\)</span> (and <span class="math">\(V^\beta\)</span>)
can be a list matrices, corresponding to the input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dmsa</span><span class="p">,</span><span class="n">dmsb</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="p">,</span> <span class="n">vhfb</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">uhf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfb</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">init_guess_by_minao</code><span class="sig-paren">(</span><em>mol=None</em>, <em>breaksym=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.init_guess_by_minao"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Initial guess in terms of the overlap to minimal basis.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">make_asym_dm</code><span class="sig-paren">(</span><em>mo1</em>, <em>mo2</em>, <em>occ1</em>, <em>occ2</em>, <em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.make_asym_dm"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>One-particle asymmetric density matrix</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo1, mo2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarrays</span><dd>Molecualr orbital coefficients</dd>
<dt>occ1, occ2: 2D ndarrays</dt>
<dd>Occupation numbers</dd>
<dt>x: 2D ndarrays</dt>
<dd><span class="math">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>.
See also <a class="reference internal" href="#pyscf.scf.uhf.det_ovlp" title="pyscf.scf.uhf.det_ovlp"><code class="xref py py-func docutils literal"><span class="pre">det_ovlp()</span></code></a></dd>
</dl>
</dd>
<dt>Return:</dt>
<dd>A list of 2D ndarrays for alpha and beta spin</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.3&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.4&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">intor_cross</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">det</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">det_ovlp</span><span class="p">(</span><span class="n">mf1</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adm</span> <span class="o">=</span> <span class="n">make_asym_dm</span><span class="p">(</span><span class="n">mf1</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adm</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 19, 19)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>mo_occ=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.make_rdm1"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>One-particle density matrix</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A list of 2D ndarrays for alpha and beta spins</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">spin_square</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.spin_square"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Spin square and multiplicity of UHF determinant</p>
<div class="math">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>There are two possibilities for <span class="math">\(S_+ S_-\)</span></dt>
<dd><ol class="first arabic simple">
<li>same electron <span class="math">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</li>
</ol>
<div class="math">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="last math">
\[\langle S_+ S_- \rangle = \langle ij|s_+ s_-|ij\rangle
                        - \langle ij|s_+ s_-|ji\rangle
                        = -\langle i^\alpha|j^\beta\rangle
                           \langle j^\beta|i^\alpha\rangle\]</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Similarly, for <span class="math">\(S_- S_+\)</span></dt>
<dd><ol class="first arabic simple">
<li>same electron</li>
</ol>
<div class="math">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li>different electrons</li>
</ol>
<div class="last math">
\[\langle S_- S_+ \rangle = -\langle i^\beta|j^\alpha\rangle
                           \langle j^\alpha|i^\beta\rangle\]</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>For <span class="math">\(S_z^2\)</span></dt>
<dd><ol class="first arabic simple">
<li>same electron</li>
</ol>
<div class="math">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li>different electrons</li>
</ol>
<div class="last math">
\[\begin{split}&amp;\frac{1}{2}\sum_{ij}(\langle ij|2s_{z1}s_{z2}|ij\rangle
                     -\langle ij|2s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}(n_\alpha^2 - n_\alpha n_\beta - n_\beta n_\alpha + n_\beta^2)
 -\frac{1}{4}(n_\alpha + n_\beta) \\
&amp;=\frac{1}{4}((n_\alpha-n_\beta)^2 - (n_\alpha+n_\beta))\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<p>In total</p>
<div class="math">
\[\begin{split}\langle S^2\rangle &amp;= \frac{1}{2}
(n_\alpha-\sum_{ij}\langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle
+n_\beta -\sum_{ij}\langle i^\beta|j^\alpha\rangle\langle j^\alpha|i^\beta\rangle)
+ \frac{1}{4}(n_\alpha-n_\beta)^2 \\\end{split}\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of 2 ndarrays</span><dd>Occupied alpha and occupied beta orbitals</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>s</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>AO overlap</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">stability</code><span class="sig-paren">(</span><em>internal=True</em>, <em>external=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#UHF.stability"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Stability analysis for RHF/RKS method.</p>
<p>See also pyscf.scf.stability.uhf_stability function.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mf : UHF or UKS object</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>internal</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Internal stability, within the UHF space.</dd>
<dt>external</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>External stability. Including the UHF -&gt; GHF and real -&gt; complex
stability analysis.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>New orbitals that are more close to the stable condition.  The return
value includes two set of orbitals.  The first corresponds to the
internal stablity and the second corresponds to the external stability.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.analyze">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">analyze</code><span class="sig-paren">(</span><em>mf</em>, <em>verbose=5</em>, <em>with_meta_lowdin=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Dipole moment</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.canonicalize">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#canonicalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.det_ovlp">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">det_ovlp</code><span class="sig-paren">(</span><em>mo1</em>, <em>mo2</em>, <em>occ1</em>, <em>occ2</em>, <em>ovlp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#det_ovlp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.det_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the overlap between two different determinants. It is the product
of single values of molecular orbital overlap matrix.</p>
<div class="math">
\[S_{12} = \langle \Psi_A | \Psi_B \rangle
= (\mathrm{det}\mathbf{U}) (\mathrm{det}\mathbf{V^\dagger})\prod\limits_{i=1}\limits^{2N} \lambda_{ii}\]</div>
<p>where <span class="math">\(\mathbf{U}, \mathbf{V}, \lambda\)</span> are unitary matrices and single
values generated by single value decomposition(SVD) of the overlap matrix
<span class="math">\(\mathbf{O}\)</span> which is the overlap matrix of two sets of molecular orbitals:</p>
<div class="math">
\[\mathbf{U}^\dagger \mathbf{O} \mathbf{V} = \mathbf{\Lambda}\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo1, mo2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarrays</span><dd>Molecualr orbital coefficients</dd>
<dt>occ1, occ2: 2D ndarrays</dt>
<dd>occupation numbers</dd>
</dl>
</dd>
<dt>Return:</dt>
<dd><dl class="first last docutils">
<dt>A list: the product of single values: float</dt>
<dd>x_a, x_b: 1D ndarrays
<span class="math">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>
They are used to calculate asymmetric density matrix</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.energy_elec">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">energy_elec</code><span class="sig-paren">(</span><em>mf</em>, <em>dm=None</em>, <em>h1e=None</em>, <em>vhf=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#energy_elec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Electronic energy of Unrestricted Hartree-Fock</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Hartree-Fock electronic energy and the 2-electron part contribution</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.get_grad">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">get_grad</code><span class="sig-paren">(</span><em>mo_coeff</em>, <em>mo_occ</em>, <em>fock_ao</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>UHF Gradients</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.get_veff">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">get_veff</code><span class="sig-paren">(</span><em>mol</em>, <em>dm</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em>, <em>vhfopt=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Unrestricted Hartree-Fock potential matrix of alpha and beta spins,
for the given density matrix</p>
<div class="math">
\[\begin{split}V_{ij}^\alpha &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\alpha \\
V_{ij}^\beta  &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\beta\end{split}\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">mol : an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></p>
<dl class="last docutils">
<dt>dm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of ndarrays</span><dd>A list of density matrices, stored as (alpha,alpha,...,beta,beta,...)</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dm_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The density matrix baseline.  When it is not 0, this function computes
the increment of HF potential w.r.t. the reference HF potential matrix.</dd>
<dt>vhf_last</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or a list of ndarrays or 0</span><dd>The reference HF potential matrix.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Whether J, K matrix is hermitian</p>
<div class="last line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt>
<dd>A class which holds precomputed quantities to optimize the
computation of J, K matrices</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><span class="math">\(V_{hf} = (V^\alpha, V^\beta)\)</span>.  <span class="math">\(V^\alpha\)</span> (and <span class="math">\(V^\beta\)</span>)
can be a list matrices, corresponding to the input density matrices.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dmsa</span><span class="p">,</span><span class="n">dmsb</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="p">,</span> <span class="n">vhfb</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">uhf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfb</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.init_guess_by_chkfile">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em>mol</em>, <em>chkfile_name</em>, <em>project=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read SCF chkfile and make the density matrix for UHF initial guess.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>project</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">None or bool</span><dd><p class="first">Whether to project chkfile&#8217;s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to swith off project.</p>
<p class="last">If project is set to None, the projection is only applied when the
basis sets of the chkfile&#8217;s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.init_guess_by_minao">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">init_guess_by_minao</code><span class="sig-paren">(</span><em>mol</em>, <em>breaksym=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#init_guess_by_minao"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.init_guess_by_minao" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix based on ANO basis, then project
the density matrix to the basis set defined by <code class="docutils literal"><span class="pre">mol</span></code></p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Density matrices, a list of 2D ndarrays for alpha and beta spins</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.make_asym_dm">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">make_asym_dm</code><span class="sig-paren">(</span><em>mo1</em>, <em>mo2</em>, <em>occ1</em>, <em>occ2</em>, <em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#make_asym_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.make_asym_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle asymmetric density matrix</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo1, mo2</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarrays</span><dd>Molecualr orbital coefficients</dd>
<dt>occ1, occ2: 2D ndarrays</dt>
<dd>Occupation numbers</dd>
<dt>x: 2D ndarrays</dt>
<dd><span class="math">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>.
See also <a class="reference internal" href="#pyscf.scf.uhf.det_ovlp" title="pyscf.scf.uhf.det_ovlp"><code class="xref py py-func docutils literal"><span class="pre">det_ovlp()</span></code></a></dd>
</dl>
</dd>
<dt>Return:</dt>
<dd>A list of 2D ndarrays for alpha and beta spin</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.3&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.4&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">intor_cross</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">det</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">det_ovlp</span><span class="p">(</span><span class="n">mf1</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adm</span> <span class="o">=</span> <span class="n">make_asym_dm</span><span class="p">(</span><span class="n">mf1</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adm</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 19, 19)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.make_rdm1">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>mo_coeff</em>, <em>mo_occ</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A list of 2D ndarrays for alpha and beta spins</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.mulliken_meta">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">mulliken_meta</code><span class="sig-paren">(</span><em>mol</em>, <em>dm_ao</em>, <em>verbose=5</em>, <em>pre_orth_method='ANO'</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.mulliken_pop">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">mulliken_pop</code><span class="sig-paren">(</span><em>mol</em>, <em>dm</em>, <em>s=None</em>, <em>verbose=5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#mulliken_pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.mulliken_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.mulliken_pop_meta_lowdin_ao">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">mulliken_pop_meta_lowdin_ao</code><span class="sig-paren">(</span><em>mol</em>, <em>dm_ao</em>, <em>verbose=5</em>, <em>pre_orth_method='ANO'</em>, <em>s=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.mulliken_pop_meta_lowdin_ao" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf.spin_square">
<code class="descclassname">pyscf.scf.uhf.</code><code class="descname">spin_square</code><span class="sig-paren">(</span><em>mo</em>, <em>s=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf.html#spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square and multiplicity of UHF determinant</p>
<div class="math">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>There are two possibilities for <span class="math">\(S_+ S_-\)</span></dt>
<dd><ol class="first arabic simple">
<li>same electron <span class="math">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</li>
</ol>
<div class="math">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="last math">
\[\langle S_+ S_- \rangle = \langle ij|s_+ s_-|ij\rangle
                        - \langle ij|s_+ s_-|ji\rangle
                        = -\langle i^\alpha|j^\beta\rangle
                           \langle j^\beta|i^\alpha\rangle\]</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Similarly, for <span class="math">\(S_- S_+\)</span></dt>
<dd><ol class="first arabic simple">
<li>same electron</li>
</ol>
<div class="math">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li>different electrons</li>
</ol>
<div class="last math">
\[\langle S_- S_+ \rangle = -\langle i^\beta|j^\alpha\rangle
                           \langle j^\alpha|i^\beta\rangle\]</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>For <span class="math">\(S_z^2\)</span></dt>
<dd><ol class="first arabic simple">
<li>same electron</li>
</ol>
<div class="math">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li>different electrons</li>
</ol>
<div class="last math">
\[\begin{split}&amp;\frac{1}{2}\sum_{ij}(\langle ij|2s_{z1}s_{z2}|ij\rangle
                     -\langle ij|2s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}(n_\alpha^2 - n_\alpha n_\beta - n_\beta n_\alpha + n_\beta^2)
 -\frac{1}{4}(n_\alpha + n_\beta) \\
&amp;=\frac{1}{4}((n_\alpha-n_\beta)^2 - (n_\alpha+n_\beta))\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<p>In total</p>
<div class="math">
\[\begin{split}\langle S^2\rangle &amp;= \frac{1}{2}
(n_\alpha-\sum_{ij}\langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle
+n_\beta -\sum_{ij}\langle i^\beta|j^\alpha\rangle\langle j^\alpha|i^\beta\rangle)
+ \frac{1}{4}(n_\alpha-n_\beta)^2 \\\end{split}\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of 2 ndarrays</span><dd>Occupied alpha and occupied beta orbitals</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>s</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>AO overlap</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<span class="target" id="module-pyscf.scf.hf_symm"></span><p>Non-relativistic restricted Hartree-Fock with point group symmetry.</p>
<p>The symmetry are not handled in a separate data structure.  Note that during
the SCF iteration,  the orbitals are grouped in terms of symmetry irreps.
But the orbitals in the result are sorted based on the orbital energies.
Function symm.label_orb_symm can be used to detect the symmetry of the
molecular orbitals.</p>
<dl class="attribute">
<dt id="pyscf.scf.hf_symm.RHF">
<code class="descclassname">pyscf.scf.hf_symm.</code><code class="descname">RHF</code><a class="headerlink" href="#pyscf.scf.hf_symm.RHF" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.hf_symm.SymAdaptedRHF" title="pyscf.scf.hf_symm.SymAdaptedRHF"><code class="xref py py-class docutils literal"><span class="pre">SymAdaptedRHF</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="pyscf.scf.hf_symm.ROHF">
<code class="descclassname">pyscf.scf.hf_symm.</code><code class="descname">ROHF</code><a class="headerlink" href="#pyscf.scf.hf_symm.ROHF" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.hf_symm.SymAdaptedROHF" title="pyscf.scf.hf_symm.SymAdaptedROHF"><code class="xref py py-class docutils literal"><span class="pre">SymAdaptedROHF</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pyscf.scf.hf_symm.SymAdaptedRHF">
<em class="property">class </em><code class="descclassname">pyscf.scf.hf_symm.</code><code class="descname">SymAdaptedRHF</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf_symm.html#SymAdaptedRHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-9</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.  Default is sqrt(conv_tol)</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>DIIS</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">DIIS class</span><dd>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code>.</span><dd>Default is the object associated to the attribute <code class="xref py py-attr docutils literal"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is inialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS informations (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 1.</dd>
<dt>diis_file: &#8216;str&#8217;</dt>
<dd>File to store DIIS vectors and error vectors.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
<dt>check_convergence</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs) =&gt; bool</span><dd>A hook for overloading convergence criteria in SCF iterations.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy :</dt>
<dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Attributes for symmetry allowed RHF:</dt>
<dd><dl class="first last docutils">
<dt>irrep_nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>Specify the number of electrons for particular irrep {&#8216;ir_name&#8217;:int,...}.
For the irreps not listed in this dict, the program will choose the
occupancy based on the orbital energies.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-76.016789472074251</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">()</span>
<span class="go">{&#39;A1&#39;: 6, &#39;A2&#39;: 0, &#39;B1&#39;: 2, &#39;B2&#39;: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">irrep_nelec</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A2&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-72.768201804695622</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">()</span>
<span class="go">{&#39;A1&#39;: 6, &#39;A2&#39;: 2, &#39;B1&#39;: 2, &#39;B2&#39;: 0}</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.scf.hf_symm.SymAdaptedRHF.analyze">
<code class="descname">analyze</code><span class="sig-paren">(</span><em>verbose=None</em>, <em>with_meta_lowdin=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf_symm.html#SymAdaptedRHF.analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Occupancy for each irreps; Mulliken population analysis</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf_symm.SymAdaptedRHF.canonicalize">
<code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix in occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf_symm.SymAdaptedRHF.eig">
<code class="descname">eig</code><span class="sig-paren">(</span><em>mf</em>, <em>h</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve generalized eigenvalue problem, for each irrep.  The
eigenvalues and eigenvectors are not sorted to ascending order.
Instead, they are grouped based on irreps.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf_symm.SymAdaptedRHF.get_irrep_nelec">
<code class="descname">get_irrep_nelec</code><span class="sig-paren">(</span><em>mol=None</em>, <em>mo_coeff=None</em>, <em>mo_occ=None</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf_symm.html#SymAdaptedRHF.get_irrep_nelec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.get_irrep_nelec" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron numbers for each irreducible representation.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></span><dd>To provide irrep_id, and spin-adapted basis</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Regular orbital coefficients, without grouping for irreps</dd>
<dt>mo_occ</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span><dd>Regular occupancy, without grouping for irreps</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>irrep_nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>The number of electrons for each irrep {&#8216;ir_name&#8217;:int,...}.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-76.016789472074251</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf_symm</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">)</span>
<span class="go">{&#39;A1&#39;: 6, &#39;A2&#39;: 0, &#39;B1&#39;: 2, &#39;B2&#39;: 2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf_symm.SymAdaptedRHF.get_occ">
<code class="descname">get_occ</code><span class="sig-paren">(</span><em>mo_energy=None</em>, <em>mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf_symm.html#SymAdaptedRHF.get_occ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>We assumed mo_energy are grouped by symmetry irreps, (see function
self.eig). The orbitals are sorted after SCF.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyscf.scf.hf_symm.SymAdaptedROHF">
<em class="property">class </em><code class="descclassname">pyscf.scf.hf_symm.</code><code class="descname">SymAdaptedROHF</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-9</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.  Default is sqrt(conv_tol)</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>DIIS</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">DIIS class</span><dd>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code>.</span><dd>Default is the object associated to the attribute <code class="xref py py-attr docutils literal"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is inialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS informations (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 1.</dd>
<dt>diis_file: &#8216;str&#8217;</dt>
<dd>File to store DIIS vectors and error vectors.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
<dt>check_convergence</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs) =&gt; bool</span><dd>A hook for overloading convergence criteria in SCF iterations.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy :</dt>
<dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Attributes for symmetry allowed ROHF:</dt>
<dd><dl class="first last docutils">
<dt>irrep_nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>Specify the number of alpha/beta electrons for particular irrep
{&#8216;ir_name&#8217;:(int,int), ...}.
For the irreps not listed in these dicts, the program will choose the
occupancy based on the orbital energies.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-75.619358861084052</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">()</span>
<span class="go">{&#39;A1&#39;: (3, 3), &#39;A2&#39;: (0, 0), &#39;B1&#39;: (1, 1), &#39;B2&#39;: (1, 0)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">irrep_nelec</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;B1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-75.425669486776457</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">()</span>
<span class="go">{&#39;A1&#39;: (3, 3), &#39;A2&#39;: (0, 0), &#39;B1&#39;: (1, 0), &#39;B2&#39;: (1, 1)}</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.scf.hf_symm.SymAdaptedROHF.canonicalize">
<code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF.canonicalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix in occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.hf_symm.SymAdaptedROHF.eig">
<code class="descname">eig</code><span class="sig-paren">(</span><em>fock</em>, <em>s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF.eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve generalized eigenvalue problem, for each irrep.  The
eigenvalues and eigenvectors are not sorted to ascending order.
Instead, they are grouped based on irreps.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf_symm.analyze">
<code class="descclassname">pyscf.scf.hf_symm.</code><code class="descname">analyze</code><span class="sig-paren">(</span><em>mf</em>, <em>verbose=5</em>, <em>with_meta_lowdin=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf_symm.html#analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf_symm.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Occupancy for each irreps; Mulliken population analysis</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf_symm.canonicalize">
<code class="descclassname">pyscf.scf.hf_symm.</code><code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf_symm.html#canonicalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf_symm.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix in occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf_symm.eig">
<code class="descclassname">pyscf.scf.hf_symm.</code><code class="descname">eig</code><span class="sig-paren">(</span><em>mf</em>, <em>h</em>, <em>s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf_symm.html#eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf_symm.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve generalized eigenvalue problem, for each irrep.  The
eigenvalues and eigenvectors are not sorted to ascending order.
Instead, they are grouped based on irreps.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf_symm.get_irrep_nelec">
<code class="descclassname">pyscf.scf.hf_symm.</code><code class="descname">get_irrep_nelec</code><span class="sig-paren">(</span><em>mol</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf_symm.html#get_irrep_nelec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf_symm.get_irrep_nelec" title="Permalink to this definition">¶</a></dt>
<dd><p>Electron numbers for each irreducible representation.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></span><dd>To provide irrep_id, and spin-adapted basis</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D ndarray</span><dd>Regular orbital coefficients, without grouping for irreps</dd>
<dt>mo_occ</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray</span><dd>Regular occupancy, without grouping for irreps</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>irrep_nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>The number of electrons for each irrep {&#8216;ir_name&#8217;:int,...}.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-76.016789472074251</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf_symm</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">)</span>
<span class="go">{&#39;A1&#39;: 6, &#39;A2&#39;: 0, &#39;B1&#39;: 2, &#39;B2&#39;: 2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.hf_symm.so2ao_mo_coeff">
<code class="descclassname">pyscf.scf.hf_symm.</code><code class="descname">so2ao_mo_coeff</code><span class="sig-paren">(</span><em>so</em>, <em>irrep_mo_coeff</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/hf_symm.html#so2ao_mo_coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.hf_symm.so2ao_mo_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfer the basis of MO coefficients, from spin-adapted basis to AO basis</p>
</dd></dl>

<hr class="docutils" />
<span class="target" id="module-pyscf.scf.uhf_symm"></span><p>Non-relativistic unrestricted Hartree-Fock with point group symmetry.</p>
<dl class="class">
<dt id="pyscf.scf.uhf_symm.SymAdaptedUHF">
<em class="property">class </em><code class="descclassname">pyscf.scf.uhf_symm.</code><code class="descname">SymAdaptedUHF</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf_symm.html#SymAdaptedUHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-9</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.  Default is sqrt(conv_tol)</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>DIIS</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">DIIS class</span><dd>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code>.</span><dd>Default is the object associated to the attribute <code class="xref py py-attr docutils literal"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is inialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS informations (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 1.</dd>
<dt>diis_file: &#8216;str&#8217;</dt>
<dd>File to store DIIS vectors and error vectors.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
<dt>check_convergence</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs) =&gt; bool</span><dd>A hook for overloading convergence criteria in SCF iterations.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy :</dt>
<dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Attributes for UHF:</dt>
<dd><dl class="first last docutils">
<dt>nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">(int, int)</span><dd>If given, freeze the number of (alpha,beta) electrons to the given value.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">number or two-element list</span><dd>level shift (in Eh) for alpha and beta Fock if two-element list is given.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mf</span><span class="o">.</span><span class="n">spin_square</span><span class="p">())</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Attributes for symmetry allowed UHF:</dt>
<dd><dl class="first last docutils">
<dt>irrep_nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>Specify the number of alpha/beta electrons for particular irrep
{&#8216;ir_name&#8217;:(int,int), ...}.
For the irreps not listed in these dicts, the program will choose the
occupancy based on the orbital energies.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-75.623975516256692</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">()</span>
<span class="go">{&#39;A1&#39;: (3, 3), &#39;A2&#39;: (0, 0), &#39;B1&#39;: (1, 1), &#39;B2&#39;: (1, 0)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">irrep_nelec</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;B1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-75.429189192031131</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">()</span>
<span class="go">{&#39;A1&#39;: (3, 3), &#39;A2&#39;: (0, 0), &#39;B1&#39;: (1, 0), &#39;B2&#39;: (1, 1)}</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.scf.uhf_symm.SymAdaptedUHF.canonicalize">
<code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix in occupied, virtual
subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf_symm.SymAdaptedUHF.get_irrep_nelec">
<code class="descname">get_irrep_nelec</code><span class="sig-paren">(</span><em>mol=None</em>, <em>mo_coeff=None</em>, <em>mo_occ=None</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf_symm.html#SymAdaptedUHF.get_irrep_nelec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.get_irrep_nelec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha/beta electron numbers for each irreducible representation.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></span><dd>To provide irrep_id, and spin-adapted basis</dd>
<dt>mo_occ</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of 1D ndarray</span><dd>Regular occupancy, without grouping for irreps</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of 2D ndarray</span><dd>Regular orbital coefficients, without grouping for irreps</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>irrep_nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>The number of alpha/beta electrons for each irrep {&#8216;ir_name&#8217;:(int,int), ...}.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-75.623975516256721</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">uhf_symm</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">)</span>
<span class="go">{&#39;A1&#39;: (3, 3), &#39;A2&#39;: (0, 0), &#39;B1&#39;: (1, 1), &#39;B2&#39;: (1, 0)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.uhf_symm.SymAdaptedUHF.get_occ">
<code class="descname">get_occ</code><span class="sig-paren">(</span><em>mo_energy=None</em>, <em>mo_coeff=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf_symm.html#SymAdaptedUHF.get_occ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>We assumed mo_energy are grouped by symmetry irreps, (see function
self.eig). The orbitals are sorted after SCF.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pyscf.scf.uhf_symm.UHF">
<code class="descclassname">pyscf.scf.uhf_symm.</code><code class="descname">UHF</code><a class="headerlink" href="#pyscf.scf.uhf_symm.UHF" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.uhf_symm.SymAdaptedUHF" title="pyscf.scf.uhf_symm.SymAdaptedUHF"><code class="xref py py-class docutils literal"><span class="pre">SymAdaptedUHF</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf_symm.canonicalize">
<code class="descclassname">pyscf.scf.uhf_symm.</code><code class="descname">canonicalize</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>fock=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf_symm.html#canonicalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix in occupied, virtual
subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.uhf_symm.get_irrep_nelec">
<code class="descclassname">pyscf.scf.uhf_symm.</code><code class="descname">get_irrep_nelec</code><span class="sig-paren">(</span><em>mol</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/uhf_symm.html#get_irrep_nelec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.get_irrep_nelec" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha/beta electron numbers for each irreducible representation.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></span><dd>To provide irrep_id, and spin-adapted basis</dd>
<dt>mo_occ</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of 1D ndarray</span><dd>Regular occupancy, without grouping for irreps</dd>
<dt>mo_coeff</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of 2D ndarray</span><dd>Regular orbital coefficients, without grouping for irreps</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>irrep_nelec</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>The number of alpha/beta electrons for each irrep {&#8216;ir_name&#8217;:(int,int), ...}.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-75.623975516256721</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">uhf_symm</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">)</span>
<span class="go">{&#39;A1&#39;: (3, 3), &#39;A2&#39;: (0, 0), &#39;B1&#39;: (1, 1), &#39;B2&#39;: (1, 0)}</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-pyscf.scf.dhf">
<span id="relativistic-hartree-fock"></span><h3>6.5.3. Relativistic Hartree-Fock<a class="headerlink" href="#module-pyscf.scf.dhf" title="Permalink to this headline">¶</a></h3>
<p>Dirac Hartree-Fock</p>
<dl class="attribute">
<dt id="pyscf.scf.dhf.DHF">
<code class="descclassname">pyscf.scf.dhf.</code><code class="descname">DHF</code><a class="headerlink" href="#pyscf.scf.dhf.DHF" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.dhf.UHF" title="pyscf.scf.dhf.UHF"><code class="xref py py-class docutils literal"><span class="pre">UHF</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pyscf.scf.dhf.RHF">
<em class="property">class </em><code class="descclassname">pyscf.scf.dhf.</code><code class="descname">RHF</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#RHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.RHF" title="Permalink to this definition">¶</a></dt>
<dd><p>Dirac-RHF</p>
<dl class="method">
<dt id="pyscf.scf.dhf.RHF.make_rdm1">
<code class="descname">make_rdm1</code><span class="sig-paren">(</span><em>mo_coeff=None</em>, <em>mo_occ=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#RHF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.RHF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>D/2 = psi_i^dagpsi_i = psi_{Ti}^dagpsi_{Ti}
D(UHF) = psi_i^dagpsi_i + psi_{Ti}^dagpsi_{Ti}
RHF average the density of spin up and spin down:
D(RHF) = (D(UHF) + T[D(UHF)])/2</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyscf.scf.dhf.UHF">
<em class="property">class </em><code class="descclassname">pyscf.scf.dhf.</code><code class="descname">UHF</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#UHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.UHF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  Default value equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>chkfile</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</dd>
<dt>conv_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>converge threshold.  Default is 1e-9</dd>
<dt>conv_tol_grad</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>gradients converge threshold.  Default is sqrt(conv_tol)</dd>
<dt>max_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>max number of iterations.  Default is 50</dd>
<dt>init_guess</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>initial guess method.  It can be one of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.
Default is &#8216;minao&#8217;</dd>
<dt>DIIS</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">DIIS class</span><dd>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</dd>
<dt>diis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal"><span class="pre">scf.diis</span></code>.</span><dd>Default is the object associated to the attribute <code class="xref py py-attr docutils literal"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is inialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS informations (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</dd>
<dt>diis_space</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</dd>
<dt>diis_start_cycle</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>The step to start DIIS.  Default is 1.</dd>
<dt>diis_file: &#8216;str&#8217;</dt>
<dd>File to store DIIS vectors and error vectors.</dd>
<dt>level_shift</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float or int</span><dd>Level shift (in AU) for virtual space.  Default is 0.</dd>
<dt>direct_scf</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Direct SCF is used by default.</dd>
<dt>direct_scf_tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Direct SCF cutoff threshold.  Default is 1e-13.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs_dict) =&gt; None</span><dd>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
envrionment.</dd>
<dt>conv_check</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>An extra cycle to check convergence after SCF iterations.</dd>
<dt>check_convergence</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">function(envs) =&gt; bool</span><dd>A hook for overloading convergence criteria in SCF iterations.</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="docutils">
<dt>converged</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>SCF converged or not</dd>
<dt>e_tot</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>Total HF energy (electronic energy plus nuclear repulsion)</dd>
<dt>mo_energy :</dt>
<dd>Orbital energies</dd>
<dt>mo_occ</dt>
<dd>Orbital occupancy</dd>
<dt>mo_coeff</dt>
<dd>Orbital coefficients</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="o">.</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Attributes for Dirac-Hartree-Fock</dt>
<dd><dl class="first last docutils">
<dt>with_ssss</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool, for Dirac-Hartree-Fock only</span><dd>If False, ignore small component integrals (SS|SS).  Default is True.</dd>
<dt>with_gaunt</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool, for Dirac-Hartree-Fock only</span><dd>Default is False.</dd>
<dt>with_breit</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool, for Dirac-Hartree-Fock only</span><dd>Gaunt + gauge term.  Default is False.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e0</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">DHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Relativistic effects = </span><span class="si">%.12f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e1</span><span class="o">-</span><span class="n">e0</span><span class="p">))</span>
<span class="go">Relativistic effects = -0.000008854205</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.scf.dhf.UHF.Gradients">
<code class="descname">Gradients</code><span class="sig-paren">(</span><em>obj</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.UHF.Gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>Unrestricted Dirac-Hartree-Fock gradients</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.dhf.UHF.dip_moment">
<code class="descname">dip_moment</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#UHF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.UHF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment calculation</p>
<div class="math">
\[\begin{split}\mu_x = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|x|\mu) + \sum_A Q_A X_A\\
\mu_y = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|y|\mu) + \sum_A Q_A Y_A\\
\mu_z = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|z|\mu) + \sum_A Q_A Z_A\end{split}\]</div>
<p>where <span class="math">\(\mu_x, \mu_y, \mu_z\)</span> are the x, y and z components of dipole
moment</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mol: an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code>
dm : a 2D ndarrays density matrices</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z component</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.dhf.UHF.get_veff">
<code class="descname">get_veff</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>dm_last=0</em>, <em>vhf_last=0</em>, <em>hermi=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#UHF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.UHF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Dirac-Coulomb</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.dhf.UHF.init_guess_by_minao">
<code class="descname">init_guess_by_minao</code><span class="sig-paren">(</span><em>mol=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#UHF.init_guess_by_minao"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.UHF.init_guess_by_minao" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess in terms of the overlap to minimal basis.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.dhf.UHF.mulliken_pop">
<code class="descname">mulliken_pop</code><span class="sig-paren">(</span><em>mol=None</em>, <em>dm=None</em>, <em>s=None</em>, <em>verbose=5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#UHF.mulliken_pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.UHF.mulliken_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math">
\[\delta_i = \sum_j M_{ij}\]</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.scf.dhf.UHF.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#UHF.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.UHF.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset mol and clean up relevant attributes for scanner mode</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.scf.dhf.dip_moment">
<code class="descclassname">pyscf.scf.dhf.</code><code class="descname">dip_moment</code><span class="sig-paren">(</span><em>mol</em>, <em>dm</em>, <em>unit='Debye'</em>, <em>verbose=3</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment calculation</p>
<div class="math">
\[\begin{split}\mu_x = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|x|\mu) + \sum_A Q_A X_A\\
\mu_y = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|y|\mu) + \sum_A Q_A Y_A\\
\mu_z = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|z|\mu) + \sum_A Q_A Z_A\end{split}\]</div>
<p>where <span class="math">\(\mu_x, \mu_y, \mu_z\)</span> are the x, y and z components of dipole
moment</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mol: an instance of <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code>
dm : a 2D ndarrays density matrices</dd>
<dt>Return:</dt>
<dd>A list: the dipole moment on x, y and z component</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.dhf.get_grad">
<code class="descclassname">pyscf.scf.dhf.</code><code class="descname">get_grad</code><span class="sig-paren">(</span><em>mo_coeff</em>, <em>mo_occ</em>, <em>fock_ao</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>DHF Gradients</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.dhf.get_init_guess">
<code class="descclassname">pyscf.scf.dhf.</code><code class="descname">get_init_guess</code><span class="sig-paren">(</span><em>mol</em>, <em>key='minao'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#get_init_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.get_init_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate density matrix for initial guess</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>key</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>One of &#8216;minao&#8217;, &#8216;atom&#8217;, &#8216;hcore&#8217;, &#8216;1e&#8217;, &#8216;chkfile&#8217;.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.dhf.init_guess_by_1e">
<code class="descclassname">pyscf.scf.dhf.</code><code class="descname">init_guess_by_1e</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#init_guess_by_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.init_guess_by_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess from one electron system.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.dhf.init_guess_by_atom">
<code class="descclassname">pyscf.scf.dhf.</code><code class="descname">init_guess_by_atom</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#init_guess_by_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.init_guess_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess from atom calculation.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.dhf.init_guess_by_chkfile">
<code class="descclassname">pyscf.scf.dhf.</code><code class="descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em>mol</em>, <em>chkfile_name</em>, <em>project=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read SCF chkfile and make the density matrix for 4C-DHF initial guess.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>project</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">None or bool</span><dd><p class="first">Whether to project chkfile&#8217;s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to swith off project.</p>
<p class="last">If project is set to None, the projection is only applied when the
basis sets of the chkfile&#8217;s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.dhf.init_guess_by_minao">
<code class="descclassname">pyscf.scf.dhf.</code><code class="descname">init_guess_by_minao</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#init_guess_by_minao"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.init_guess_by_minao" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess in terms of the overlap to minimal basis.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.dhf.kernel">
<code class="descclassname">pyscf.scf.dhf.</code><code class="descname">kernel</code><span class="sig-paren">(</span><em>mf</em>, <em>conv_tol=1e-09</em>, <em>conv_tol_grad=None</em>, <em>dump_chk=True</em>, <em>dm0=None</em>, <em>callback=None</em>, <em>conv_check=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>the modified SCF kernel for Dirac-Hartree-Fock.  In this kernel, the
SCF is carried out in three steps.  First the 2-electron part is
approximated by large component integrals (LL|LL); Next, (SS|LL) the
interaction between large and small components are added; Finally,
converge the SCF with the small component contributions (SS|SS)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.dhf.mulliken_pop">
<code class="descclassname">pyscf.scf.dhf.</code><code class="descname">mulliken_pop</code><span class="sig-paren">(</span><em>mol</em>, <em>dm</em>, <em>s=None</em>, <em>verbose=5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#mulliken_pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.mulliken_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math">
\[\delta_i = \sum_j M_{ij}\]</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.dhf.time_reversal_matrix">
<code class="descclassname">pyscf.scf.dhf.</code><code class="descname">time_reversal_matrix</code><span class="sig-paren">(</span><em>mol</em>, <em>mat</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/dhf.html#time_reversal_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.dhf.time_reversal_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>T(A_ij) = A[T(i),T(j)]^*</p>
</dd></dl>

</div>
<div class="section" id="id1">
<h3>6.5.4. addons<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.scf.addons"></span><dl class="function">
<dt id="pyscf.scf.addons.convert_to_ghf">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">convert_to_ghf</code><span class="sig-paren">(</span><em>mf</em>, <em>out=None</em>, <em>remove_df=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/addons.html#convert_to_ghf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.addons.convert_to_ghf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the given mean-field object to the generalized HF/KS object</p>
<p>Note if mf is an second order SCF object, the second order object will not
be converted (in other words, only the underlying SCF object will be
converted)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mf : SCF object</dd>
<dt>Kwargs</dt>
<dd><dl class="first last docutils">
<dt>remove_df</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to convert the DF-SCF object to the normal SCF object.
This conversion is not applied by default.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An generalized SCF object</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.convert_to_rhf">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">convert_to_rhf</code><span class="sig-paren">(</span><em>mf</em>, <em>out=None</em>, <em>remove_df=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/addons.html#convert_to_rhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.addons.convert_to_rhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the given mean-field object to the restricted HF/KS object</p>
<p>Note if mf is an second order SCF object, the second order object will not
be converted (in other words, only the underlying SCF object will be
converted)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mf : SCF object</dd>
<dt>Kwargs</dt>
<dd><dl class="first last docutils">
<dt>remove_df</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to convert the DF-SCF object to the normal SCF object.
This conversion is not applied by default.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An unrestricted SCF object</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.convert_to_uhf">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">convert_to_uhf</code><span class="sig-paren">(</span><em>mf</em>, <em>out=None</em>, <em>remove_df=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/addons.html#convert_to_uhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.addons.convert_to_uhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the given mean-field object to the unrestricted HF/KS object</p>
<p>Note if mf is an second order SCF object, the second order object will not
be converted (in other words, only the underlying SCF object will be
converted)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>mf : SCF object</dd>
<dt>Kwargs</dt>
<dd><dl class="first last docutils">
<dt>remove_df</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to convert the DF-SCF object to the normal SCF object.
This conversion is not applied by default.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An unrestricted SCF object</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.dynamic_level_shift">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">dynamic_level_shift</code><span class="sig-paren">(</span><em>mf</em>, <em>factor=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.dynamic_level_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamically change the level shift in each SCF cycle.  The level shift
value is set to (HF energy change * factor)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.dynamic_level_shift_">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">dynamic_level_shift_</code><span class="sig-paren">(</span><em>mf</em>, <em>factor=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/addons.html#dynamic_level_shift_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.addons.dynamic_level_shift_" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamically change the level shift in each SCF cycle.  The level shift
value is set to (HF energy change * factor)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.dynamic_sz_">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">dynamic_sz_</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.dynamic_sz_" title="Permalink to this definition">¶</a></dt>
<dd><p>For UHF, allowing the Sz value being changed during SCF iteration.
Determine occupation of alpha and beta electrons based on energy spectrum</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.fast_newton">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">fast_newton</code><span class="sig-paren">(</span><em>mf</em>, <em>mo_coeff=None</em>, <em>mo_occ=None</em>, <em>dm0=None</em>, <em>auxbasis=None</em>, <em>dual_basis=None</em>, <em>**newton_kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/addons.html#fast_newton"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.addons.fast_newton" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a wrap function which combines several operations. This
function first setup the initial guess
from density fitting calculation then use  for
Newton solver and call Newton solver.
Newton solver attributes [max_cycle_inner, max_stepsize, ah_start_tol,
ah_conv_tol, ah_grad_trust_region, ...] can be passed through <a href="#id2"><span class="problematic" id="id3">**</span></a>newton_kwargs.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.float_occ">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">float_occ</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.float_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>For UHF, allowing the Sz value being changed during SCF iteration.
Determine occupation of alpha and beta electrons based on energy spectrum</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.float_occ_">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">float_occ_</code><span class="sig-paren">(</span><em>mf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/addons.html#float_occ_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.addons.float_occ_" title="Permalink to this definition">¶</a></dt>
<dd><p>For UHF, allowing the Sz value being changed during SCF iteration.
Determine occupation of alpha and beta electrons based on energy spectrum</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.get_ghf_orbspin">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">get_ghf_orbspin</code><span class="sig-paren">(</span><em>mo_energy</em>, <em>mo_occ</em>, <em>is_rhf=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/addons.html#get_ghf_orbspin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.addons.get_ghf_orbspin" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin of each GHF orbital when the GHF orbitals are converted from
RHF/UHF orbitals</p>
<p>For RHF orbitals, the orbspin corresponds to first occupied orbitals then
unoccupied orbitals.  In the occupied orbital space, if degenerated, first
alpha then beta, last the (open-shell) singly occupied (alpha) orbitals. In
the unoccupied orbital space, first the (open-shell) unoccupied (beta)
orbitals if applicable, then alpha and beta orbitals</p>
<p>For UHF orbitals, the orbspin corresponds to first occupied orbitals then
unoccupied orbitals.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.mom_occ">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">mom_occ</code><span class="sig-paren">(</span><em>mf</em>, <em>occorb</em>, <em>setocc</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.mom_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Use maximum overlap method to determine occupation number for each orbital in every
iteration. It can be applied to unrestricted HF/KS and restricted open-shell
HF/KS.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.mom_occ_">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">mom_occ_</code><span class="sig-paren">(</span><em>mf</em>, <em>occorb</em>, <em>setocc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/addons.html#mom_occ_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.addons.mom_occ_" title="Permalink to this definition">¶</a></dt>
<dd><p>Use maximum overlap method to determine occupation number for each orbital in every
iteration. It can be applied to unrestricted HF/KS and restricted open-shell
HF/KS.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.project_dm_nr2nr">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">project_dm_nr2nr</code><span class="sig-paren">(</span><em>mol1</em>, <em>dm1</em>, <em>mol2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/addons.html#project_dm_nr2nr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.addons.project_dm_nr2nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Project density matrix representation from basis set 1 (mol1) to basis
set 2 (mol2).</p>
<div class="math">
\[ \begin{align}\begin{aligned}|AO2\rangle DM_AO2 \langle AO2|\\= |AO2\rangle P DM_AO1 P \langle AO2|\\DM_AO2 = P DM_AO1 P\\P = S_{AO2}^{-1}\langle AO2|AO1\rangle\end{aligned}\end{align} \]</div>
<p>There are three relevant functions:
<a class="reference internal" href="#pyscf.scf.addons.project_dm_nr2nr" title="pyscf.scf.addons.project_dm_nr2nr"><code class="xref py py-func docutils literal"><span class="pre">project_dm_nr2nr()</span></code></a> is the projection for non-relativistic (scalar) basis.
<code class="xref py py-func docutils literal"><span class="pre">project_dm_nr2r()</span></code> projects from non-relativistic to relativistic basis.
<code class="xref py py-func docutils literal"><span class="pre">project_dm_r2r()</span></code>  is the projection between relativistic (spinor) basis.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.project_mo_nr2nr">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">project_mo_nr2nr</code><span class="sig-paren">(</span><em>mol1</em>, <em>mo1</em>, <em>mol2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/addons.html#project_mo_nr2nr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.addons.project_mo_nr2nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Project orbital coefficients from basis set 1 (C1 for mol1) to basis
set 2 (C2 for mol2).</p>
<div class="math">
\[ \begin{align}\begin{aligned}|\psi1\rangle = |AO1\rangle C1\\|\psi2\rangle = P |\psi1\rangle = |AO2\rangle S^{-1}\langle AO2| AO1\rangle&gt; C1 = |AO2\rangle&gt; C2\\C2 = S^{-1}\langle AO2|AO1\rangle C1\end{aligned}\end{align} \]</div>
<p>There are three relevant functions:
<a class="reference internal" href="#pyscf.scf.addons.project_mo_nr2nr" title="pyscf.scf.addons.project_mo_nr2nr"><code class="xref py py-func docutils literal"><span class="pre">project_mo_nr2nr()</span></code></a> is the projection for non-relativistic (scalar) basis.
<code class="xref py py-func docutils literal"><span class="pre">project_mo_nr2r()</span></code> projects from non-relativistic to relativistic basis.
<code class="xref py py-func docutils literal"><span class="pre">project_mo_r2r()</span></code>  is the projection between relativistic (spinor) basis.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.remove_linear_dep">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">remove_linear_dep</code><span class="sig-paren">(</span><em>mf</em>, <em>threshold=1e-08</em>, <em>lindep=1e-10</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.remove_linear_dep" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>threshold</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>The threshold under which the eigenvalues of the overlap matrix are
discarded to avoid numerical instability.</dd>
<dt>lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>The threshold that triggers the special treatment of the linear
dependence issue.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.addons.remove_linear_dep_">
<code class="descclassname">pyscf.scf.addons.</code><code class="descname">remove_linear_dep_</code><span class="sig-paren">(</span><em>mf</em>, <em>threshold=1e-08</em>, <em>lindep=1e-10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/addons.html#remove_linear_dep_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.addons.remove_linear_dep_" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>threshold</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>The threshold under which the eigenvalues of the overlap matrix are
discarded to avoid numerical instability.</dd>
<dt>lindep</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>The threshold that triggers the special treatment of the linear
dependence issue.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<span class="target" id="module-pyscf.scf.chkfile"></span><dl class="function">
<dt id="pyscf.scf.chkfile.dump_scf">
<code class="descclassname">pyscf.scf.chkfile.</code><code class="descname">dump_scf</code><span class="sig-paren">(</span><em>mol</em>, <em>chkfile</em>, <em>e_tot</em>, <em>mo_energy</em>, <em>mo_coeff</em>, <em>mo_occ</em>, <em>overwrite_mol=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/chkfile.html#dump_scf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.chkfile.dump_scf" title="Permalink to this definition">¶</a></dt>
<dd><p>save temporary results</p>
</dd></dl>

<hr class="docutils" />
<span class="target" id="module-pyscf.scf.diis"></span><p>DIIS</p>
<dl class="class">
<dt id="pyscf.scf.diis.ADIIS">
<em class="property">class </em><code class="descclassname">pyscf.scf.diis.</code><code class="descname">ADIIS</code><span class="sig-paren">(</span><em>dev=None</em>, <em>filename=None</em>, <em>incore=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/diis.html#ADIIS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.diis.ADIIS" title="Permalink to this definition">¶</a></dt>
<dd><p>Ref: JCP, 132, 054109</p>
</dd></dl>

<dl class="class">
<dt id="pyscf.scf.diis.EDIIS">
<em class="property">class </em><code class="descclassname">pyscf.scf.diis.</code><code class="descname">EDIIS</code><span class="sig-paren">(</span><em>dev=None</em>, <em>filename=None</em>, <em>incore=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/diis.html#EDIIS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.diis.EDIIS" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF-EDIIS
Ref: JCP 116, 8255</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.scf.diis.get_err_vec">
<code class="descclassname">pyscf.scf.diis.</code><code class="descname">get_err_vec</code><span class="sig-paren">(</span><em>s</em>, <em>d</em>, <em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/scf/diis.html#get_err_vec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.scf.diis.get_err_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>error vector = SDF - FDS</p>
</dd></dl>

</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ao2mo.html" class="btn btn-neutral float-right" title="7. ao2mo — Integral transformations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lib.html" class="btn btn-neutral" title="5. lib — Helper functions, parameters, and C extensions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.7.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>