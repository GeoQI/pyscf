

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4. gto — Molecular structure and GTO basis &mdash; PySCF 1.7.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PySCF 1.7.0 documentation" href="index.html"/>
        <link rel="next" title="5. lib — Helper functions, parameters, and C extensions" href="lib.html"/>
        <link rel="prev" title="3. Installation" href="install.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">2. Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">3. Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. gto &#8212; Molecular structure and GTO basis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#input">4.1. Input</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#geometry">4.1.1. Geometry</a></li>
<li class="toctree-l3"><a class="reference internal" href="#input-basis">4.1.2. Input Basis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#command-line">4.1.3. Command line</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spin-and-charge">4.1.4. Spin and charge</a></li>
<li class="toctree-l3"><a class="reference internal" href="#symmetry">4.1.5. Symmetry</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#program-reference">4.2. Program reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mole">4.2.1. mole</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-pyscf.gto.moleintor">4.2.2. moleintor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basis">4.2.3. basis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#internal-format">4.2.3.1. Internal format</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="lib.html">5. <code class="docutils literal"><span class="pre">lib</span></code> &#8212; Helper functions, parameters, and C extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="scf.html">6. scf &#8212; Mean-field methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="ao2mo.html">7. ao2mo &#8212; Integral transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="mcscf.html">8. mcscf &#8212; Multi-configurational self-consistent field</a></li>
<li class="toctree-l1"><a class="reference internal" href="fci.html">9. fci &#8212; Full configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="symm.html">10. symm &#8211; Point group symmetry and spin symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="df.html">11. df &#8212; Density fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="dft.html">12. dft &#8212; Density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="tddft.html">13. tddft &#8212; Time dependent density functional theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="cc.html">14. cc &#8212; Coupled cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">15. ci &#8212; Configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dmrgscf.html">16. dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="fciqmcscf.html">17. fciqmcscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">18. tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="grad.html">19. grad &#8212; Analytical nuclear gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="hessian.html">20. hessian &#8212; Analytical nuclear Hessian</a></li>
<li class="toctree-l1"><a class="reference internal" href="pbc.html">21. pbc &#8212; Periodic boundary conditions</a></li>
<li class="toctree-l1"><a class="reference internal" href="nao.html">22. nao &#8212; Numerical Atomic Orbitals</a></li>
<li class="toctree-l1"><a class="reference internal" href="lo.html">23. lo &#8212; Orbital localization</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">24. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="qmmm.html">25. qmmm &#8212; QM/MM interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="mrpt.html">26. mrpt &#8212; Multi-reference perturbation theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmark.html">27. Benchmark</a></li>
<li class="toctree-l1"><a class="reference internal" href="code-rule.html">28. Code standard</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">29. Version history</a></li>
<li class="toctree-l1"><a class="reference internal" href="gw.html">30. gw &#8212; Molecular G0W0</a></li>
<li class="toctree-l1"><a class="reference internal" href="hci.html">31. hci &#8212; Interface to Heat-Bath selective CI</a></li>
<li class="toctree-l1"><a class="reference internal" href="sgx.html">32. sgx &#8212; Pseudo-spectral methods (COSX, PS, SN-K)</a></li>
<li class="toctree-l1"><a class="reference internal" href="semiempirical.html">33. semiempirical &#8212; Semiempirical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="mp.html">34. mp &#8212; MP2</a></li>
<li class="toctree-l1"><a class="reference internal" href="semiempirical.html">33. semiempirical &#8212; Semiempirical methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="soscf.html">35. soscf &#8212; Second order Hartree-Fock solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="icmpspt.html">36. icmpspt &#8212; Internal-contracted MPS perturbation method</a></li>
<li class="toctree-l1"><a class="reference internal" href="ccn.html">37. ccn &#8212; Auto-Generated Coupled-Cluster Equations of Arbitrary Order</a></li>
<li class="toctree-l1"><a class="reference internal" href="cornell_shci.html">38. cornell_shci &#8212; Interface to Fast Semistochastic Heat Bath Configuration Interaction (SHCI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="dftd3.html">39. dftd3 &#8212; DFT plus Dispersion Correction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dmrgscf.html">16. dmrgscf</a></li>
<li class="toctree-l1"><a class="reference internal" href="doci.html">40. doci &#8212; Doubly occupied configuration interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="geomopt.html">41. geomopt &#8212; Geometry optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="solvent.html">42. solvent &#8212; Solvent methods</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PySCF</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>4. gto &#8212; Molecular structure and GTO basis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/gto.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="gto-molecular-structure-and-gto-basis">
<span id="gto"></span><h1>4. gto &#8212; Molecular structure and GTO basis<a class="headerlink" href="#gto-molecular-structure-and-gto-basis" title="Permalink to this headline">¶</a></h1>
<p>This module provides the functions to parse the command line options,
the molecular geometry and format the basic functions for <cite>libcint</cite>
integral library.  In <code class="file docutils literal"><span class="pre">mole</span></code>, a basic class <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> is
defined to hold the global parameters, which will be used throughout the
package.</p>
<div class="section" id="input">
<h2>4.1. Input<a class="headerlink" href="#input" title="Permalink to this headline">¶</a></h2>
<div class="section" id="geometry">
<h3>4.1.1. Geometry<a class="headerlink" href="#geometry" title="Permalink to this headline">¶</a></h3>
<p>There are multiple ways to input molecular geometry. The internal format of
<code class="xref py py-attr docutils literal"><span class="pre">Mole.atom</span></code> is a python list:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">atom</span> <span class="o">=</span> <span class="p">[[</span><span class="n">atom1</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)],</span>
        <span class="p">[</span><span class="n">atom2</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)],</span>
        <span class="o">...</span>
        <span class="p">[</span><span class="n">atomN</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)]]</span>
</pre></div>
</div>
<p>You can input the geometry in this format.  You can use Python script to
construct the geometry:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;O&#39;</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
</pre></div>
</div>
<p>Besides Python list, tuple and numpy.ndarray are all supported by the internal
format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;O&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span> <span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<p>Also, <code class="xref py py-attr docutils literal"><span class="pre">atom</span></code> can be a string of Cartesian format or Z-matrix format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">O 0 0 0</span>
<span class="gp">... </span><span class="s1">H 0 1 0</span>
<span class="gp">... </span><span class="s1">H 0 0 1;</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span>
</pre></div>
</div>
<p>There are a few requirements for the string format.  The string input
takes <code class="docutils literal"><span class="pre">;</span></code> or <code class="docutils literal"><span class="pre">\n</span></code> to partition atoms. White space and <code class="docutils literal"><span class="pre">,</span></code> are used to
split items for each atom.  Blank lines or lines started with <code class="docutils literal"><span class="pre">#</span></code> will be
ignored:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
<span class="gp">... </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">#O 0 0 0</span>
<span class="gp">... </span><span class="s1">H 0 1 0</span>
<span class="gp">...</span><span class="s1"></span>
<span class="gp">... </span><span class="s1">H 0 0 1;</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The geometry string is case-insensitive.  It also supports to input the nuclear
charges of elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">8</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]]</span>
</pre></div>
</div>
<p>If you need to label an atom to distinguish it from the rest, you can prefix
or suffix number or special characters <code class="docutils literal"><span class="pre">1234567890~!&#64;#$%^&amp;*()_+.?:&lt;&gt;[]{}|</span></code>
(except <code class="docutils literal"><span class="pre">,</span></code> and <code class="docutils literal"><span class="pre">;</span></code>) to an atomic symbol.  With this decoration, you can
specify different basis sets, or masses, or nuclear models for different atoms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;8 0 0 0; h:1 0 1 0; H@2 0 0&#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="s1">&#39;cc-pvdz&#39;</span><span class="p">,</span> <span class="s1">&#39;H@2&#39;</span><span class="p">:</span> <span class="s1">&#39;6-31G&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>
<span class="go">[[&#39;O&#39;, [0.0, 0.0, 0.0]], [&#39;H:1&#39;, [0.0, 1.0, 0.0]], [&#39;H@2&#39;, [0.0, 0.0]]]</span>
</pre></div>
</div>
<p>No matter which format or symbols were used in the input, <code class="xref py py-func docutils literal"><span class="pre">Mole.build()</span></code>
will convert <code class="xref py py-attr docutils literal"><span class="pre">Mole.atom</span></code> to the internal format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="go">    O        0,   0, 0             ; 1 0.0 1 0</span>

<span class="go">        H@2,0 0 1</span>
<span class="go">    &#39;&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span><span class="p">)</span>
<span class="go">[[&#39;O&#39;, [0.0, 0.0, 0.0]], [&#39;H&#39;, [0.0, 1.0, 0.0]], [&#39;H@2&#39;, [0.0, 0.0, 1.0]]]</span>
</pre></div>
</div>
<p>In the program, the molecular geometry is accessed with <code class="xref py py-meth docutils literal"><span class="pre">Mole.atom_coords()</span></code>
function.  This function returns a (N,3) array for the coordinates (in Bohr) of
each atom:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">())</span>
<span class="go">[[ 0.          0.          0.        ]</span>
<span class="go"> [ 0.          1.88972612  0.        ]</span>
<span class="go"> [ 0.          0.          1.88972612]]</span>
</pre></div>
</div>
</div>
<div class="section" id="input-basis">
<span id="id1"></span><h3>4.1.2. Input Basis<a class="headerlink" href="#input-basis" title="Permalink to this headline">¶</a></h3>
<p>There are various ways to input basis sets.  Besides the input of universal
basis string and basis <code class="docutils literal"><span class="pre">dict</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;sto3g&#39;</span>
<span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="s1">&#39;sto3g&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="s1">&#39;6-31g&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>basis can be input with helper functions.
Function <code class="xref py py-func docutils literal"><span class="pre">basis.parse()</span></code> can parse a basis string of NWChem format
(<a class="reference external" href="https://bse.pnl.gov/bse/portal">https://bse.pnl.gov/bse/portal</a>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="n">gto</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">C    S</span>
<span class="s1">     71.6168370              0.15432897</span>
<span class="s1">     13.0450960              0.53532814</span>
<span class="s1">      3.5305122              0.44463454</span>
<span class="s1">C    SP</span>
<span class="s1">      2.9412494             -0.09996723             0.15591627</span>
<span class="s1">      0.6834831              0.39951283             0.60768372</span>
<span class="s1">      0.2222899              0.70011547             0.39195739</span>
<span class="s1">&#39;&#39;&#39;</span><span class="p">)}</span>
</pre></div>
</div>
<p>Functions <code class="xref py py-func docutils literal"><span class="pre">basis.load()</span></code> can be load arbitrary basis from the database, even
the basis which does not match the element.</p>
<blockquote>
<div>mol.basis = {&#8216;H&#8217;: gto.basis.load(&#8216;sto3g&#8217;, &#8216;C&#8217;)}</div></blockquote>
<p>Both <code class="xref py py-func docutils literal"><span class="pre">basis.parse()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">basis.load()</span></code> return the basis set in the
internal format (See the <a class="reference internal" href="#gto-basis"><span class="std std-ref">basis</span></a>).</p>
<p>Basis parser supports &#8220;Ghost&#8221; atom:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GHOST&#39;</span><span class="p">:</span> <span class="n">gto</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">),</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="s1">&#39;sto3g&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>More examples of inputing ghost atoms can be found in
<code class="file docutils literal"><span class="pre">examples/gto/03-ghost_atom.py</span></code></p>
<p>Like the requirements of geometry input, you can use atomic symbol
(case-insensitive) or the atomic nuclear charge, as the keyword of the
<code class="xref py py-attr docutils literal"><span class="pre">basis</span></code> dict.  Prefix and suffix of numbers and special
characters are allowed.  If the decorated atomic symbol is appeared in
<code class="xref py py-attr docutils literal"><span class="pre">atom</span></code> but not <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code>, the basis parser will
remove all decorations then seek the pure atomic symbol in
<code class="xref py py-attr docutils literal"><span class="pre">basis</span></code> dict.  In the following example, <code class="docutils literal"><span class="pre">6-31G</span></code> basis
will be assigned to the second H atom, but <code class="docutils literal"><span class="pre">STO-3G</span></code> will be used for
the third atom:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;8 0 0 0; h1 0 1 0; H2 0 0 1&#39;</span>
<span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="s1">&#39;sto3g&#39;</span><span class="p">,</span> <span class="s1">&#39;H1&#39;</span><span class="p">:</span> <span class="s1">&#39;6-31G&#39;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="command-line">
<h3>4.1.3. Command line<a class="headerlink" href="#command-line" title="Permalink to this headline">¶</a></h3>
<p>Some of the input variables can be passed from command line:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ python example.py -o /path/to/my_log.txt -m 1000
</pre></div>
</div>
<p>This command line specifies the output file and the maximum of memory for the
calculation.  By default, command line has the highest priority, which means our
settings in the script will be overwritten by the command line arguments.  To
make the input parser ignore the command line arguments, you can call the
<code class="xref py py-func docutils literal"><span class="pre">Mole.build()</span></code> with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The first 0 prevent <code class="xref py py-func docutils literal"><span class="pre">build()</span></code> dumping the input file.  The
second 0 prevent <code class="xref py py-func docutils literal"><span class="pre">build()</span></code> parsing command line.</p>
</div>
<div class="section" id="spin-and-charge">
<h3>4.1.4. Spin and charge<a class="headerlink" href="#spin-and-charge" title="Permalink to this headline">¶</a></h3>
<p>Charge and spin multiplicity can be assigned to <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mol</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">mol</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Note <code class="xref py py-attr docutils literal"><span class="pre">Mole.spin</span></code> is the number of unpaired electrons (difference between
the numbers of alpha electrons and beta electrons).  These two attributes do not
affect any other parameters in the <code class="xref py py-attr docutils literal"><span class="pre">Mole.build</span></code> initialization function.
They can be set or modified (although not recommended to do so) after the
molecular object is initialized:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;O 0 0 0; h 0 1 0; h 0 0 1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;sto-6g&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nelec</span><span class="p">)</span>
<span class="go">(6, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nelec</span><span class="p">)</span>
<span class="go">(5, 5)</span>
</pre></div>
</div>
<p><code class="xref py py-attr docutils literal"><span class="pre">Mole.charge</span></code> is the parameter to define the total number electrons of the
system.  In a custom system such as the Hubbard lattice model, the total number
of electrons needs to be defined directly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div>
</div>
</div>
<div class="section" id="symmetry">
<h3>4.1.5. Symmetry<a class="headerlink" href="#symmetry" title="Permalink to this headline">¶</a></h3>
<p>Point group symmetry information is held in <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> object.  The symmetry
module (<a class="reference internal" href="symm.html#symm"><span class="std std-ref">symm &#8211; Point group symmetry and spin symmetry</span></a>) of PySCF program can detect arbitrary point groups. In the
SCF calculations, PySCF program supports linear molecular symmetry
<span class="math">\(D_{\infty h}\)</span> (labelled as Dooh in the program), <span class="math">\(C_{\infty v}\)</span>
(labelled as Coov) plus <span class="math">\(D_{2h}\)</span> and its subgroups.</p>
<p>If the attribute <code class="xref py py-attr docutils literal"><span class="pre">Mole.symmetry</span></code> is set, <code class="xref py py-meth docutils literal"><span class="pre">Mole.build()</span></code> function will
detect the top point group and the supported subgroups.  The detected point
groups are saved in <code class="xref py py-attr docutils literal"><span class="pre">Mole.topgroup</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">Mole.groupname</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;B 0 0 0; H 0 1 1; H 1 0 1; H 1 1 0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">topgroup</span><span class="p">)</span>
<span class="go">C3v</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">groupname</span><span class="p">)</span>
<span class="go">Cs</span>
</pre></div>
</div>
<p>Also, during the <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> object initialization, the program will move the
charge center of the system to the origin (0,0,0) and place the main rotation
axis on z-axis (if available, see <a class="reference internal" href="symm.html#symm"><span class="std std-ref">symm &#8211; Point group symmetry and spin symmetry</span></a> for more details about how the
main axis is determined).  In the last example, the molecule is rotated to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charges</span><span class="p">())</span>
<span class="go">[[  0.00000000e+00  -8.18275415e-01   0.00000000e+00]</span>
<span class="go"> [ -7.71477460e-01   1.36379236e+00  -1.33623816e+00]</span>
<span class="go"> [ -7.71477460e-01   1.36379236e+00   1.33623816e+00]</span>
<span class="go"> [  1.54295492e+00   1.36379236e+00  -2.22044605e-16]]</span>
</pre></div>
</div>
<p>Sometimes it is necessary to use a lower symmetry instead of the detected
symmetry group.  The subgroup symmetry can be specified in
<code class="xref py py-attr docutils literal"><span class="pre">Mole.symmetry_subgroup</span></code> and the program will first detect the highest
possible symmetry group and lower the point group symmetry to the specified
subgroup:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">symmetry_subgroup</span> <span class="o">=</span> <span class="n">C2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">topgroup</span><span class="p">)</span>
<span class="go">Dooh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">groupname</span><span class="p">)</span>
<span class="go">C2</span>
</pre></div>
</div>
<p>In many situations, you may requite the program to use the point group symmetry
in different orientation.  This can be achieved by explicit specification of the
symmetry elements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="s1">&#39;coov&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">topgroup</span><span class="p">)</span>
<span class="go">coov</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">groupname</span><span class="p">)</span>
<span class="go">coov</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_coords</span><span class="p">())</span>
<span class="go">[[ 0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          1.88972612]]</span>
</pre></div>
</div>
<p>When a particular symmetry was assigned to <code class="xref py py-attr docutils literal"><span class="pre">Mole.symmetry</span></code>. The program
will use the given symmetry group for the system and use the input orientation.
The initialization function <code class="xref py py-meth docutils literal"><span class="pre">Mole.build()</span></code> will test whether the input
symmetry matches the input orientation.  If the given symmetry group does not
agree to the actual input symmetry, the initialization will stop and issue an
error message:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="s1">&#39;Dooh&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="go">RuntimeWarning: Unable to identify input symmetry Dooh.</span>
<span class="go">Try symmetry=&quot;Dooh&quot; with geometry (unit=&quot;Bohr&quot;)</span>
<span class="go">(&#39;N&#39;, [0.0, 0.0, -0.9448630622825309])</span>
<span class="go">(&#39;N&#39;, [0.0, 0.0, 0.9448630622825309])</span>
</pre></div>
</div>
<p>Note if Z-matrix is given in the input, the molecule may be placed in an
arbitrary orientation.  Although still works, specifying <code class="xref py py-attr docutils literal"><span class="pre">Mole.symmetry</span></code>
often leads to the above error message.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="xref py py-attr docutils literal"><span class="pre">Mole.symmetry_subgroup</span></code> does not have effects
when specific symmetry group is assigned to <code class="xref py py-attr docutils literal"><span class="pre">Mole.symmetry</span></code>.</p>
</div>
<p>When symmetry is enabled in the <code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> object, the point group symmetry
information will be used to construct the symmetry adapted orbital basis (see
also <a class="reference internal" href="symm.html#symm"><span class="std std-ref">symm &#8211; Point group symmetry and spin symmetry</span></a>).  The symmetry adapted orbitals are held in
<code class="xref py py-attr docutils literal"><span class="pre">Mole.symm_orb</span></code> as a list of 2D arrays.  Each element of the list
is an AO (atomic orbital) to SO (symmetry-adapted orbital) transformation matrix
for an irreducible representation.  The name of the irreducible representations
are stored in <code class="xref py py-attr docutils literal"><span class="pre">Mole.irrep_name</span></code> and their internal IDs (see more details
in <a class="reference internal" href="symm.html#symm"><span class="std std-ref">symm &#8211; Point group symmetry and spin symmetry</span></a>) are stored in <code class="xref py py-attr docutils literal"><span class="pre">Mole.irrep_id</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">symmetry</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">irrep_name</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">irrep_id</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">symm_orb</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">A1g 0 (10, 3)</span>
<span class="go">E1gx 2 (10, 1)</span>
<span class="go">E1gy 3 (10, 1)</span>
<span class="go">A1u 5 (10, 3)</span>
<span class="go">E1uy 6 (10, 1)</span>
<span class="go">E1ux 7 (10, 1)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="program-reference">
<h2>4.2. Program reference<a class="headerlink" href="#program-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="mole">
<h3>4.2.1. mole<a class="headerlink" href="#mole" title="Permalink to this headline">¶</a></h3>
<p><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code> class handles three layers: input, internal format, libcint arguments.
The relationship of the three layers are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">atom</span> <span class="p">(</span><span class="nb">input</span><span class="p">)</span>  <span class="o">&lt;=&gt;</span>  <span class="o">.</span><span class="n">_atom</span> <span class="p">(</span><span class="k">for</span> <span class="n">python</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="o">.</span><span class="n">_atm</span> <span class="p">(</span><span class="k">for</span> <span class="n">libcint</span><span class="p">)</span>
<span class="o">.</span><span class="n">basis</span> <span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="o">.</span><span class="n">_basis</span> <span class="p">(</span><span class="k">for</span> <span class="n">python</span><span class="p">)</span> <span class="o">&lt;=&gt;</span> <span class="o">.</span><span class="n">_bas</span> <span class="p">(</span><span class="k">for</span> <span class="n">libcint</span><span class="p">)</span>
</pre></div>
</div>
<p>input layer does not talk to libcint directly.  Data are held in python
internal fomrat layer.  Most of methods defined in this class only operates
on the internal format.  Exceptions are make_env, make_atm_env, make_bas_env,
<code class="xref py py-func docutils literal"><span class="pre">set_common_orig_()</span></code>, <code class="xref py py-func docutils literal"><span class="pre">set_rinv_orig_()</span></code> which are used to
manipulate the libcint arguments.</p>
<span class="target" id="module-pyscf.gto.mole"></span><dl class="function">
<dt id="pyscf.gto.mole.M">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">M</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#M"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.M" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a shortcut to build up Mole object.</p>
<p>Args: Same to <a class="reference internal" href="#pyscf.gto.mole.Mole.build" title="pyscf.gto.mole.Mole.build"><code class="xref py py-func docutils literal"><span class="pre">Mole.build()</span></code></a></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="k">import</span> <span class="n">gto</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="pyscf.gto.mole.Mole">
<em class="property">class </em><code class="descclassname">pyscf.gto.mole.</code><code class="descname">Mole</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic class to hold molecular structure and global options</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level</dd>
<dt>output</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span><dd>Output file, default is None which dumps msg to sys.stdout</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int, float</span><dd>Allowed memory in MB</dd>
<dt>charge</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Charge of molecule. It affects the electron numbers</dd>
<dt>spin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span><dd>2S, num. alpha electrons - num. beta electrons to control
multiplicity. If spin = None is set, multiplicity will be guessed
based on the neutral molecule.</dd>
<dt>symmetry</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool or str</span><dd>Whether to use symmetry.  When this variable is set to True, the
molecule will be rotated and the highest rotation axis will be
placed z-axis.
If a string is given as the name of point group, the given point
group symmetry will be used.  Note that the input molecular
coordinates will not be changed in this case.</dd>
<dt>symmetry_subgroup</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>subgroup</dd>
<dt>atom</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list or str</span><dd><p class="first">To define molecluar structure.  The internal format is</p>
<div class="last line-block">
<div class="line">atom = [[atom1, (x, y, z)],</div>
<div class="line-block">
<div class="line">[atom2, (x, y, z)],</div>
<div class="line">...</div>
<div class="line">[atomN, (x, y, z)]]</div>
</div>
</div>
</dd>
<dt>unit</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Angstrom or Bohr</dd>
<dt>basis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>To define basis set.</dd>
<dt>nucmod</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str or [function(nuc_charge, nucprop) =&gt; zeta]</span><dd>Nuclear model.  0 or None means point nuclear model.  Other
values will enable Gaussian nuclear model.  If a function is
assigned to this attribute, the function will be called to
generate the nuclear charge distribution value &#8220;zeta&#8221; and the
relevant nuclear model will be set to Gaussian model.
Default is point nuclear model.</dd>
<dt>nucprop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>Nuclear properties (like g-factor &#8216;g&#8217;, quadrupole moments &#8216;Q&#8217;).
It is needed by pyscf.prop module and submodules.</dd>
<dt>cart</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Using Cartesian GTO basis and integrals (6d,10f,15g)</dd>
</dl>
<p>** Following attributes are generated by <a class="reference internal" href="#pyscf.gto.mole.Mole.build" title="pyscf.gto.mole.Mole.build"><code class="xref py py-func docutils literal"><span class="pre">Mole.build()</span></code></a> **</p>
<dl class="docutils">
<dt>stdout</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">file object</span><dd>Default is sys.stdout if <code class="xref py py-attr docutils literal"><span class="pre">Mole.output</span></code> is not set</dd>
<dt>topgroup</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Point group of the system.</dd>
<dt>groupname</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>The supported subgroup of the point group. It can be one of Dooh,
Coov, D2h, C2h, C2v, D2, Cs, Ci, C2, C1</dd>
<dt>nelectron</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>sum of nuclear charges - <code class="xref py py-attr docutils literal"><span class="pre">Mole.charge</span></code></dd>
<dt>symm_orb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of numpy.ndarray</span><dd>Symmetry adapted basis.  Each element is a set of symm-adapted orbitals
for one irreducible representation.  The list index does <strong>not</strong> correspond
to the id of irreducible representation.</dd>
<dt>irrep_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of int</span><dd>Each element is one irreducible representation id associated with the basis
stored in symm_orb.  One irrep id stands for one irreducible representation
symbol.  The irrep symbol and the relevant id are defined in
<code class="xref py py-attr docutils literal"><span class="pre">symm.param.IRREP_ID_TABLE</span></code></dd>
<dt>irrep_name</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of str</span><dd>Each element is one irreducible representation symbol associated with the basis
stored in symm_orb.  The irrep symbols are defined in
<code class="xref py py-attr docutils literal"><span class="pre">symm.param.IRREP_ID_TABLE</span></code></dd>
<dt>_built</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>To label whether <a class="reference internal" href="#pyscf.gto.mole.Mole.build" title="pyscf.gto.mole.Mole.build"><code class="xref py py-func docutils literal"><span class="pre">Mole.build()</span></code></a> has been called.  It is to
ensure certain functions being initialized only once.</dd>
<dt>_basis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>like <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code>, the internal format which is returned from the
parser <a class="reference internal" href="#pyscf.gto.mole.format_basis" title="pyscf.gto.mole.format_basis"><code class="xref py py-func docutils literal"><span class="pre">format_basis()</span></code></a></dd>
<dt>_keys</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a set of str</span><dd>Store the keys appeared in the module.  It is used to check misinput attributes</dd>
</dl>
<p>** Following attributes are arguments used by <code class="docutils literal"><span class="pre">libcint</span></code> library **</p>
<dl class="last docutils">
<dt>_atm :</dt>
<dd><code class="code docutils literal"><span class="pre">[[charge,</span> <span class="pre">ptr-of-coord,</span> <span class="pre">nuc-model,</span> <span class="pre">ptr-zeta,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[...]]</span></code>
each element reperesents one atom</dd>
<dt>natm :</dt>
<dd>number of atoms</dd>
<dt>_bas :</dt>
<dd><code class="code docutils literal"><span class="pre">[[atom-id,</span> <span class="pre">angular-momentum,</span> <span class="pre">num-primitive-GTO,</span> <span class="pre">num-contracted-GTO,</span> <span class="pre">0,</span> <span class="pre">ptr-of-exps,</span> <span class="pre">ptr-of-contract-coeff,</span> <span class="pre">0],</span> <span class="pre">[...]]</span></code>
each element reperesents one shell</dd>
<dt>nbas :</dt>
<dd>number of shells</dd>
<dt>_env :</dt>
<dd>list of floats to store the coordinates, GTO exponents, contract-coefficients</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">Mole</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto3g&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">H^2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_pure_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">H</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span>
<span class="go">[[ 0.99999999  0.43958641]</span>
<span class="go"> [ 0.43958641  0.99999999]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="go">&lt;class &#39;pyscf.gto.mole.Mole&#39;&gt; has no attributes Charge</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyscf.gto.mole.Mole.ao2mo">
<code class="descname">ao2mo</code><span class="sig-paren">(</span><em>mo_coeffs</em>, <em>erifile=None</em>, <em>dataname='eri_mo'</em>, <em>intor='int2e'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.ao2mo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.ao2mo" title="Permalink to this definition">¶</a></dt>
<dd><p>Integral transformation for arbitrary orbitals and arbitrary
integrals.  See more detalied documentation in func:<cite>ao2mo.kernel</cite>.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo_coeffs (an np array or a list of arrays)</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">A matrix of orbital</span><dd>coefficients if it is a numpy ndarray, or four sets of orbital
coefficients, corresponding to the four indices of (ij|kl).</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>erifile (str or h5py File or h5py Group object)</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">The file/object</span><dd>to store the transformed integrals.  If not given, the return
value is an array (in memory) of the transformed integrals.</dd>
<dt>dataname</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd><em>Note</em> this argument is effective if erifile is given.
The dataset name in the erifile (ref the hierarchy of HDF5 format
<a class="reference external" href="http://www.hdfgroup.org/HDF5/doc1.6/UG/09_Groups.html">http://www.hdfgroup.org/HDF5/doc1.6/UG/09_Groups.html</a>).  By assigning
different dataname, the existed integral file can be reused.  If
the erifile contains the specified dataname, the old integrals
will be replaced by the new one under the key dataname.</dd>
<dt>intor (str)</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">integral name Name of the 2-electron integral.  Ref</span><dd>to <code class="xref py py-func docutils literal"><span class="pre">getints_by_shell()</span></code>
for the complete list of available 2-electron integral names</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of transformed integrals if erifile is not given.
Otherwise, return the file/fileobject if erifile is assigned.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">pyscf</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 1 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span> <span class="mi">8</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eri1</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">(</span><span class="n">mo1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eri1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(55, 55)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eri1</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">(</span><span class="n">mo1</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eri1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eri1</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">(</span><span class="n">eri</span><span class="p">,</span> <span class="p">(</span><span class="n">mo1</span><span class="p">,</span><span class="n">mo2</span><span class="p">,</span><span class="n">mo2</span><span class="p">,</span><span class="n">mo2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eri1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(80, 36)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eri1</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">(</span><span class="n">eri</span><span class="p">,</span> <span class="p">(</span><span class="n">mo1</span><span class="p">,</span><span class="n">mo2</span><span class="p">,</span><span class="n">mo2</span><span class="p">,</span><span class="n">mo2</span><span class="p">),</span> <span class="n">erifile</span><span class="o">=</span><span class="s1">&#39;water.h5&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.ao_labels">
<code class="descname">ao_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.ao_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Labels of AO basis functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>fmt</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or bool</span><dd>if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-AO-notation)]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pyscf.gto.mole.Mole.ao_loc">
<code class="descname">ao_loc</code><a class="headerlink" href="#pyscf.gto.mole.Mole.ao_loc" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>list, each entry is the corresponding start basis function id</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.ao_loc_2c">
<code class="descname">ao_loc_2c</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.ao_loc_2c" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset of every shell in the spinor basis function spectrum</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>list, each entry is the corresponding start id of spinor function</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_2c</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 2, 4, 6, 12, 18, 20, 22, 24, 30, 36]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.ao_loc_nr">
<code class="descname">ao_loc_nr</code><span class="sig-paren">(</span><em>mol</em>, <em>cart=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.ao_loc_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>list, each entry is the corresponding start basis function id</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.aoslice_2c_by_atom">
<code class="descname">aoslice_2c_by_atom</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.aoslice_2c_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.aoslice_by_atom">
<code class="descname">aoslice_by_atom</code><span class="sig-paren">(</span><em>mol</em>, <em>ao_loc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.aoslice_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.aoslice_nr_by_atom">
<code class="descname">aoslice_nr_by_atom</code><span class="sig-paren">(</span><em>mol</em>, <em>ao_loc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.aoslice_nr_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.atom_charge">
<code class="descname">atom_charge</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.atom_charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Nuclear effective charge of the given atom id
Note &#8220;atom_charge /= charge(atom_symbol)&#8221; when ECP is enabled.
Number of electrons screened by ECP can be obtained by charge(atom_symbol)-atom_charge</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">17</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.atom_charges">
<code class="descname">atom_charges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_charges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.atom_charges" title="Permalink to this definition">¶</a></dt>
<dd><p>np.asarray([mol.atom_charge(i) for i in range(mol.natm)])</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.atom_coord">
<code class="descname">atom_coord</code><span class="sig-paren">(</span><em>atm_id</em>, <em>unit='Bohr'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_coord"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.atom_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Coordinates (ndarray) of the given atom id</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_coord</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 0.          0.          2.07869874]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.atom_coords">
<code class="descname">atom_coords</code><span class="sig-paren">(</span><em>unit='Bohr'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_coords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.atom_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>np.asarray([mol.atom_coords(i) for i in range(mol.natm)])</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.atom_mass_list">
<code class="descname">atom_mass_list</code><span class="sig-paren">(</span><em>mol</em>, <em>isotope_avg=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.atom_mass_list" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of mass for all atoms in the molecule</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>isotope_avg</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to use the isotope average mass as the atomic mass</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.atom_nelec_core">
<code class="descname">atom_nelec_core</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_nelec_core"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.atom_nelec_core" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of core electrons for pseudo potential.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.atom_nshells">
<code class="descname">atom_nshells</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_nshells"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.atom_nshells" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of basis/shells of the given atom</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_nshells</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.atom_pure_symbol">
<code class="descname">atom_pure_symbol</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_pure_symbol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.atom_pure_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>For the given atom id, return the standard symbol (striping special characters)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">H</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.atom_shell_ids">
<code class="descname">atom_shell_ids</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_shell_ids"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.atom_shell_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of the shell-ids of the given atom</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_shell_ids</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[3, 4, 5, 6, 7]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.atom_symbol">
<code class="descname">atom_symbol</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_symbol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.atom_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>For the given atom id, return the input symbol (without striping special characters)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">H^2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.bas_angular">
<code class="descname">bas_angular</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_angular"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.bas_angular" title="Permalink to this definition">¶</a></dt>
<dd><p>The angular momentum associated with the given basis</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_atom</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.bas_atom">
<code class="descname">bas_atom</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.bas_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>The atom (0-based id) that the given basis sits on</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_atom</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.bas_coord">
<code class="descname">bas_coord</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_coord"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.bas_coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Coordinates (ndarray) associated with the given basis id</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_coord</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 0.          0.          2.07869874]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.bas_ctr_coeff">
<code class="descname">bas_ctr_coeff</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_ctr_coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.bas_ctr_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract coefficients (ndarray) of the given shell</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_ctr_coeff</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[[ 10.03400444]</span>
<span class="go"> [  4.1188704 ]</span>
<span class="go"> [  1.53971186]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.bas_exp">
<code class="descname">bas_exp</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.bas_exp" title="Permalink to this definition">¶</a></dt>
<dd><p>exponents (ndarray) of the given shell</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_kappa</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[ 13.01     1.962    0.4446]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.bas_kappa">
<code class="descname">bas_kappa</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_kappa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.bas_kappa" title="Permalink to this definition">¶</a></dt>
<dd><p>Kappa (if l &lt; j, -l-1, else l) of the given shell</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_kappa</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.bas_len_cart">
<code class="descname">bas_len_cart</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_len_cart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.bas_len_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of Cartesian function associated with given basis</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.bas_len_spinor">
<code class="descname">bas_len_spinor</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_len_spinor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.bas_len_spinor" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of spinor associated with given basis
If kappa is 0, return 4l+2</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.bas_nctr">
<code class="descname">bas_nctr</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_nctr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.bas_nctr" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of contracted GTOs for the given shell</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_atom</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.bas_nprim">
<code class="descname">bas_nprim</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_nprim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.bas_nprim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of primitive GTOs for the given shell</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_atom</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.build">
<code class="descname">build</code><span class="sig-paren">(</span><em>dump_input=True</em>, <em>parse_arg=True</em>, <em>verbose=None</em>, <em>output=None</em>, <em>max_memory=None</em>, <em>atom=None</em>, <em>basis=None</em>, <em>unit=None</em>, <em>nucmod=None</em>, <em>ecp=None</em>, <em>charge=None</em>, <em>spin=0</em>, <em>symmetry=None</em>, <em>symmetry_subgroup=None</em>, <em>cart=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.build"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup moleclue and initialize some control parameters.  Whenever you
change the value of the attributes of <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a>, you need call
this function to refresh the internal data of Mole.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dump_input</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>whether to dump the contents of input file in the output file</dd>
<dt>parse_arg</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>whether to read the sys.argv and overwrite the relevant parameters</dd>
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>output</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span><dd>Output file.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.output</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int, float</span><dd>Allowd memory in MB.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>atom</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list or str</span><dd>To define molecluar structure.</dd>
<dt>basis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>To define basis set.</dd>
<dt>nucmod</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>Nuclear model.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.nucmod</span></code></dd>
<dt>charge</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Charge of molecule. It affects the electron numbers
If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.charge</span></code></dd>
<dt>spin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>2S, num. alpha electrons - num. beta electrons to control
multiplicity. If setting spin = None , multiplicity will be
guessed based on the neutral molecule.
If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.spin</span></code></dd>
<dt>symmetry</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool or str</span><dd>Whether to use symmetry.  If given a string of point group
name, the given point group symmetry will be used.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.cart2sph_coeff">
<code class="descname">cart2sph_coeff</code><span class="sig-paren">(</span><em>normalized='sp'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.cart2sph_coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.cart2sph_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformation matrix that transforms Cartesian GTOs to spherical
GTOs for all basis functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>normalized</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">string or boolean</span><dd>How the Cartesian GTOs are normalized.  Except s and p functions,
Cartesian GTOs do not have the universal normalization coefficients
for the different components of the same shell.  The value of this
argument can be one of &#8216;sp&#8217;, &#8216;all&#8217;, None.  &#8216;sp&#8217; means the Cartesian s
and p basis are normalized.  &#8216;all&#8217; means all Cartesian functions are
normalized.  None means none of the Cartesian functions are normalized.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">cart2sph_coeff</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_cart&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">s0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">4.58676826646e-15</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.cart_labels">
<code class="descname">cart_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.cart_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Labels of Cartesian GTO functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-xyz-notation)]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.condense_to_shell">
<code class="descname">condense_to_shell</code><span class="sig-paren">(</span><em>mol</em>, <em>mat</em>, <em>compressor=&lt;function amax&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.condense_to_shell" title="Permalink to this definition">¶</a></dt>
<dd><p>The given matrix is first partitioned to blocks, based on AO shell as
delimiter.  Then call compressor function to abstract each block.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Deepcopy of the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.dumps">
<code class="descname">dumps</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Mole object to a JSON formatted str.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyscf.gto.mole.Mole.elements">
<code class="descname">elements</code><a class="headerlink" href="#pyscf.gto.mole.Mole.elements" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of elements in the molecule</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.energy_nuc">
<code class="descname">energy_nuc</code><span class="sig-paren">(</span><em>mol</em>, <em>charges=None</em>, <em>coords=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.energy_nuc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute nuclear repulsion energy (AU) or static Coulomb energy</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>float</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.etbs">
<code class="descname">etbs</code><span class="sig-paren">(</span><em>etbs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.etbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#pyscf.gto.mole.expand_etb" title="pyscf.gto.mole.expand_etb"><code class="xref py py-func docutils literal"><span class="pre">expand_etb()</span></code></a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd>etbs = [(l, n, alpha, beta), (l, n, alpha, beta),...]</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.eval_ao">
<code class="descname">eval_ao</code><span class="sig-paren">(</span><em>mol</em>, <em>eval_name</em>, <em>coords</em>, <em>comp=None</em>, <em>shls_slice=None</em>, <em>non0tab=None</em>, <em>ao_loc=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.eval_ao" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate AO function value on the given grids,</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">eval_name : str</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="13%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">comp</th>
<th class="head">Expression</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8220;GTOval_sph&#8221;</td>
<td>1</td>
<td><a href="#id2"><span class="problematic" id="id3">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_sph&#8221;</td>
<td>3</td>
<td>nabla <a href="#id4"><span class="problematic" id="id5">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_ig_sph&#8221;</td>
<td>3</td>
<td>(#C(0 1) g) <a href="#id6"><span class="problematic" id="id7">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ipig_sph&#8221;</td>
<td>3</td>
<td>(#C(0 1) nabla g) <a href="#id8"><span class="problematic" id="id9">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_cart&#8221;</td>
<td>1</td>
<td><a href="#id10"><span class="problematic" id="id11">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_cart&#8221;</td>
<td>3</td>
<td>nabla <a href="#id12"><span class="problematic" id="id13">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_ig_cart&#8221;</td>
<td>3</td>
<td>(#C(0 1) g)|AO&gt;</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="last docutils">
<dt>atm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>bas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>env</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float64 ndarray</span><dd>libcint integral function argument</dd>
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>The coordinates of the grids.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of the components of the operator</dd>
<dt>shls_slice</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2-element list</span><dd>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in mol will be evaluated.</dd>
<dt>non0tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D bool array</span><dd>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">dft.gen_grid.make_mask()</span></code></dd>
<dt>out</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If provided, results are written into this array.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>2D array of shape (N,nao) Or 3D array of shape (*,N,nao) to store AO
values on grids.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># 100 random points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(100, 24)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 100, 24)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.eval_gto">
<code class="descname">eval_gto</code><span class="sig-paren">(</span><em>mol</em>, <em>eval_name</em>, <em>coords</em>, <em>comp=None</em>, <em>shls_slice=None</em>, <em>non0tab=None</em>, <em>ao_loc=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.eval_gto" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate AO function value on the given grids,</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">eval_name : str</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="13%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">comp</th>
<th class="head">Expression</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8220;GTOval_sph&#8221;</td>
<td>1</td>
<td><a href="#id14"><span class="problematic" id="id15">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_sph&#8221;</td>
<td>3</td>
<td>nabla <a href="#id16"><span class="problematic" id="id17">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_ig_sph&#8221;</td>
<td>3</td>
<td>(#C(0 1) g) <a href="#id18"><span class="problematic" id="id19">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ipig_sph&#8221;</td>
<td>3</td>
<td>(#C(0 1) nabla g) <a href="#id20"><span class="problematic" id="id21">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_cart&#8221;</td>
<td>1</td>
<td><a href="#id22"><span class="problematic" id="id23">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_cart&#8221;</td>
<td>3</td>
<td>nabla <a href="#id24"><span class="problematic" id="id25">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_ig_cart&#8221;</td>
<td>3</td>
<td>(#C(0 1) g)|AO&gt;</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="last docutils">
<dt>atm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>bas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>env</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float64 ndarray</span><dd>libcint integral function argument</dd>
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>The coordinates of the grids.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of the components of the operator</dd>
<dt>shls_slice</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2-element list</span><dd>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in mol will be evaluated.</dd>
<dt>non0tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D bool array</span><dd>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">dft.gen_grid.make_mask()</span></code></dd>
<dt>out</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If provided, results are written into this array.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>2D array of shape (N,nao) Or 3D array of shape (*,N,nao) to store AO
values on grids.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># 100 random points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(100, 24)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 100, 24)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.expand_etb">
<code class="descname">expand_etb</code><span class="sig-paren">(</span><em>l</em>, <em>n</em>, <em>alpha</em>, <em>beta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.expand_etb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.expand_etb" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the exponents of even tempered basis for <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code>.
.. math:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span>\<span class="n">alpha</span> <span class="o">*</span> \<span class="n">beta</span><span class="o">^</span><span class="p">{</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">}}</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">..</span> <span class="n">n</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>l</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Angular momentum</dd>
<dt>n</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of GTOs</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[[1, [6.0, 1]], [1, [3.0, 1]], [1, [1.5, 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.expand_etbs">
<code class="descname">expand_etbs</code><span class="sig-paren">(</span><em>etbs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.expand_etbs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.expand_etbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#pyscf.gto.mole.expand_etb" title="pyscf.gto.mole.expand_etb"><code class="xref py py-func docutils literal"><span class="pre">expand_etb()</span></code></a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd>etbs = [(l, n, alpha, beta), (l, n, alpha, beta),...]</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.format_atom">
<code class="descname">format_atom</code><span class="sig-paren">(</span><em>atom</em>, <em>origin=0</em>, <em>axes=None</em>, <em>unit='Ang'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.format_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.format_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal"><span class="pre">Mole.atom</span></code> to the internal data format.
Including, changing the nuclear charge to atom symbol, converting the
coordinates to AU, rotate and shift the molecule.
If the <code class="xref py py-attr docutils literal"><span class="pre">atom</span></code> is a string, it takes &#8221;;&#8221; and &#8220;n&#8221;
for the mark to separate atoms;  &#8221;,&#8221; and arbitrary length of blank space
to spearate the individual terms for an atom.  Blank line will be ignored.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atoms</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list or str</span><dd>the same to <code class="xref py py-attr docutils literal"><span class="pre">Mole.atom</span></code></dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>origin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>new axis origin.</dd>
<dt>axes</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>(new_x, new_y, new_z), new coordinates</dd>
<dt>unit</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or number</span><dd>If unit is one of strings (B, b, Bohr, bohr, AU, au), the coordinates
of the input atoms are the atomic unit;  If unit is one of strings
(A, a, Angstrom, angstrom, Ang, ang), the coordinates are in the
unit of angstrom;  If a number is given, the number are considered
as the Bohr value (in angstrom), which should be around 0.53</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>&#8220;atoms&#8221; in the internal format. The internal format is</dt>
<dd><div class="first last line-block">
<div class="line">atom = [[atom1, (x, y, z)],</div>
<div class="line-block">
<div class="line">[atom2, (x, y, z)],</div>
<div class="line">...</div>
<div class="line">[atomN, (x, y, z)]]</div>
</div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">(</span><span class="s1">&#39;9,0,0,0; h@1 0 0 1&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H@1&#39;, [-1.0, -1.0, 0.0]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">([</span><span class="s1">&#39;9,0,0,0&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))],</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H&#39;, [-1, -1, 0]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.format_basis">
<code class="descname">format_basis</code><span class="sig-paren">(</span><em>basis_tab</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.format_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.format_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code> to the internal data format.</p>
<dl class="docutils">
<dt><a href="#id26"><span class="problematic" id="id27">``</span></a>{ atom: [(l, ((-exp, c_1, c_2, ..),</dt>
<dd><blockquote class="first">
<div>(-exp, c_1, c_2, ..))),</div></blockquote>
<dl class="last docutils">
<dt>(l, ((-exp, c_1, c_2, ..),</dt>
<dd>(-exp, c_1, c_2, ..)))], ... }``</dd>
</dl>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>basis_tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>Similar to <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code>, it <strong>cannot</strong> be a str</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_basis</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span> <span class="s1">&#39;H^2&#39;</span><span class="p">:</span> <span class="s1">&#39;3-21g&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[0,</span>
<span class="go">    [3.4252509099999999, 0.15432897000000001],</span>
<span class="go">    [0.62391373000000006, 0.53532813999999995],</span>
<span class="go">    [0.16885539999999999, 0.44463454000000002]]],</span>
<span class="go"> &#39;H^2&#39;: [[0,</span>
<span class="go">    [5.4471780000000001, 0.15628500000000001],</span>
<span class="go">    [0.82454700000000003, 0.90469100000000002]],</span>
<span class="go">    [0, [0.18319199999999999, 1.0]]]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.format_ecp">
<code class="descname">format_ecp</code><span class="sig-paren">(</span><em>ecp_tab</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.format_ecp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.format_ecp" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal"><span class="pre">ecp</span></code> (dict) to the internal data format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span><span class="n">nelec</span><span class="p">,</span>  <span class="c1"># core electrons</span>
</pre></div>
</div>
<blockquote>
<div><blockquote>
<div><dl class="docutils">
<dt>((l,  # l=-1 for UL, l&gt;=0 for Ul to indicate <a href="#id56"><span class="problematic" id="id57">|l&gt;&lt;l|</span></a></dt>
<dd><dl class="first last docutils">
<dt>(((exp_1, c_1),  # for r^0</dt>
<dd><blockquote class="first">
<div>(exp_2, c_2),
...),</div></blockquote>
<dl class="last docutils">
<dt>((exp_1, c_1),  # for r^1</dt>
<dd>(exp_2, c_2),
...),</dd>
<dt>((exp_1, c_1),  # for r^2</dt>
<dd>...))))),</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>...}</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.fromfile">
<code class="descname">fromfile</code><span class="sig-paren">(</span><em>filename</em>, <em>format=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.fromfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.fromfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the Mole object based on the input geometry file</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.fromstring">
<code class="descname">fromstring</code><span class="sig-paren">(</span><em>string</em>, <em>format='xyz'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.fromstring"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.fromstring" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the Mole object based on the input geometry string</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.gto_norm">
<code class="descname">gto_norm</code><span class="sig-paren">(</span><em>l</em>, <em>expnt</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.gto_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.gto_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalized factor for GTO radial part   <span class="math">\(g=r^l e^{-\alpha r^2}\)</span></p>
<div class="math">
\[\frac{1}{\sqrt{\int g^2 r^2 dr}}
= \sqrt{\frac{2^{2l+3} (l+1)! (2a)^{l+1.5}}{(2l+2)!\sqrt{\pi}}}\]</div>
<p>Ref: H. B. Schlegel and M. J. Frisch, Int. J. Quant.  Chem., 54(1995), 83-87.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>l (int):</dt>
<dd>angular momentum</dd>
<dt>expnt :</dt>
<dd>exponent <span class="math">\(\alpha\)</span></dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>normalization factor</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gto_norm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">2.5264751109842591</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.has_ecp">
<code class="descname">has_ecp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.has_ecp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.has_ecp" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether pseudo potential is used in the system.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.intor">
<code class="descname">intor</code><span class="sig-paren">(</span><em>intor</em>, <em>comp=None</em>, <em>hermi=0</em>, <em>aosym='s1'</em>, <em>out=None</em>, <em>shls_slice=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.intor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.intor" title="Permalink to this definition">¶</a></dt>
<dd><p>Integral generator.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>intor</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Name of the 1e or 2e AO integrals.  Ref to <code class="xref py py-func docutils literal"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Symmetry of the integrals</p>
<div class="last line-block">
<div class="line">0 : no symmetry assumed (default)</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ipnuc_sph&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># &lt;nabla i | V_nuc | j&gt;</span>
<span class="go">[[[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.10289944  0.48176097]</span>
<span class="go">  [-0.48176097 -0.10289944]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j -0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j -0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.intor_asymmetric">
<code class="descname">intor_asymmetric</code><span class="sig-paren">(</span><em>intor</em>, <em>comp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.intor_asymmetric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.intor_asymmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>One-electron integral generator. The integrals are assumed to be anti-hermitian</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>intor</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Name of the 1-electron integral.  Ref to <code class="xref py py-func docutils literal"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Components of the integrals, e.g. int1e_ipovlp has 3 components.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor_asymmetric</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j  0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j  0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.intor_by_shell">
<code class="descname">intor_by_shell</code><span class="sig-paren">(</span><em>intor</em>, <em>shells</em>, <em>comp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.intor_by_shell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.intor_by_shell" title="Permalink to this definition">¶</a></dt>
<dd><p>For given 2, 3 or 4 shells, interface for libcint to get 1e, 2e,
2-center-2e or 3-center-2e integrals</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>intor_name</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>See also <code class="xref py py-func docutils literal"><span class="pre">getints()</span></code> for the supported intor_name</dd>
<dt>shls</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span><dd>The AO shell-ids of the integrals</dd>
<dt>atm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>bas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>env</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float64 ndarray</span><dd>libcint integral function argument</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Components of the integrals, e.g. int1e_ipovlp has 3 components.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>ndarray of 2-dim to 5-dim, depending on the integral type (1e,
2e, 3c-2e, 2c2e) and the value of comp</dd>
<dt>Examples:</dt>
<dd>The gradients of the spherical 2e integrals</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">getints_by_shell</span><span class="p">(</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[[[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.08760462]]]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.intor_symmetric">
<code class="descname">intor_symmetric</code><span class="sig-paren">(</span><em>intor</em>, <em>comp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.intor_symmetric"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.intor_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>One-electron integral generator. The integrals are assumed to be hermitian</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>intor</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Name of the 1-electron integral.  Ref to <code class="xref py py-func docutils literal"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor_symmetric</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j -0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j -0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.kernel">
<code class="descname">kernel</code><span class="sig-paren">(</span><em>dump_input=True</em>, <em>parse_arg=True</em>, <em>verbose=None</em>, <em>output=None</em>, <em>max_memory=None</em>, <em>atom=None</em>, <em>basis=None</em>, <em>unit=None</em>, <em>nucmod=None</em>, <em>ecp=None</em>, <em>charge=None</em>, <em>spin=0</em>, <em>symmetry=None</em>, <em>symmetry_subgroup=None</em>, <em>cart=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup moleclue and initialize some control parameters.  Whenever you
change the value of the attributes of <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a>, you need call
this function to refresh the internal data of Mole.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dump_input</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>whether to dump the contents of input file in the output file</dd>
<dt>parse_arg</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>whether to read the sys.argv and overwrite the relevant parameters</dd>
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>output</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span><dd>Output file.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.output</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int, float</span><dd>Allowd memory in MB.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>atom</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list or str</span><dd>To define molecluar structure.</dd>
<dt>basis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>To define basis set.</dd>
<dt>nucmod</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>Nuclear model.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.nucmod</span></code></dd>
<dt>charge</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Charge of molecule. It affects the electron numbers
If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.charge</span></code></dd>
<dt>spin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>2S, num. alpha electrons - num. beta electrons to control
multiplicity. If setting spin = None , multiplicity will be
guessed based on the neutral molecule.
If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.spin</span></code></dd>
<dt>symmetry</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool or str</span><dd>Whether to use symmetry.  If given a string of point group
name, the given point group symmetry will be used.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>molstr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.loads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialize a str containing a JSON document to a Mole object.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.make_atm_env">
<code class="descname">make_atm_env</code><span class="sig-paren">(</span><em>atom</em>, <em>ptr=0</em>, <em>nucmod=1</em>, <em>nucprop=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.make_atm_env"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.make_atm_env" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the internal format <code class="xref py py-attr docutils literal"><span class="pre">Mole._atom</span></code> to the format required
by <code class="docutils literal"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.make_bas_env">
<code class="descname">make_bas_env</code><span class="sig-paren">(</span><em>basis_add</em>, <em>atom_id=0</em>, <em>ptr=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.make_bas_env"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.make_bas_env" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code> to the argument <code class="docutils literal"><span class="pre">bas</span></code> for <code class="docutils literal"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.make_ecp_env">
<code class="descname">make_ecp_env</code><span class="sig-paren">(</span><em>_atm</em>, <em>_ecp</em>, <em>pre_env=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.make_ecp_env"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.make_ecp_env" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the input arguments _ecpbas for ECP integrals</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.make_env">
<code class="descname">make_env</code><span class="sig-paren">(</span><em>atoms</em>, <em>basis</em>, <em>pre_env=[]</em>, <em>nucmod={}</em>, <em>nucprop=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.make_env"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.make_env" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the input arguments for <code class="docutils literal"><span class="pre">libcint</span></code> library based on internal
format <code class="xref py py-attr docutils literal"><span class="pre">Mole._atom</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">Mole._basis</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyscf.gto.mole.Mole.ms">
<code class="descname">ms</code><a class="headerlink" href="#pyscf.gto.mole.Mole.ms" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin quantum number. multiplicity = ms*2+1</p>
</dd></dl>

<dl class="attribute">
<dt id="pyscf.gto.mole.Mole.nao">
<code class="descname">nao</code><a class="headerlink" href="#pyscf.gto.mole.Mole.nao" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of contracted GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.nao_2c">
<code class="descname">nao_2c</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.nao_2c" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of contracted spinor GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.nao_2c_range">
<code class="descname">nao_2c_range</code><span class="sig-paren">(</span><em>mol</em>, <em>bas_id0</em>, <em>bas_id1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.nao_2c_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower and upper boundary of contracted spinor basis functions associated
with the given shell range</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mol :</dt>
<dd><a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</dd>
<dt>bas_id0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>start shell id, 0-based</dd>
<dt>bas_id1</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>stop shell id, 0-based</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>tupel of start basis function id and the stop function id</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_2c_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(4, 12)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.nao_cart">
<code class="descname">nao_cart</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.nao_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of contracted cartesian GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.nao_nr">
<code class="descname">nao_nr</code><span class="sig-paren">(</span><em>mol</em>, <em>cart=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.nao_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of contracted GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.nao_nr_range">
<code class="descname">nao_nr_range</code><span class="sig-paren">(</span><em>mol</em>, <em>bas_id0</em>, <em>bas_id1</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.nao_nr_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower and upper boundary of contracted spherical basis functions associated
with the given shell range</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mol :</dt>
<dd><a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</dd>
<dt>bas_id0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>start shell id</dd>
<dt>bas_id1</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>stop shell id</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>tupel of start basis function id and the stop function id</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_nr_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(2, 6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.npgto_nr">
<code class="descname">npgto_nr</code><span class="sig-paren">(</span><em>mol</em>, <em>cart=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.npgto_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of primitive spherical GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.offset_2c_by_atom">
<code class="descname">offset_2c_by_atom</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.offset_2c_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.offset_ao_by_atom">
<code class="descname">offset_ao_by_atom</code><span class="sig-paren">(</span><em>mol</em>, <em>ao_loc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.offset_ao_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.offset_nr_by_atom">
<code class="descname">offset_nr_by_atom</code><span class="sig-paren">(</span><em>mol</em>, <em>ao_loc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.offset_nr_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.pack">
<code class="descname">pack</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.pack" title="Permalink to this definition">¶</a></dt>
<dd><p>Pack the input args of <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> to a dict.</p>
<p>Note this function only pack the input arguments (not the entire Mole
class).  Modifications to mol._atm, mol._bas, mol._env are not tracked.
Use <a class="reference internal" href="#pyscf.gto.mole.dumps" title="pyscf.gto.mole.dumps"><code class="xref py py-func docutils literal"><span class="pre">dumps()</span></code></a> to serialize the entire Mole object.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.search_ao_label">
<code class="descname">search_ao_label</code><span class="sig-paren">(</span><em>mol</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.search_ao_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index of the AO basis function based on the given ao_label</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ao_label</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">string or a list of strings</span><dd>The regular expression pattern to match the orbital labels
returned by mol.ao_labels()</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list of index for the AOs that matches the given ao_label RE pattern</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl.*p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21 22 23 24 25 26 27 28 29 30]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl 2p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">([</span><span class="s1">&#39;Cl.*d&#39;</span><span class="p">,</span> <span class="s1">&#39;Cl 4p&#39;</span><span class="p">])</span>
<span class="go">[25 26 27 31 32 33 34 35 36 37 38 39 40]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.search_ao_nr">
<code class="descname">search_ao_nr</code><span class="sig-paren">(</span><em>mol</em>, <em>atm_id</em>, <em>l</em>, <em>m</em>, <em>atmshell</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.search_ao_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the first basis function id (<strong>not</strong> the shell id) which matches
the given atom-id, angular momentum magnetic angular momentum, principal shell.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>atom id, 0-based</dd>
<dt>l</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>angular momentum</dd>
<dt>m</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>magnetic angular momentum</dd>
<dt>atmshell</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>principal quantum number</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>basis function id, 0-based.  If not found, return None</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_nr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Cl 3px</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_common_orig">
<code class="descname">set_common_orig</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.set_common_orig" title="Permalink to this definition">¶</a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_common_orig_">
<code class="descname">set_common_orig_</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.set_common_orig_" title="Permalink to this definition">¶</a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_common_origin">
<code class="descname">set_common_origin</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_common_origin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.set_common_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_common_origin_">
<code class="descname">set_common_origin_</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.set_common_origin_" title="Permalink to this definition">¶</a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_f12_zeta">
<code class="descname">set_f12_zeta</code><span class="sig-paren">(</span><em>zeta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_f12_zeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.set_f12_zeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Set zeta for YP exp(-zeta r12)/r12 or STG exp(-zeta r12) type integrals</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_geom_">
<code class="descname">set_geom_</code><span class="sig-paren">(</span><em>atoms_or_coords</em>, <em>unit=None</em>, <em>symmetry=None</em>, <em>inplace=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_geom_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.set_geom_" title="Permalink to this definition">¶</a></dt>
<dd><p>Update geometry</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_nuc_mod">
<code class="descname">set_nuc_mod</code><span class="sig-paren">(</span><em>atm_id</em>, <em>zeta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_nuc_mod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.set_nuc_mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the nuclear charge distribution of the given atom ID.  The charge
distribution is defined as: rho(r) = nuc_charge * Norm * exp(-zeta * r^2).
This function can <strong>only</strong> be called after .build() method is executed.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zeta</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">filatov_nuc_mod</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">set_nuc_mod</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_nuc_mod_">
<code class="descname">set_nuc_mod_</code><span class="sig-paren">(</span><em>atm_id</em>, <em>zeta</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.set_nuc_mod_" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the nuclear charge distribution of the given atom ID.  The charge
distribution is defined as: rho(r) = nuc_charge * Norm * exp(-zeta * r^2).
This function can <strong>only</strong> be called after .build() method is executed.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zeta</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">filatov_nuc_mod</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">set_nuc_mod</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_range_coulomb">
<code class="descname">set_range_coulomb</code><span class="sig-paren">(</span><em>omega</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_range_coulomb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.set_range_coulomb" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the long range part of range-separated Coulomb operator for
<strong>all</strong> 2e integrals
erf(omega r12) / r12
set omega to 0 to siwtch off the range-separated Coulomb</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_range_coulomb_">
<code class="descname">set_range_coulomb_</code><span class="sig-paren">(</span><em>omega</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.set_range_coulomb_" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the long range part of range-separated Coulomb operator for
<strong>all</strong> 2e integrals
erf(omega r12) / r12
set omega to 0 to siwtch off the range-separated Coulomb</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_rinv_orig">
<code class="descname">set_rinv_orig</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.set_rinv_orig" title="Permalink to this definition">¶</a></dt>
<dd><p>Update origin for operator <span class="math">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_rinv_orig_">
<code class="descname">set_rinv_orig_</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.set_rinv_orig_" title="Permalink to this definition">¶</a></dt>
<dd><p>Update origin for operator <span class="math">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_rinv_origin">
<code class="descname">set_rinv_origin</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_rinv_origin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.set_rinv_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Update origin for operator <span class="math">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_rinv_origin_">
<code class="descname">set_rinv_origin_</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.set_rinv_origin_" title="Permalink to this definition">¶</a></dt>
<dd><p>Update origin for operator <span class="math">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_rinv_zeta">
<code class="descname">set_rinv_zeta</code><span class="sig-paren">(</span><em>zeta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_rinv_zeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.set_rinv_zeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume the charge distribution on the &#8220;rinv_origin&#8221;.  zeta is the parameter
to control the charge distribution: rho(r) = Norm * exp(-zeta * r^2).
<strong>Be careful</strong> when call this function. It affects the behavior of
int1e_rinv_* functions.  Make sure to set it back to 0 after using it!</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.set_rinv_zeta_">
<code class="descname">set_rinv_zeta_</code><span class="sig-paren">(</span><em>zeta</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.set_rinv_zeta_" title="Permalink to this definition">¶</a></dt>
<dd><p>Assume the charge distribution on the &#8220;rinv_origin&#8221;.  zeta is the parameter
to control the charge distribution: rho(r) = Norm * exp(-zeta * r^2).
<strong>Be careful</strong> when call this function. It affects the behavior of
int1e_rinv_* functions.  Make sure to set it back to 0 after using it!</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.sph2spinor_coeff">
<code class="descname">sph2spinor_coeff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.sph2spinor_coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.sph2spinor_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformation matrix that transforms real-spherical GTOs to spinor
GTOs for all basis functions</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca</span><span class="p">,</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">sph2spinor_coeff</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_spinor&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ca</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">+=</span> <span class="n">cb</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">s0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">6.66133814775e-16</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.sph_labels">
<code class="descname">sph_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.sph_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.spheric_labels">
<code class="descname">spheric_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.spheric_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.spinor_labels">
<code class="descname">spinor_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.spinor_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Labels of spinor GTO functions</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.time_reversal_map">
<code class="descname">time_reversal_map</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.time_reversal_map" title="Permalink to this definition">¶</a></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have postive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.tmap">
<code class="descname">tmap</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.tmap" title="Permalink to this definition">¶</a></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have postive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.to_uncontracted_cartesian_basis">
<code class="descname">to_uncontracted_cartesian_basis</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.to_uncontracted_cartesian_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Decontract the basis of a Mole or a Cell.  Returns a Mole (Cell) object
with the uncontracted basis environment and a list of coefficients that
transform the uncontracted cartesian basis to the original basis.  Each
element in the list corresponds to one shell of the original Mole (Cell).</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Ne&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pmol</span><span class="p">,</span> <span class="n">ctr_coeff</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">to_uncontracted_cartesian_basis</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">ctr_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pmol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.tofile">
<code class="descname">tofile</code><span class="sig-paren">(</span><em>mol</em>, <em>filename</em>, <em>format=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.tofile" title="Permalink to this definition">¶</a></dt>
<dd><p>Write molecular geometry to a file of the required format.</p>
<dl class="docutils">
<dt>Supported output formats:</dt>
<dd><div class="first last line-block">
<div class="line">raw: Each line is  &lt;symobl&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;</div>
<div class="line">xyz: XYZ cartesian coordinates format</div>
<div class="line">zmat: Z-matrix format</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.tostring">
<code class="descname">tostring</code><span class="sig-paren">(</span><em>mol</em>, <em>format='raw'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.tostring" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert molecular geometry to a string of the required format.</p>
<dl class="docutils">
<dt>Supported output formats:</dt>
<dd><div class="first last line-block">
<div class="line">raw: Each line is  &lt;symobl&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;</div>
<div class="line">xyz: XYZ cartesian coordinates format</div>
<div class="line">zmat: Z-matrix format</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.tot_electrons">
<code class="descname">tot_electrons</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.tot_electrons" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of electrons for the given molecule</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>electron number in integer</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 1 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">tot_electrons</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.unpack">
<code class="descname">unpack</code><span class="sig-paren">(</span><em>moldic</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.unpack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.unpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack a dict which is packed by <a class="reference internal" href="#pyscf.gto.mole.pack" title="pyscf.gto.mole.pack"><code class="xref py py-func docutils literal"><span class="pre">pack()</span></code></a>, to generate the input
arguments for <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object.</p>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.with_common_orig">
<code class="descname">with_common_orig</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.with_common_orig" title="Permalink to this definition">¶</a></dt>
<dd><p>Retuen a temporary mol context which has the rquired common origin.
The required common origin has no effects out of the temporary context.
See also <code class="xref py py-func docutils literal"><span class="pre">mol.set_common_origin()</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_r&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.with_common_origin">
<code class="descname">with_common_origin</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.with_common_origin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.with_common_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Retuen a temporary mol context which has the rquired common origin.
The required common origin has no effects out of the temporary context.
See also <code class="xref py py-func docutils literal"><span class="pre">mol.set_common_origin()</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_r&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.with_range_coulomb">
<code class="descname">with_range_coulomb</code><span class="sig-paren">(</span><em>omega</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.with_range_coulomb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.with_range_coulomb" title="Permalink to this definition">¶</a></dt>
<dd><p>Retuen a temporary mol context which has the required parameter
omega for long range part of range-separated Coulomb operator.
If omega = None, it will be treated as the regular Coulomb operator.
See also <code class="xref py py-func docutils literal"><span class="pre">mol.set_range_coulomb()</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_range_coulomb</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int2e&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.with_rinv_as_nucleus">
<code class="descname">with_rinv_as_nucleus</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.with_rinv_as_nucleus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.with_rinv_as_nucleus" title="Permalink to this definition">¶</a></dt>
<dd><p>Retuen a temporary mol context in which the rinv operator (1/r) is
treated like the Coulomb potential of a Gaussian charge distribution
rho(r) = Norm * exp(-zeta * r^2) at the place of the input atm_id.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_as_nucleus</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.with_rinv_orig">
<code class="descname">with_rinv_orig</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.Mole.with_rinv_orig" title="Permalink to this definition">¶</a></dt>
<dd><p>Retuen a temporary mol context which has the rquired origin of 1/r
operator.  The required origin has no effects out of the temporary
context.  See also <code class="xref py py-func docutils literal"><span class="pre">mol.set_rinv_origin()</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.with_rinv_origin">
<code class="descname">with_rinv_origin</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.with_rinv_origin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.with_rinv_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Retuen a temporary mol context which has the rquired origin of 1/r
operator.  The required origin has no effects out of the temporary
context.  See also <code class="xref py py-func docutils literal"><span class="pre">mol.set_rinv_origin()</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyscf.gto.mole.Mole.with_rinv_zeta">
<code class="descname">with_rinv_zeta</code><span class="sig-paren">(</span><em>zeta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.with_rinv_zeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.Mole.with_rinv_zeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Retuen a temporary mol context which has the rquired Gaussian charge
distribution placed at &#8220;rinv_origin&#8221;: rho(r) = Norm * exp(-zeta * r^2).
See also <code class="xref py py-func docutils literal"><span class="pre">mol.set_rinv_zeta()</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_zeta</span><span class="p">(</span><span class="n">zeta</span><span class="o">=</span><span class="mf">1.5</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.ao_labels">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">ao_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#ao_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.ao_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Labels of AO basis functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>fmt</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or bool</span><dd>if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-AO-notation)]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.ao_loc_2c">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">ao_loc_2c</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#ao_loc_2c"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.ao_loc_2c" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset of every shell in the spinor basis function spectrum</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>list, each entry is the corresponding start id of spinor function</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_2c</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 2, 4, 6, 12, 18, 20, 22, 24, 30, 36]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.ao_loc_nr">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">ao_loc_nr</code><span class="sig-paren">(</span><em>mol</em>, <em>cart=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#ao_loc_nr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.ao_loc_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>list, each entry is the corresponding start basis function id</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.aoslice_by_atom">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">aoslice_by_atom</code><span class="sig-paren">(</span><em>mol</em>, <em>ao_loc=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#aoslice_by_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.aoslice_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.atom_mass_list">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">atom_mass_list</code><span class="sig-paren">(</span><em>mol</em>, <em>isotope_avg=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#atom_mass_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.atom_mass_list" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of mass for all atoms in the molecule</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>isotope_avg</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to use the isotope average mass as the atomic mass</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.atom_types">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">atom_types</code><span class="sig-paren">(</span><em>atoms</em>, <em>basis=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#atom_types"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.atom_types" title="Permalink to this definition">¶</a></dt>
<dd><p>symmetry inequivalent atoms</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.cart2j_kappa">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">cart2j_kappa</code><span class="sig-paren">(</span><em>kappa</em>, <em>l=None</em>, <em>normalized=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.cart2j_kappa" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian to spinor transformation matrix for kappa</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>normalized :</dt>
<dd>How the Cartesian GTOs are normalized.  &#8216;sp&#8217; means the s and p
functions are normalized.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.cart2j_l">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">cart2j_l</code><span class="sig-paren">(</span><em>l</em>, <em>normalized=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.cart2j_l" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian to spinor transformation matrix for angular moment l</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.cart2sph">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">cart2sph</code><span class="sig-paren">(</span><em>l</em>, <em>c_tensor=None</em>, <em>normalized=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#cart2sph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.cart2sph" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian to real spherical transformation matrix</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>normalized :</dt>
<dd>How the Cartesian GTOs are normalized.  &#8216;sp&#8217; means the s and p
functions are normalized.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.cart2spinor_kappa">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">cart2spinor_kappa</code><span class="sig-paren">(</span><em>kappa</em>, <em>l=None</em>, <em>normalized=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#cart2spinor_kappa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.cart2spinor_kappa" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian to spinor transformation matrix for kappa</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>normalized :</dt>
<dd>How the Cartesian GTOs are normalized.  &#8216;sp&#8217; means the s and p
functions are normalized.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.cart2spinor_l">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">cart2spinor_l</code><span class="sig-paren">(</span><em>l</em>, <em>normalized=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#cart2spinor_l"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.cart2spinor_l" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian to spinor transformation matrix for angular moment l</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.cart2zmat">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">cart2zmat</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#cart2zmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.cart2zmat" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">((</span>
<span class="go">(0.000000000000,  1.889726124565,  0.000000000000),</span>
<span class="go">(0.000000000000,  0.000000000000, -1.889726124565),</span>
<span class="go">(1.889726124565, -1.889726124565,  0.000000000000),</span>
<span class="go">(1.889726124565,  0.000000000000,  1.133835674739)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cart2zmat</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="go">1</span>
<span class="go">1 2.67247631453057</span>
<span class="go">1 4.22555607338457 2 50.7684795164077</span>
<span class="go">1 2.90305235726773 2 79.3904651036893 3 6.20854462618583</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.cart_labels">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">cart_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#cart_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.cart_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Labels of Cartesian GTO functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-xyz-notation)]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.chiral_mol">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">chiral_mol</code><span class="sig-paren">(</span><em>mol1</em>, <em>mol2=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#chiral_mol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.chiral_mol" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect whether the given molelcule is chiral molecule or two molecules
are chiral isomers.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.conc_env">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">conc_env</code><span class="sig-paren">(</span><em>atm1</em>, <em>bas1</em>, <em>env1</em>, <em>atm2</em>, <em>bas2</em>, <em>env2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#conc_env"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.conc_env" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate two Mole&#8217;s integral parameters.  This function can be used
to construct the environment for cross integrals like</p>
<div class="math">
\[\langle \mu | \nu \rangle, \mu \in mol1, \nu \in mol2\]</div>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Concatenated atm, bas, env</dd>
<dt>Examples:</dt>
<dd>Compute the overlap between H2 molecule and O atom</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol1</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 1 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol2</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atm3</span><span class="p">,</span> <span class="n">bas3</span><span class="p">,</span> <span class="n">env3</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">conc_env</span><span class="p">(</span><span class="n">mol1</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">mol1</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">mol1</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span>
<span class="gp">... </span>                                <span class="n">mol2</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">mol2</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">mol2</span><span class="o">.</span><span class="n">_env</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">moleintor</span><span class="o">.</span><span class="n">getints</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">,</span> <span class="n">atm3</span><span class="p">,</span> <span class="n">bas3</span><span class="p">,</span> <span class="n">env3</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="go">[[ 0.04875181  0.44714688  0.          0.37820346  0.        ]</span>
<span class="go"> [ 0.04875181  0.44714688  0.          0.          0.37820346]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.conc_mol">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">conc_mol</code><span class="sig-paren">(</span><em>mol1</em>, <em>mol2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#conc_mol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.conc_mol" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate two Mole objects.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.condense_to_shell">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">condense_to_shell</code><span class="sig-paren">(</span><em>mol</em>, <em>mat</em>, <em>compressor=&lt;function amax&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#condense_to_shell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.condense_to_shell" title="Permalink to this definition">¶</a></dt>
<dd><p>The given matrix is first partitioned to blocks, based on AO shell as
delimiter.  Then call compressor function to abstract each block.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.copy">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">copy</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Deepcopy of the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.dumps">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">dumps</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#dumps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Serialize Mole object to a JSON formatted str.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.dyall_nuc_mod">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">dyall_nuc_mod</code><span class="sig-paren">(</span><em>nuc_charge</em>, <em>nucprop={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#dyall_nuc_mod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.dyall_nuc_mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the nuclear charge distribution parameter zeta
rho(r) = nuc_charge * Norm * exp(-zeta * r^2)</p>
<p>Ref. L. Visscher and K. Dyall, At. Data Nucl. Data Tables, 67, 207 (1997)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.energy_nuc">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">energy_nuc</code><span class="sig-paren">(</span><em>mol</em>, <em>charges=None</em>, <em>coords=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#energy_nuc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.energy_nuc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute nuclear repulsion energy (AU) or static Coulomb energy</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>float</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.etbs">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">etbs</code><span class="sig-paren">(</span><em>etbs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.etbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#pyscf.gto.mole.expand_etb" title="pyscf.gto.mole.expand_etb"><code class="xref py py-func docutils literal"><span class="pre">expand_etb()</span></code></a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd>etbs = [(l, n, alpha, beta), (l, n, alpha, beta),...]</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.expand_etb">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">expand_etb</code><span class="sig-paren">(</span><em>l</em>, <em>n</em>, <em>alpha</em>, <em>beta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#expand_etb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.expand_etb" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the exponents of even tempered basis for <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code>.
.. math:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span>\<span class="n">alpha</span> <span class="o">*</span> \<span class="n">beta</span><span class="o">^</span><span class="p">{</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">}}</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">..</span> <span class="n">n</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>l</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Angular momentum</dd>
<dt>n</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of GTOs</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[[1, [6.0, 1]], [1, [3.0, 1]], [1, [1.5, 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.expand_etbs">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">expand_etbs</code><span class="sig-paren">(</span><em>etbs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#expand_etbs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.expand_etbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#pyscf.gto.mole.expand_etb" title="pyscf.gto.mole.expand_etb"><code class="xref py py-func docutils literal"><span class="pre">expand_etb()</span></code></a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd>etbs = [(l, n, alpha, beta), (l, n, alpha, beta),...]</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.fakemol_for_charges">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">fakemol_for_charges</code><span class="sig-paren">(</span><em>coords</em>, <em>expnt=1e+16</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#fakemol_for_charges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.fakemol_for_charges" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a fake Mole object that holds the charges on the given
coordinates (coords).  The shape of the charge can be a normal
distribution with the Gaussian exponent (expnt).</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.filatov_nuc_mod">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">filatov_nuc_mod</code><span class="sig-paren">(</span><em>nuc_charge</em>, <em>nucprop={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#filatov_nuc_mod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.filatov_nuc_mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the nuclear charge distribution parameter zeta
rho(r) = nuc_charge * Norm * exp(-zeta * r^2)</p>
<dl class="docutils">
<dt>Ref. M. Filatov and D. Cremer, Theor. Chem. Acc. 108, 168 (2002)</dt>
<dd><ol class="first last upperalpha simple" start="13">
<li>Filatov and D. Cremer, Chem. Phys. Lett. 351, 259 (2002)</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.format_atom">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">format_atom</code><span class="sig-paren">(</span><em>atoms</em>, <em>origin=0</em>, <em>axes=None</em>, <em>unit='angstrom'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#format_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.format_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal"><span class="pre">Mole.atom</span></code> to the internal data format.
Including, changing the nuclear charge to atom symbol, converting the
coordinates to AU, rotate and shift the molecule.
If the <code class="xref py py-attr docutils literal"><span class="pre">atom</span></code> is a string, it takes &#8221;;&#8221; and &#8220;n&#8221;
for the mark to separate atoms;  &#8221;,&#8221; and arbitrary length of blank space
to spearate the individual terms for an atom.  Blank line will be ignored.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atoms</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list or str</span><dd>the same to <code class="xref py py-attr docutils literal"><span class="pre">Mole.atom</span></code></dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>origin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>new axis origin.</dd>
<dt>axes</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>(new_x, new_y, new_z), new coordinates</dd>
<dt>unit</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or number</span><dd>If unit is one of strings (B, b, Bohr, bohr, AU, au), the coordinates
of the input atoms are the atomic unit;  If unit is one of strings
(A, a, Angstrom, angstrom, Ang, ang), the coordinates are in the
unit of angstrom;  If a number is given, the number are considered
as the Bohr value (in angstrom), which should be around 0.53</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>&#8220;atoms&#8221; in the internal format. The internal format is</dt>
<dd><div class="first last line-block">
<div class="line">atom = [[atom1, (x, y, z)],</div>
<div class="line-block">
<div class="line">[atom2, (x, y, z)],</div>
<div class="line">...</div>
<div class="line">[atomN, (x, y, z)]]</div>
</div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">(</span><span class="s1">&#39;9,0,0,0; h@1 0 0 1&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H@1&#39;, [-1.0, -1.0, 0.0]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">([</span><span class="s1">&#39;9,0,0,0&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))],</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H&#39;, [-1, -1, 0]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.format_basis">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">format_basis</code><span class="sig-paren">(</span><em>basis_tab</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#format_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.format_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code> to the internal data format.</p>
<dl class="docutils">
<dt><a href="#id28"><span class="problematic" id="id29">``</span></a>{ atom: [(l, ((-exp, c_1, c_2, ..),</dt>
<dd><blockquote class="first">
<div>(-exp, c_1, c_2, ..))),</div></blockquote>
<dl class="last docutils">
<dt>(l, ((-exp, c_1, c_2, ..),</dt>
<dd>(-exp, c_1, c_2, ..)))], ... }``</dd>
</dl>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>basis_tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>Similar to <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code>, it <strong>cannot</strong> be a str</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_basis</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span> <span class="s1">&#39;H^2&#39;</span><span class="p">:</span> <span class="s1">&#39;3-21g&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[0,</span>
<span class="go">    [3.4252509099999999, 0.15432897000000001],</span>
<span class="go">    [0.62391373000000006, 0.53532813999999995],</span>
<span class="go">    [0.16885539999999999, 0.44463454000000002]]],</span>
<span class="go"> &#39;H^2&#39;: [[0,</span>
<span class="go">    [5.4471780000000001, 0.15628500000000001],</span>
<span class="go">    [0.82454700000000003, 0.90469100000000002]],</span>
<span class="go">    [0, [0.18319199999999999, 1.0]]]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.format_ecp">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">format_ecp</code><span class="sig-paren">(</span><em>ecp_tab</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#format_ecp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.format_ecp" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal"><span class="pre">ecp</span></code> (dict) to the internal data format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span><span class="n">nelec</span><span class="p">,</span>  <span class="c1"># core electrons</span>
</pre></div>
</div>
<blockquote>
<div><blockquote>
<div><dl class="docutils">
<dt>((l,  # l=-1 for UL, l&gt;=0 for Ul to indicate <a href="#id58"><span class="problematic" id="id59">|l&gt;&lt;l|</span></a></dt>
<dd><dl class="first last docutils">
<dt>(((exp_1, c_1),  # for r^0</dt>
<dd><blockquote class="first">
<div>(exp_2, c_2),
...),</div></blockquote>
<dl class="last docutils">
<dt>((exp_1, c_1),  # for r^1</dt>
<dd>(exp_2, c_2),
...),</dd>
<dt>((exp_1, c_1),  # for r^2</dt>
<dd>...))))),</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>...}</p>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.from_zmatrix">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">from_zmatrix</code><span class="sig-paren">(</span><em>atomstr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#from_zmatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.from_zmatrix" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;H</span>
<span class="go">H 1 2.67247631453057</span>
<span class="go">H 1 4.22555607338457 2 50.7684795164077</span>
<span class="go">H 1 2.90305235726773 2 79.3904651036893 3 6.20854462618583&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">zmat2cart</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[&#39;H&#39;, array([ 0.,  0.,  0.])]</span>
<span class="go">[&#39;H&#39;, array([ 2.67247631,  0.        ,  0.        ])]</span>
<span class="go">[&#39;H&#39;, array([ 2.67247631,  0.        ,  3.27310166])]</span>
<span class="go">[&#39;H&#39;, array([ 0.53449526,  0.30859098,  2.83668811])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.fromfile">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">fromfile</code><span class="sig-paren">(</span><em>filename</em>, <em>format=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#fromfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.fromfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read molecular geometry from a file
(in testing)</p>
<dl class="docutils">
<dt>Supported formats:</dt>
<dd><div class="first last line-block">
<div class="line">raw: Each line is  &lt;symobl&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;</div>
<div class="line">xyz: XYZ cartesian coordinates format</div>
<div class="line">zmat: Z-matrix format</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.fromstring">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">fromstring</code><span class="sig-paren">(</span><em>string</em>, <em>format='xyz'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#fromstring"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.fromstring" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the string of the specified format to internal format
(in testing)</p>
<dl class="docutils">
<dt>Supported formats:</dt>
<dd><div class="first last line-block">
<div class="line">raw: Each line is  &lt;symobl&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;</div>
<div class="line">xyz: XYZ cartesian coordinates format</div>
<div class="line">zmat: Z-matrix format</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.gaussian_int">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">gaussian_int</code><span class="sig-paren">(</span><em>n</em>, <em>alpha</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#gaussian_int"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.gaussian_int" title="Permalink to this definition">¶</a></dt>
<dd><p>int_0^inf x^n exp(-alpha x^2) dx</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.gto_norm">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">gto_norm</code><span class="sig-paren">(</span><em>l</em>, <em>expnt</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#gto_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.gto_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalized factor for GTO radial part   <span class="math">\(g=r^l e^{-\alpha r^2}\)</span></p>
<div class="math">
\[\frac{1}{\sqrt{\int g^2 r^2 dr}}
= \sqrt{\frac{2^{2l+3} (l+1)! (2a)^{l+1.5}}{(2l+2)!\sqrt{\pi}}}\]</div>
<p>Ref: H. B. Schlegel and M. J. Frisch, Int. J. Quant.  Chem., 54(1995), 83-87.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>l (int):</dt>
<dd>angular momentum</dd>
<dt>expnt :</dt>
<dd>exponent <span class="math">\(\alpha\)</span></dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>normalization factor</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gto_norm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">2.5264751109842591</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.inter_distance">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">inter_distance</code><span class="sig-paren">(</span><em>mol</em>, <em>coords=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#inter_distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.inter_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Inter-particle distance array</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.intor_cross">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">intor_cross</code><span class="sig-paren">(</span><em>intor</em>, <em>mol1</em>, <em>mol2</em>, <em>comp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#intor_cross"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.intor_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>1-electron integrals from two molecules like</p>
<div class="math">
\[\langle \mu | intor | \nu \rangle, \mu \in mol1, \nu \in mol2\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>intor</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Name of the 1-electron integral, such as int1e_ovlp_sph (spherical overlap),
int1e_nuc_cart (cartesian nuclear attraction), int1e_ipovlp_spinor
(spinor overlap gradients), etc.  Ref to <code class="xref py py-func docutils literal"><span class="pre">getints()</span></code> for the
full list of available 1-electron integral names</dd>
<dt>mol1, mol2:</dt>
<dd><a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> objects</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</dd>
<dt>Examples:</dt>
<dd>Compute the overlap between H2 molecule and O atom</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol1</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 1 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol2</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">intor_cross</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">,</span> <span class="n">mol1</span><span class="p">,</span> <span class="n">mol2</span><span class="p">)</span>
<span class="go">[[ 0.04875181  0.44714688  0.          0.37820346  0.        ]</span>
<span class="go"> [ 0.04875181  0.44714688  0.          0.          0.37820346]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.is_same_mol">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">is_same_mol</code><span class="sig-paren">(</span><em>mol1</em>, <em>mol2</em>, <em>tol=1e-05</em>, <em>cmp_basis=True</em>, <em>ignore_chiral=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.is_same_mol" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare the two molecules whether they have the same structure.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>In Bohr</dd>
<dt>cmp_basis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to compare basis functions for the two molecules</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.len_cart">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">len_cart</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#len_cart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.len_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of Cartesian function associated with given angular momentum.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.len_spinor">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">len_spinor</code><span class="sig-paren">(</span><em>l</em>, <em>kappa</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#len_spinor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.len_spinor" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of spinor associated with given angular momentum and kappa.  If kappa is 0,
return 4l+2</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.loads">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">loads</code><span class="sig-paren">(</span><em>molstr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#loads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialize a str containing a JSON document to a Mole object.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.make_atm_env">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">make_atm_env</code><span class="sig-paren">(</span><em>atom</em>, <em>ptr=0</em>, <em>nuclear_model=1</em>, <em>nucprop={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#make_atm_env"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.make_atm_env" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the internal format <code class="xref py py-attr docutils literal"><span class="pre">Mole._atom</span></code> to the format required
by <code class="docutils literal"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.make_bas_env">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">make_bas_env</code><span class="sig-paren">(</span><em>basis_add</em>, <em>atom_id=0</em>, <em>ptr=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#make_bas_env"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.make_bas_env" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code> to the argument <code class="docutils literal"><span class="pre">bas</span></code> for <code class="docutils literal"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.make_ecp_env">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">make_ecp_env</code><span class="sig-paren">(</span><em>mol</em>, <em>_atm</em>, <em>ecp</em>, <em>pre_env=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#make_ecp_env"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.make_ecp_env" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the input arguments _ecpbas for ECP integrals</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.make_env">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">make_env</code><span class="sig-paren">(</span><em>atoms</em>, <em>basis</em>, <em>pre_env=[]</em>, <em>nucmod={}</em>, <em>nucprop={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#make_env"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.make_env" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the input arguments for <code class="docutils literal"><span class="pre">libcint</span></code> library based on internal
format <code class="xref py py-attr docutils literal"><span class="pre">Mole._atom</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">Mole._basis</span></code></p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.nao_2c">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">nao_2c</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#nao_2c"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.nao_2c" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of contracted spinor GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.nao_2c_range">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">nao_2c_range</code><span class="sig-paren">(</span><em>mol</em>, <em>bas_id0</em>, <em>bas_id1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#nao_2c_range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.nao_2c_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower and upper boundary of contracted spinor basis functions associated
with the given shell range</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mol :</dt>
<dd><a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</dd>
<dt>bas_id0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>start shell id, 0-based</dd>
<dt>bas_id1</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>stop shell id, 0-based</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>tupel of start basis function id and the stop function id</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_2c_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(4, 12)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.nao_cart">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">nao_cart</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#nao_cart"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.nao_cart" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of contracted cartesian GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.nao_nr">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">nao_nr</code><span class="sig-paren">(</span><em>mol</em>, <em>cart=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#nao_nr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.nao_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of contracted GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.nao_nr_range">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">nao_nr_range</code><span class="sig-paren">(</span><em>mol</em>, <em>bas_id0</em>, <em>bas_id1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#nao_nr_range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.nao_nr_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower and upper boundary of contracted spherical basis functions associated
with the given shell range</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mol :</dt>
<dd><a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</dd>
<dt>bas_id0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>start shell id</dd>
<dt>bas_id1</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>stop shell id</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>tupel of start basis function id and the stop function id</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_nr_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(2, 6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.npgto_nr">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">npgto_nr</code><span class="sig-paren">(</span><em>mol</em>, <em>cart=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#npgto_nr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.npgto_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of primitive spherical GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.offset_2c_by_atom">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">offset_2c_by_atom</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#offset_2c_by_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.offset_2c_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.offset_nr_by_atom">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">offset_nr_by_atom</code><span class="sig-paren">(</span><em>mol</em>, <em>ao_loc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.offset_nr_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.pack">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">pack</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#pack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.pack" title="Permalink to this definition">¶</a></dt>
<dd><p>Pack the input args of <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> to a dict.</p>
<p>Note this function only pack the input arguments (not the entire Mole
class).  Modifications to mol._atm, mol._bas, mol._env are not tracked.
Use <a class="reference internal" href="#pyscf.gto.mole.dumps" title="pyscf.gto.mole.dumps"><code class="xref py py-func docutils literal"><span class="pre">dumps()</span></code></a> to serialize the entire Mole object.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.same_basis_set">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">same_basis_set</code><span class="sig-paren">(</span><em>mol1</em>, <em>mol2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#same_basis_set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.same_basis_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether two molecules use the same basis sets.
The two molecules can have different geometry.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.same_mol">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">same_mol</code><span class="sig-paren">(</span><em>mol1</em>, <em>mol2</em>, <em>tol=1e-05</em>, <em>cmp_basis=True</em>, <em>ignore_chiral=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#same_mol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.same_mol" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare the two molecules whether they have the same structure.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>tol</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float</span><dd>In Bohr</dd>
<dt>cmp_basis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>Whether to compare basis functions for the two molecules</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.search_ao_label">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">search_ao_label</code><span class="sig-paren">(</span><em>mol</em>, <em>label</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#search_ao_label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.search_ao_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index of the AO basis function based on the given ao_label</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ao_label</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">string or a list of strings</span><dd>The regular expression pattern to match the orbital labels
returned by mol.ao_labels()</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list of index for the AOs that matches the given ao_label RE pattern</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl.*p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21 22 23 24 25 26 27 28 29 30]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl 2p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">([</span><span class="s1">&#39;Cl.*d&#39;</span><span class="p">,</span> <span class="s1">&#39;Cl 4p&#39;</span><span class="p">])</span>
<span class="go">[25 26 27 31 32 33 34 35 36 37 38 39 40]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.search_ao_nr">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">search_ao_nr</code><span class="sig-paren">(</span><em>mol</em>, <em>atm_id</em>, <em>l</em>, <em>m</em>, <em>atmshell</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#search_ao_nr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.search_ao_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the first basis function id (<strong>not</strong> the shell id) which matches
the given atom-id, angular momentum magnetic angular momentum, principal shell.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>atom id, 0-based</dd>
<dt>l</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>angular momentum</dd>
<dt>m</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>magnetic angular momentum</dd>
<dt>atmshell</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>principal quantum number</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>basis function id, 0-based.  If not found, return None</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_nr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Cl 3px</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.search_shell_id">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">search_shell_id</code><span class="sig-paren">(</span><em>mol</em>, <em>atm_id</em>, <em>l</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#search_shell_id"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.search_shell_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Search the first basis/shell id (<strong>not</strong> the basis function id) which
matches the given atom-id and angular momentum</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>atom id, 0-based</dd>
<dt>l</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>angular momentum</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>basis id, 0-based.  If not found, return None</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_shell_id</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># Cl p shell</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_shell_id</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># Cl d shell</span>
<span class="go">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.sph2spinor_kappa">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">sph2spinor_kappa</code><span class="sig-paren">(</span><em>kappa</em>, <em>l=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#sph2spinor_kappa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.sph2spinor_kappa" title="Permalink to this definition">¶</a></dt>
<dd><p>Real spherical to spinor transformation matrix for kappa</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.sph2spinor_l">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">sph2spinor_l</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#sph2spinor_l"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.sph2spinor_l" title="Permalink to this definition">¶</a></dt>
<dd><p>Real spherical to spinor transformation matrix for angular moment l</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.sph_labels">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">sph_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#sph_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.sph_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.spheric_labels">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">spheric_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.spheric_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.spherical_labels">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">spherical_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.spherical_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.spinor_labels">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">spinor_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#spinor_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.spinor_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Labels of spinor GTO functions</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.time_reversal_map">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">time_reversal_map</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#time_reversal_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.time_reversal_map" title="Permalink to this definition">¶</a></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have postive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.to_uncontracted_cartesian_basis">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">to_uncontracted_cartesian_basis</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#to_uncontracted_cartesian_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.to_uncontracted_cartesian_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Decontract the basis of a Mole or a Cell.  Returns a Mole (Cell) object
with the uncontracted basis environment and a list of coefficients that
transform the uncontracted cartesian basis to the original basis.  Each
element in the list corresponds to one shell of the original Mole (Cell).</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Ne&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pmol</span><span class="p">,</span> <span class="n">ctr_coeff</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">to_uncontracted_cartesian_basis</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">ctr_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pmol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.tofile">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">tofile</code><span class="sig-paren">(</span><em>mol</em>, <em>filename</em>, <em>format=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#tofile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.tofile" title="Permalink to this definition">¶</a></dt>
<dd><p>Write molecular geometry to a file of the required format.</p>
<dl class="docutils">
<dt>Supported output formats:</dt>
<dd><div class="first last line-block">
<div class="line">raw: Each line is  &lt;symobl&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;</div>
<div class="line">xyz: XYZ cartesian coordinates format</div>
<div class="line">zmat: Z-matrix format</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.tostring">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">tostring</code><span class="sig-paren">(</span><em>mol</em>, <em>format='raw'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#tostring"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.tostring" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert molecular geometry to a string of the required format.</p>
<dl class="docutils">
<dt>Supported output formats:</dt>
<dd><div class="first last line-block">
<div class="line">raw: Each line is  &lt;symobl&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;</div>
<div class="line">xyz: XYZ cartesian coordinates format</div>
<div class="line">zmat: Z-matrix format</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.tot_electrons">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">tot_electrons</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#tot_electrons"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.tot_electrons" title="Permalink to this definition">¶</a></dt>
<dd><p>Total number of electrons for the given molecule</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>electron number in integer</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 1 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">tot_electrons</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.uncontract">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">uncontract</code><span class="sig-paren">(</span><em>_basis</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.uncontract" title="Permalink to this definition">¶</a></dt>
<dd><p>Uncontract internal format _basis</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">uncontract</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;sto3g&#39;</span><span class="p">,</span> <span class="s1">&#39;He&#39;</span><span class="p">))</span>
<span class="go">[[0, [6.36242139, 1]], [0, [1.158923, 1]], [0, [0.31364979, 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.uncontracted_basis">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">uncontracted_basis</code><span class="sig-paren">(</span><em>_basis</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#uncontracted_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.uncontracted_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Uncontract internal format _basis</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">uncontract</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;sto3g&#39;</span><span class="p">,</span> <span class="s1">&#39;He&#39;</span><span class="p">))</span>
<span class="go">[[0, [6.36242139, 1]], [0, [1.158923, 1]], [0, [0.31364979, 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.unpack">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">unpack</code><span class="sig-paren">(</span><em>moldic</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#unpack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.mole.unpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack a dict which is packed by <a class="reference internal" href="#pyscf.gto.mole.pack" title="pyscf.gto.mole.pack"><code class="xref py py-func docutils literal"><span class="pre">pack()</span></code></a>, to generate the input
arguments for <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object.</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.zmat">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">zmat</code><span class="sig-paren">(</span><em>atomstr</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.zmat" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;H</span>
<span class="go">H 1 2.67247631453057</span>
<span class="go">H 1 4.22555607338457 2 50.7684795164077</span>
<span class="go">H 1 2.90305235726773 2 79.3904651036893 3 6.20854462618583&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">zmat2cart</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[&#39;H&#39;, array([ 0.,  0.,  0.])]</span>
<span class="go">[&#39;H&#39;, array([ 2.67247631,  0.        ,  0.        ])]</span>
<span class="go">[&#39;H&#39;, array([ 2.67247631,  0.        ,  3.27310166])]</span>
<span class="go">[&#39;H&#39;, array([ 0.53449526,  0.30859098,  2.83668811])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.mole.zmat2cart">
<code class="descclassname">pyscf.gto.mole.</code><code class="descname">zmat2cart</code><span class="sig-paren">(</span><em>atomstr</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.gto.mole.zmat2cart" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;H</span>
<span class="go">H 1 2.67247631453057</span>
<span class="go">H 1 4.22555607338457 2 50.7684795164077</span>
<span class="go">H 1 2.90305235726773 2 79.3904651036893 3 6.20854462618583&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">zmat2cart</span><span class="p">(</span><span class="n">a</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[&#39;H&#39;, array([ 0.,  0.,  0.])]</span>
<span class="go">[&#39;H&#39;, array([ 2.67247631,  0.        ,  0.        ])]</span>
<span class="go">[&#39;H&#39;, array([ 2.67247631,  0.        ,  3.27310166])]</span>
<span class="go">[&#39;H&#39;, array([ 0.53449526,  0.30859098,  2.83668811])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">pyscf.gto.mole.</code><code class="descname">Mole</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Basic class to hold molecular structure and global options</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first docutils">
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level</dd>
<dt>output</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span><dd>Output file, default is None which dumps msg to sys.stdout</dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int, float</span><dd>Allowed memory in MB</dd>
<dt>charge</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Charge of molecule. It affects the electron numbers</dd>
<dt>spin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span><dd>2S, num. alpha electrons - num. beta electrons to control
multiplicity. If spin = None is set, multiplicity will be guessed
based on the neutral molecule.</dd>
<dt>symmetry</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool or str</span><dd>Whether to use symmetry.  When this variable is set to True, the
molecule will be rotated and the highest rotation axis will be
placed z-axis.
If a string is given as the name of point group, the given point
group symmetry will be used.  Note that the input molecular
coordinates will not be changed in this case.</dd>
<dt>symmetry_subgroup</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>subgroup</dd>
<dt>atom</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list or str</span><dd><p class="first">To define molecluar structure.  The internal format is</p>
<div class="last line-block">
<div class="line">atom = [[atom1, (x, y, z)],</div>
<div class="line-block">
<div class="line">[atom2, (x, y, z)],</div>
<div class="line">...</div>
<div class="line">[atomN, (x, y, z)]]</div>
</div>
</div>
</dd>
<dt>unit</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Angstrom or Bohr</dd>
<dt>basis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>To define basis set.</dd>
<dt>nucmod</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str or [function(nuc_charge, nucprop) =&gt; zeta]</span><dd>Nuclear model.  0 or None means point nuclear model.  Other
values will enable Gaussian nuclear model.  If a function is
assigned to this attribute, the function will be called to
generate the nuclear charge distribution value &#8220;zeta&#8221; and the
relevant nuclear model will be set to Gaussian model.
Default is point nuclear model.</dd>
<dt>nucprop</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>Nuclear properties (like g-factor &#8216;g&#8217;, quadrupole moments &#8216;Q&#8217;).
It is needed by pyscf.prop module and submodules.</dd>
<dt>cart</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Using Cartesian GTO basis and integrals (6d,10f,15g)</dd>
</dl>
<p>** Following attributes are generated by <a class="reference internal" href="#pyscf.gto.mole.Mole.build" title="pyscf.gto.mole.Mole.build"><code class="xref py py-func docutils literal"><span class="pre">Mole.build()</span></code></a> **</p>
<dl class="docutils">
<dt>stdout</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">file object</span><dd>Default is sys.stdout if <code class="xref py py-attr docutils literal"><span class="pre">Mole.output</span></code> is not set</dd>
<dt>topgroup</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Point group of the system.</dd>
<dt>groupname</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>The supported subgroup of the point group. It can be one of Dooh,
Coov, D2h, C2h, C2v, D2, Cs, Ci, C2, C1</dd>
<dt>nelectron</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>sum of nuclear charges - <code class="xref py py-attr docutils literal"><span class="pre">Mole.charge</span></code></dd>
<dt>symm_orb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of numpy.ndarray</span><dd>Symmetry adapted basis.  Each element is a set of symm-adapted orbitals
for one irreducible representation.  The list index does <strong>not</strong> correspond
to the id of irreducible representation.</dd>
<dt>irrep_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of int</span><dd>Each element is one irreducible representation id associated with the basis
stored in symm_orb.  One irrep id stands for one irreducible representation
symbol.  The irrep symbol and the relevant id are defined in
<code class="xref py py-attr docutils literal"><span class="pre">symm.param.IRREP_ID_TABLE</span></code></dd>
<dt>irrep_name</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a list of str</span><dd>Each element is one irreducible representation symbol associated with the basis
stored in symm_orb.  The irrep symbols are defined in
<code class="xref py py-attr docutils literal"><span class="pre">symm.param.IRREP_ID_TABLE</span></code></dd>
<dt>_built</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>To label whether <a class="reference internal" href="#pyscf.gto.mole.Mole.build" title="pyscf.gto.mole.Mole.build"><code class="xref py py-func docutils literal"><span class="pre">Mole.build()</span></code></a> has been called.  It is to
ensure certain functions being initialized only once.</dd>
<dt>_basis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>like <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code>, the internal format which is returned from the
parser <a class="reference internal" href="#pyscf.gto.mole.format_basis" title="pyscf.gto.mole.format_basis"><code class="xref py py-func docutils literal"><span class="pre">format_basis()</span></code></a></dd>
<dt>_keys</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">a set of str</span><dd>Store the keys appeared in the module.  It is used to check misinput attributes</dd>
</dl>
<p>** Following attributes are arguments used by <code class="docutils literal"><span class="pre">libcint</span></code> library **</p>
<dl class="last docutils">
<dt>_atm :</dt>
<dd><code class="code docutils literal"><span class="pre">[[charge,</span> <span class="pre">ptr-of-coord,</span> <span class="pre">nuc-model,</span> <span class="pre">ptr-zeta,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[...]]</span></code>
each element reperesents one atom</dd>
<dt>natm :</dt>
<dd>number of atoms</dd>
<dt>_bas :</dt>
<dd><code class="code docutils literal"><span class="pre">[[atom-id,</span> <span class="pre">angular-momentum,</span> <span class="pre">num-primitive-GTO,</span> <span class="pre">num-contracted-GTO,</span> <span class="pre">0,</span> <span class="pre">ptr-of-exps,</span> <span class="pre">ptr-of-contract-coeff,</span> <span class="pre">0],</span> <span class="pre">[...]]</span></code>
each element reperesents one shell</dd>
<dt>nbas :</dt>
<dd>number of shells</dd>
<dt>_env :</dt>
<dd>list of floats to store the coordinates, GTO exponents, contract-coefficients</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">Mole</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto3g&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">H^2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_pure_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">H</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span>
<span class="go">[[ 0.99999999  0.43958641]</span>
<span class="go"> [ 0.43958641  0.99999999]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="go">&lt;class &#39;pyscf.gto.mole.Mole&#39;&gt; has no attributes Charge</span>
</pre></div>
</div>
<dl class="method">
<dt>
<code class="descname">ao2mo</code><span class="sig-paren">(</span><em>mo_coeffs</em>, <em>erifile=None</em>, <em>dataname='eri_mo'</em>, <em>intor='int2e'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.ao2mo"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Integral transformation for arbitrary orbitals and arbitrary
integrals.  See more detalied documentation in func:<cite>ao2mo.kernel</cite>.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mo_coeffs (an np array or a list of arrays)</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">A matrix of orbital</span><dd>coefficients if it is a numpy ndarray, or four sets of orbital
coefficients, corresponding to the four indices of (ij|kl).</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>erifile (str or h5py File or h5py Group object)</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">The file/object</span><dd>to store the transformed integrals.  If not given, the return
value is an array (in memory) of the transformed integrals.</dd>
<dt>dataname</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd><em>Note</em> this argument is effective if erifile is given.
The dataset name in the erifile (ref the hierarchy of HDF5 format
<a class="reference external" href="http://www.hdfgroup.org/HDF5/doc1.6/UG/09_Groups.html">http://www.hdfgroup.org/HDF5/doc1.6/UG/09_Groups.html</a>).  By assigning
different dataname, the existed integral file can be reused.  If
the erifile contains the specified dataname, the old integrals
will be replaced by the new one under the key dataname.</dd>
<dt>intor (str)</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">integral name Name of the 2-electron integral.  Ref</span><dd>to <code class="xref py py-func docutils literal"><span class="pre">getints_by_shell()</span></code>
for the complete list of available 2-electron integral names</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of transformed integrals if erifile is not given.
Otherwise, return the file/fileobject if erifile is assigned.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">pyscf</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 1 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span> <span class="mi">8</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eri1</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">(</span><span class="n">mo1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eri1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(55, 55)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eri1</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">(</span><span class="n">mo1</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eri1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eri1</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">(</span><span class="n">eri</span><span class="p">,</span> <span class="p">(</span><span class="n">mo1</span><span class="p">,</span><span class="n">mo2</span><span class="p">,</span><span class="n">mo2</span><span class="p">,</span><span class="n">mo2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eri1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(80, 36)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eri1</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">(</span><span class="n">eri</span><span class="p">,</span> <span class="p">(</span><span class="n">mo1</span><span class="p">,</span><span class="n">mo2</span><span class="p">,</span><span class="n">mo2</span><span class="p">,</span><span class="n">mo2</span><span class="p">),</span> <span class="n">erifile</span><span class="o">=</span><span class="s1">&#39;water.h5&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">ao_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span></dt>
<dd><p>Labels of AO basis functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>fmt</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or bool</span><dd>if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-AO-notation)]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">ao_loc</code></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>list, each entry is the corresponding start basis function id</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">ao_loc_2c</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span></dt>
<dd><p>Offset of every shell in the spinor basis function spectrum</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>list, each entry is the corresponding start id of spinor function</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_2c</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 2, 4, 6, 12, 18, 20, 22, 24, 30, 36]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">ao_loc_nr</code><span class="sig-paren">(</span><em>mol</em>, <em>cart=None</em><span class="sig-paren">)</span></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>list, each entry is the corresponding start basis function id</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">aoslice_2c_by_atom</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">aoslice_by_atom</code><span class="sig-paren">(</span><em>mol</em>, <em>ao_loc=None</em><span class="sig-paren">)</span></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">aoslice_nr_by_atom</code><span class="sig-paren">(</span><em>mol</em>, <em>ao_loc=None</em><span class="sig-paren">)</span></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">atom_charge</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_charge"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Nuclear effective charge of the given atom id
Note &#8220;atom_charge /= charge(atom_symbol)&#8221; when ECP is enabled.
Number of electrons screened by ECP can be obtained by charge(atom_symbol)-atom_charge</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">17</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">atom_charges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_charges"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>np.asarray([mol.atom_charge(i) for i in range(mol.natm)])</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">atom_coord</code><span class="sig-paren">(</span><em>atm_id</em>, <em>unit='Bohr'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_coord"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Coordinates (ndarray) of the given atom id</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_coord</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 0.          0.          2.07869874]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">atom_coords</code><span class="sig-paren">(</span><em>unit='Bohr'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_coords"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>np.asarray([mol.atom_coords(i) for i in range(mol.natm)])</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">atom_mass_list</code><span class="sig-paren">(</span><em>mol</em>, <em>isotope_avg=False</em><span class="sig-paren">)</span></dt>
<dd><p>A list of mass for all atoms in the molecule</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>isotope_avg</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span><dd>Whether to use the isotope average mass as the atomic mass</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">atom_nelec_core</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_nelec_core"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Number of core electrons for pseudo potential.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">atom_nshells</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_nshells"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Number of basis/shells of the given atom</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_nshells</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">atom_pure_symbol</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_pure_symbol"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>For the given atom id, return the standard symbol (striping special characters)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">H</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">atom_shell_ids</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_shell_ids"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>A list of the shell-ids of the given atom</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_shell_ids</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[3, 4, 5, 6, 7]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">atom_symbol</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.atom_symbol"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>For the given atom id, return the input symbol (without striping special characters)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">H^2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">bas_angular</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_angular"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>The angular momentum associated with the given basis</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_atom</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">bas_atom</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_atom"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>The atom (0-based id) that the given basis sits on</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_atom</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">bas_coord</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_coord"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Coordinates (ndarray) associated with the given basis id</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_coord</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 0.          0.          2.07869874]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">bas_ctr_coeff</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_ctr_coeff"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Contract coefficients (ndarray) of the given shell</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_ctr_coeff</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[[ 10.03400444]</span>
<span class="go"> [  4.1188704 ]</span>
<span class="go"> [  1.53971186]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">bas_exp</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_exp"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>exponents (ndarray) of the given shell</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_kappa</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[ 13.01     1.962    0.4446]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">bas_kappa</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_kappa"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Kappa (if l &lt; j, -l-1, else l) of the given shell</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_kappa</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">bas_len_cart</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_len_cart"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>The number of Cartesian function associated with given basis</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">bas_len_spinor</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_len_spinor"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>The number of spinor associated with given basis
If kappa is 0, return 4l+2</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">bas_nctr</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_nctr"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>The number of contracted GTOs for the given shell</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_atom</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">bas_nprim</code><span class="sig-paren">(</span><em>bas_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.bas_nprim"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>The number of primitive GTOs for the given shell</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>bas_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>0-based</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_atom</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">build</code><span class="sig-paren">(</span><em>dump_input=True</em>, <em>parse_arg=True</em>, <em>verbose=None</em>, <em>output=None</em>, <em>max_memory=None</em>, <em>atom=None</em>, <em>basis=None</em>, <em>unit=None</em>, <em>nucmod=None</em>, <em>ecp=None</em>, <em>charge=None</em>, <em>spin=0</em>, <em>symmetry=None</em>, <em>symmetry_subgroup=None</em>, <em>cart=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.build"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Setup moleclue and initialize some control parameters.  Whenever you
change the value of the attributes of <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a>, you need call
this function to refresh the internal data of Mole.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dump_input</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>whether to dump the contents of input file in the output file</dd>
<dt>parse_arg</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>whether to read the sys.argv and overwrite the relevant parameters</dd>
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>output</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span><dd>Output file.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.output</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int, float</span><dd>Allowd memory in MB.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>atom</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list or str</span><dd>To define molecluar structure.</dd>
<dt>basis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>To define basis set.</dd>
<dt>nucmod</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>Nuclear model.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.nucmod</span></code></dd>
<dt>charge</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Charge of molecule. It affects the electron numbers
If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.charge</span></code></dd>
<dt>spin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>2S, num. alpha electrons - num. beta electrons to control
multiplicity. If setting spin = None , multiplicity will be
guessed based on the neutral molecule.
If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.spin</span></code></dd>
<dt>symmetry</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool or str</span><dd>Whether to use symmetry.  If given a string of point group
name, the given point group symmetry will be used.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">cart2sph_coeff</code><span class="sig-paren">(</span><em>normalized='sp'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.cart2sph_coeff"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Transformation matrix that transforms Cartesian GTOs to spherical
GTOs for all basis functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>normalized</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">string or boolean</span><dd>How the Cartesian GTOs are normalized.  Except s and p functions,
Cartesian GTOs do not have the universal normalization coefficients
for the different components of the same shell.  The value of this
argument can be one of &#8216;sp&#8217;, &#8216;all&#8217;, None.  &#8216;sp&#8217; means the Cartesian s
and p basis are normalized.  &#8216;all&#8217; means all Cartesian functions are
normalized.  None means none of the Cartesian functions are normalized.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">cart2sph_coeff</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_cart&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">s0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">4.58676826646e-15</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">cart_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span></dt>
<dd><p>Labels of Cartesian GTO functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-xyz-notation)]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">condense_to_shell</code><span class="sig-paren">(</span><em>mol</em>, <em>mat</em>, <em>compressor=&lt;function amax&gt;</em><span class="sig-paren">)</span></dt>
<dd><p>The given matrix is first partitioned to blocks, based on AO shell as
delimiter.  Then call compressor function to abstract each block.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copy</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span></dt>
<dd><p>Deepcopy of the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">dumps</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span></dt>
<dd><p>Serialize Mole object to a JSON formatted str.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">elements</code></dt>
<dd><p>A list of elements in the molecule</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">energy_nuc</code><span class="sig-paren">(</span><em>mol</em>, <em>charges=None</em>, <em>coords=None</em><span class="sig-paren">)</span></dt>
<dd><p>Compute nuclear repulsion energy (AU) or static Coulomb energy</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>float</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">etbs</code><span class="sig-paren">(</span><em>etbs</em><span class="sig-paren">)</span></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#pyscf.gto.mole.expand_etb" title="pyscf.gto.mole.expand_etb"><code class="xref py py-func docutils literal"><span class="pre">expand_etb()</span></code></a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd>etbs = [(l, n, alpha, beta), (l, n, alpha, beta),...]</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">eval_ao</code><span class="sig-paren">(</span><em>mol</em>, <em>eval_name</em>, <em>coords</em>, <em>comp=None</em>, <em>shls_slice=None</em>, <em>non0tab=None</em>, <em>ao_loc=None</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Evaluate AO function value on the given grids,</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">eval_name : str</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="13%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">comp</th>
<th class="head">Expression</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8220;GTOval_sph&#8221;</td>
<td>1</td>
<td><a href="#id30"><span class="problematic" id="id31">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_sph&#8221;</td>
<td>3</td>
<td>nabla <a href="#id32"><span class="problematic" id="id33">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_ig_sph&#8221;</td>
<td>3</td>
<td>(#C(0 1) g) <a href="#id34"><span class="problematic" id="id35">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ipig_sph&#8221;</td>
<td>3</td>
<td>(#C(0 1) nabla g) <a href="#id36"><span class="problematic" id="id37">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_cart&#8221;</td>
<td>1</td>
<td><a href="#id38"><span class="problematic" id="id39">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_cart&#8221;</td>
<td>3</td>
<td>nabla <a href="#id40"><span class="problematic" id="id41">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_ig_cart&#8221;</td>
<td>3</td>
<td>(#C(0 1) g)|AO&gt;</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="last docutils">
<dt>atm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>bas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>env</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float64 ndarray</span><dd>libcint integral function argument</dd>
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>The coordinates of the grids.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of the components of the operator</dd>
<dt>shls_slice</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2-element list</span><dd>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in mol will be evaluated.</dd>
<dt>non0tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D bool array</span><dd>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">dft.gen_grid.make_mask()</span></code></dd>
<dt>out</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If provided, results are written into this array.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>2D array of shape (N,nao) Or 3D array of shape (*,N,nao) to store AO
values on grids.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># 100 random points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(100, 24)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 100, 24)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">eval_gto</code><span class="sig-paren">(</span><em>mol</em>, <em>eval_name</em>, <em>coords</em>, <em>comp=None</em>, <em>shls_slice=None</em>, <em>non0tab=None</em>, <em>ao_loc=None</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>Evaluate AO function value on the given grids,</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">eval_name : str</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="13%" />
<col width="49%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">comp</th>
<th class="head">Expression</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8220;GTOval_sph&#8221;</td>
<td>1</td>
<td><a href="#id42"><span class="problematic" id="id43">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_sph&#8221;</td>
<td>3</td>
<td>nabla <a href="#id44"><span class="problematic" id="id45">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_ig_sph&#8221;</td>
<td>3</td>
<td>(#C(0 1) g) <a href="#id46"><span class="problematic" id="id47">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ipig_sph&#8221;</td>
<td>3</td>
<td>(#C(0 1) nabla g) <a href="#id48"><span class="problematic" id="id49">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_cart&#8221;</td>
<td>1</td>
<td><a href="#id50"><span class="problematic" id="id51">|</span></a>AO&gt;</td>
</tr>
<tr class="row-odd"><td>&#8220;GTOval_ip_cart&#8221;</td>
<td>3</td>
<td>nabla <a href="#id52"><span class="problematic" id="id53">|</span></a>AO&gt;</td>
</tr>
<tr class="row-even"><td>&#8220;GTOval_ig_cart&#8221;</td>
<td>3</td>
<td>(#C(0 1) g)|AO&gt;</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="last docutils">
<dt>atm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>bas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>env</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float64 ndarray</span><dd>libcint integral function argument</dd>
<dt>coords</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D array, shape (N,3)</span><dd>The coordinates of the grids.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of the components of the operator</dd>
<dt>shls_slice</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2-element list</span><dd>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in mol will be evaluated.</dd>
<dt>non0tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">2D bool array</span><dd>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal"><span class="pre">dft.gen_grid.make_mask()</span></code></dd>
<dt>out</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>If provided, results are written into this array.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>2D array of shape (N,nao) Or 3D array of shape (*,N,nao) to store AO
values on grids.</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># 100 random points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(100, 24)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 100, 24)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">expand_etb</code><span class="sig-paren">(</span><em>l</em>, <em>n</em>, <em>alpha</em>, <em>beta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.expand_etb"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Generate the exponents of even tempered basis for <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code>.
.. math:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span>\<span class="n">alpha</span> <span class="o">*</span> \<span class="n">beta</span><span class="o">^</span><span class="p">{</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">}}</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">..</span> <span class="n">n</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>l</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Angular momentum</dd>
<dt>n</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Number of GTOs</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[[1, [6.0, 1]], [1, [3.0, 1]], [1, [1.5, 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">expand_etbs</code><span class="sig-paren">(</span><em>etbs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.expand_etbs"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#pyscf.gto.mole.expand_etb" title="pyscf.gto.mole.expand_etb"><code class="xref py py-func docutils literal"><span class="pre">expand_etb()</span></code></a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd>etbs = [(l, n, alpha, beta), (l, n, alpha, beta),...]</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">format_atom</code><span class="sig-paren">(</span><em>atom</em>, <em>origin=0</em>, <em>axes=None</em>, <em>unit='Ang'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.format_atom"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal"><span class="pre">Mole.atom</span></code> to the internal data format.
Including, changing the nuclear charge to atom symbol, converting the
coordinates to AU, rotate and shift the molecule.
If the <code class="xref py py-attr docutils literal"><span class="pre">atom</span></code> is a string, it takes &#8221;;&#8221; and &#8220;n&#8221;
for the mark to separate atoms;  &#8221;,&#8221; and arbitrary length of blank space
to spearate the individual terms for an atom.  Blank line will be ignored.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atoms</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list or str</span><dd>the same to <code class="xref py py-attr docutils literal"><span class="pre">Mole.atom</span></code></dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>origin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>new axis origin.</dd>
<dt>axes</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span><dd>(new_x, new_y, new_z), new coordinates</dd>
<dt>unit</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or number</span><dd>If unit is one of strings (B, b, Bohr, bohr, AU, au), the coordinates
of the input atoms are the atomic unit;  If unit is one of strings
(A, a, Angstrom, angstrom, Ang, ang), the coordinates are in the
unit of angstrom;  If a number is given, the number are considered
as the Bohr value (in angstrom), which should be around 0.53</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>&#8220;atoms&#8221; in the internal format. The internal format is</dt>
<dd><div class="first last line-block">
<div class="line">atom = [[atom1, (x, y, z)],</div>
<div class="line-block">
<div class="line">[atom2, (x, y, z)],</div>
<div class="line">...</div>
<div class="line">[atomN, (x, y, z)]]</div>
</div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">(</span><span class="s1">&#39;9,0,0,0; h@1 0 0 1&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H@1&#39;, [-1.0, -1.0, 0.0]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">([</span><span class="s1">&#39;9,0,0,0&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))],</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H&#39;, [-1, -1, 0]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">format_basis</code><span class="sig-paren">(</span><em>basis_tab</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.format_basis"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code> to the internal data format.</p>
<dl class="docutils">
<dt><a href="#id54"><span class="problematic" id="id55">``</span></a>{ atom: [(l, ((-exp, c_1, c_2, ..),</dt>
<dd><blockquote class="first">
<div>(-exp, c_1, c_2, ..))),</div></blockquote>
<dl class="last docutils">
<dt>(l, ((-exp, c_1, c_2, ..),</dt>
<dd>(-exp, c_1, c_2, ..)))], ... }``</dd>
</dl>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>basis_tab</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span><dd>Similar to <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code>, it <strong>cannot</strong> be a str</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>Formated <code class="xref py py-attr docutils literal"><span class="pre">basis</span></code></dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_basis</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span> <span class="s1">&#39;H^2&#39;</span><span class="p">:</span> <span class="s1">&#39;3-21g&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[0,</span>
<span class="go">    [3.4252509099999999, 0.15432897000000001],</span>
<span class="go">    [0.62391373000000006, 0.53532813999999995],</span>
<span class="go">    [0.16885539999999999, 0.44463454000000002]]],</span>
<span class="go"> &#39;H^2&#39;: [[0,</span>
<span class="go">    [5.4471780000000001, 0.15628500000000001],</span>
<span class="go">    [0.82454700000000003, 0.90469100000000002]],</span>
<span class="go">    [0, [0.18319199999999999, 1.0]]]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">format_ecp</code><span class="sig-paren">(</span><em>ecp_tab</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.format_ecp"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal"><span class="pre">ecp</span></code> (dict) to the internal data format:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span><span class="n">nelec</span><span class="p">,</span>  <span class="c1"># core electrons</span>
</pre></div>
</div>
<blockquote>
<div><blockquote>
<div><dl class="docutils">
<dt>((l,  # l=-1 for UL, l&gt;=0 for Ul to indicate <a href="#id60"><span class="problematic" id="id61">|l&gt;&lt;l|</span></a></dt>
<dd><dl class="first last docutils">
<dt>(((exp_1, c_1),  # for r^0</dt>
<dd><blockquote class="first">
<div>(exp_2, c_2),
...),</div></blockquote>
<dl class="last docutils">
<dt>((exp_1, c_1),  # for r^1</dt>
<dd>(exp_2, c_2),
...),</dd>
<dt>((exp_1, c_1),  # for r^2</dt>
<dd>...))))),</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>...}</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">fromfile</code><span class="sig-paren">(</span><em>filename</em>, <em>format=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.fromfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Update the Mole object based on the input geometry file</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">fromstring</code><span class="sig-paren">(</span><em>string</em>, <em>format='xyz'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.fromstring"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Update the Mole object based on the input geometry string</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">gto_norm</code><span class="sig-paren">(</span><em>l</em>, <em>expnt</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.gto_norm"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Normalized factor for GTO radial part   <span class="math">\(g=r^l e^{-\alpha r^2}\)</span></p>
<div class="math">
\[\frac{1}{\sqrt{\int g^2 r^2 dr}}
= \sqrt{\frac{2^{2l+3} (l+1)! (2a)^{l+1.5}}{(2l+2)!\sqrt{\pi}}}\]</div>
<p>Ref: H. B. Schlegel and M. J. Frisch, Int. J. Quant.  Chem., 54(1995), 83-87.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>l (int):</dt>
<dd>angular momentum</dd>
<dt>expnt :</dt>
<dd>exponent <span class="math">\(\alpha\)</span></dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>normalization factor</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gto_norm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">2.5264751109842591</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">has_ecp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.has_ecp"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Whether pseudo potential is used in the system.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">intor</code><span class="sig-paren">(</span><em>intor</em>, <em>comp=None</em>, <em>hermi=0</em>, <em>aosym='s1'</em>, <em>out=None</em>, <em>shls_slice=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.intor"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Integral generator.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>intor</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Name of the 1e or 2e AO integrals.  Ref to <code class="xref py py-func docutils literal"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd><p class="first">Symmetry of the integrals</p>
<div class="last line-block">
<div class="line">0 : no symmetry assumed (default)</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ipnuc_sph&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># &lt;nabla i | V_nuc | j&gt;</span>
<span class="go">[[[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.10289944  0.48176097]</span>
<span class="go">  [-0.48176097 -0.10289944]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j -0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j -0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">intor_asymmetric</code><span class="sig-paren">(</span><em>intor</em>, <em>comp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.intor_asymmetric"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>One-electron integral generator. The integrals are assumed to be anti-hermitian</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>intor</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Name of the 1-electron integral.  Ref to <code class="xref py py-func docutils literal"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Components of the integrals, e.g. int1e_ipovlp has 3 components.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor_asymmetric</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j  0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j  0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">intor_by_shell</code><span class="sig-paren">(</span><em>intor</em>, <em>shells</em>, <em>comp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.intor_by_shell"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>For given 2, 3 or 4 shells, interface for libcint to get 1e, 2e,
2-center-2e or 3-center-2e integrals</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>intor_name</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>See also <code class="xref py py-func docutils literal"><span class="pre">getints()</span></code> for the supported intor_name</dd>
<dt>shls</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span><dd>The AO shell-ids of the integrals</dd>
<dt>atm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>bas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>env</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float64 ndarray</span><dd>libcint integral function argument</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Components of the integrals, e.g. int1e_ipovlp has 3 components.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>ndarray of 2-dim to 5-dim, depending on the integral type (1e,
2e, 3c-2e, 2c2e) and the value of comp</dd>
<dt>Examples:</dt>
<dd>The gradients of the spherical 2e integrals</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">getints_by_shell</span><span class="p">(</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[[[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.08760462]]]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">intor_symmetric</code><span class="sig-paren">(</span><em>intor</em>, <em>comp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.intor_symmetric"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>One-electron integral generator. The integrals are assumed to be hermitian</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>intor</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Name of the 1-electron integral.  Ref to <code class="xref py py-func docutils literal"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor_symmetric</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j -0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j -0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">kernel</code><span class="sig-paren">(</span><em>dump_input=True</em>, <em>parse_arg=True</em>, <em>verbose=None</em>, <em>output=None</em>, <em>max_memory=None</em>, <em>atom=None</em>, <em>basis=None</em>, <em>unit=None</em>, <em>nucmod=None</em>, <em>ecp=None</em>, <em>charge=None</em>, <em>spin=0</em>, <em>symmetry=None</em>, <em>symmetry_subgroup=None</em>, <em>cart=None</em><span class="sig-paren">)</span></dt>
<dd><p>Setup moleclue and initialize some control parameters.  Whenever you
change the value of the attributes of <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a>, you need call
this function to refresh the internal data of Mole.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>dump_input</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>whether to dump the contents of input file in the output file</dd>
<dt>parse_arg</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool</span><dd>whether to read the sys.argv and overwrite the relevant parameters</dd>
<dt>verbose</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Print level.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.verbose</span></code></dd>
<dt>output</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span><dd>Output file.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.output</span></code></dd>
<dt>max_memory</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int, float</span><dd>Allowd memory in MB.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.max_memory</span></code></dd>
<dt>atom</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list or str</span><dd>To define molecluar structure.</dd>
<dt>basis</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>To define basis set.</dd>
<dt>nucmod</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict or str</span><dd>Nuclear model.  If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.nucmod</span></code></dd>
<dt>charge</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Charge of molecule. It affects the electron numbers
If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.charge</span></code></dd>
<dt>spin</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>2S, num. alpha electrons - num. beta electrons to control
multiplicity. If setting spin = None , multiplicity will be
guessed based on the neutral molecule.
If given, overwrite <code class="xref py py-attr docutils literal"><span class="pre">Mole.spin</span></code></dd>
<dt>symmetry</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">bool or str</span><dd>Whether to use symmetry.  If given a string of point group
name, the given point group symmetry will be used.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">loads</code><span class="sig-paren">(</span><em>molstr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.loads"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Deserialize a str containing a JSON document to a Mole object.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">make_atm_env</code><span class="sig-paren">(</span><em>atom</em>, <em>ptr=0</em>, <em>nucmod=1</em>, <em>nucprop=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.make_atm_env"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Convert the internal format <code class="xref py py-attr docutils literal"><span class="pre">Mole._atom</span></code> to the format required
by <code class="docutils literal"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">make_bas_env</code><span class="sig-paren">(</span><em>basis_add</em>, <em>atom_id=0</em>, <em>ptr=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.make_bas_env"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Convert <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code> to the argument <code class="docutils literal"><span class="pre">bas</span></code> for <code class="docutils literal"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">make_ecp_env</code><span class="sig-paren">(</span><em>_atm</em>, <em>_ecp</em>, <em>pre_env=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.make_ecp_env"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Generate the input arguments _ecpbas for ECP integrals</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">make_env</code><span class="sig-paren">(</span><em>atoms</em>, <em>basis</em>, <em>pre_env=[]</em>, <em>nucmod={}</em>, <em>nucprop=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.make_env"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Generate the input arguments for <code class="docutils literal"><span class="pre">libcint</span></code> library based on internal
format <code class="xref py py-attr docutils literal"><span class="pre">Mole._atom</span></code> and <code class="xref py py-attr docutils literal"><span class="pre">Mole._basis</span></code></p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">ms</code></dt>
<dd><p>Spin quantum number. multiplicity = ms*2+1</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">nao</code></dt>
<dd><p>Total number of contracted GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">nao_2c</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span></dt>
<dd><p>Total number of contracted spinor GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">nao_2c_range</code><span class="sig-paren">(</span><em>mol</em>, <em>bas_id0</em>, <em>bas_id1</em><span class="sig-paren">)</span></dt>
<dd><p>Lower and upper boundary of contracted spinor basis functions associated
with the given shell range</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mol :</dt>
<dd><a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</dd>
<dt>bas_id0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>start shell id, 0-based</dd>
<dt>bas_id1</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>stop shell id, 0-based</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>tupel of start basis function id and the stop function id</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_2c_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(4, 12)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">nao_cart</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span></dt>
<dd><p>Total number of contracted cartesian GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">nao_nr</code><span class="sig-paren">(</span><em>mol</em>, <em>cart=None</em><span class="sig-paren">)</span></dt>
<dd><p>Total number of contracted GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">nao_nr_range</code><span class="sig-paren">(</span><em>mol</em>, <em>bas_id0</em>, <em>bas_id1</em><span class="sig-paren">)</span></dt>
<dd><p>Lower and upper boundary of contracted spherical basis functions associated
with the given shell range</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>mol :</dt>
<dd><a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</dd>
<dt>bas_id0</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>start shell id</dd>
<dt>bas_id1</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>stop shell id</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>tupel of start basis function id and the stop function id</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_nr_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(2, 6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">npgto_nr</code><span class="sig-paren">(</span><em>mol</em>, <em>cart=None</em><span class="sig-paren">)</span></dt>
<dd><p>Total number of primitive spherical GTOs for the given <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">offset_2c_by_atom</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">offset_ao_by_atom</code><span class="sig-paren">(</span><em>mol</em>, <em>ao_loc=None</em><span class="sig-paren">)</span></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">offset_nr_by_atom</code><span class="sig-paren">(</span><em>mol</em>, <em>ao_loc=None</em><span class="sig-paren">)</span></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">pack</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span></dt>
<dd><p>Pack the input args of <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> to a dict.</p>
<p>Note this function only pack the input arguments (not the entire Mole
class).  Modifications to mol._atm, mol._bas, mol._env are not tracked.
Use <a class="reference internal" href="#pyscf.gto.mole.dumps" title="pyscf.gto.mole.dumps"><code class="xref py py-func docutils literal"><span class="pre">dumps()</span></code></a> to serialize the entire Mole object.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">search_ao_label</code><span class="sig-paren">(</span><em>mol</em>, <em>label</em><span class="sig-paren">)</span></dt>
<dd><p>Find the index of the AO basis function based on the given ao_label</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ao_label</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">string or a list of strings</span><dd>The regular expression pattern to match the orbital labels
returned by mol.ao_labels()</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A list of index for the AOs that matches the given ao_label RE pattern</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl.*p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21 22 23 24 25 26 27 28 29 30]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl 2p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">([</span><span class="s1">&#39;Cl.*d&#39;</span><span class="p">,</span> <span class="s1">&#39;Cl 4p&#39;</span><span class="p">])</span>
<span class="go">[25 26 27 31 32 33 34 35 36 37 38 39 40]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">search_ao_nr</code><span class="sig-paren">(</span><em>mol</em>, <em>atm_id</em>, <em>l</em>, <em>m</em>, <em>atmshell</em><span class="sig-paren">)</span></dt>
<dd><p>Search the first basis function id (<strong>not</strong> the shell id) which matches
the given atom-id, angular momentum magnetic angular momentum, principal shell.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>atm_id</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>atom id, 0-based</dd>
<dt>l</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>angular momentum</dd>
<dt>m</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>magnetic angular momentum</dd>
<dt>atmshell</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>principal quantum number</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>basis function id, 0-based.  If not found, return None</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_nr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Cl 3px</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_common_orig</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_common_orig_</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_common_origin</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_common_origin"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_common_origin_</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_f12_zeta</code><span class="sig-paren">(</span><em>zeta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_f12_zeta"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Set zeta for YP exp(-zeta r12)/r12 or STG exp(-zeta r12) type integrals</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_geom_</code><span class="sig-paren">(</span><em>atoms_or_coords</em>, <em>unit=None</em>, <em>symmetry=None</em>, <em>inplace=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_geom_"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Update geometry</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_nuc_mod</code><span class="sig-paren">(</span><em>atm_id</em>, <em>zeta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_nuc_mod"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Change the nuclear charge distribution of the given atom ID.  The charge
distribution is defined as: rho(r) = nuc_charge * Norm * exp(-zeta * r^2).
This function can <strong>only</strong> be called after .build() method is executed.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zeta</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">filatov_nuc_mod</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">set_nuc_mod</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_nuc_mod_</code><span class="sig-paren">(</span><em>atm_id</em>, <em>zeta</em><span class="sig-paren">)</span></dt>
<dd><p>Change the nuclear charge distribution of the given atom ID.  The charge
distribution is defined as: rho(r) = nuc_charge * Norm * exp(-zeta * r^2).
This function can <strong>only</strong> be called after .build() method is executed.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zeta</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">filatov_nuc_mod</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">set_nuc_mod</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_range_coulomb</code><span class="sig-paren">(</span><em>omega</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_range_coulomb"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Apply the long range part of range-separated Coulomb operator for
<strong>all</strong> 2e integrals
erf(omega r12) / r12
set omega to 0 to siwtch off the range-separated Coulomb</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_range_coulomb_</code><span class="sig-paren">(</span><em>omega</em><span class="sig-paren">)</span></dt>
<dd><p>Apply the long range part of range-separated Coulomb operator for
<strong>all</strong> 2e integrals
erf(omega r12) / r12
set omega to 0 to siwtch off the range-separated Coulomb</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_rinv_orig</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span></dt>
<dd><p>Update origin for operator <span class="math">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_rinv_orig_</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span></dt>
<dd><p>Update origin for operator <span class="math">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_rinv_origin</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_rinv_origin"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Update origin for operator <span class="math">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_rinv_origin_</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span></dt>
<dd><p>Update origin for operator <span class="math">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_rinv_zeta</code><span class="sig-paren">(</span><em>zeta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.set_rinv_zeta"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Assume the charge distribution on the &#8220;rinv_origin&#8221;.  zeta is the parameter
to control the charge distribution: rho(r) = Norm * exp(-zeta * r^2).
<strong>Be careful</strong> when call this function. It affects the behavior of
int1e_rinv_* functions.  Make sure to set it back to 0 after using it!</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_rinv_zeta_</code><span class="sig-paren">(</span><em>zeta</em><span class="sig-paren">)</span></dt>
<dd><p>Assume the charge distribution on the &#8220;rinv_origin&#8221;.  zeta is the parameter
to control the charge distribution: rho(r) = Norm * exp(-zeta * r^2).
<strong>Be careful</strong> when call this function. It affects the behavior of
int1e_rinv_* functions.  Make sure to set it back to 0 after using it!</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">sph2spinor_coeff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.sph2spinor_coeff"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Transformation matrix that transforms real-spherical GTOs to spinor
GTOs for all basis functions</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca</span><span class="p">,</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">sph2spinor_coeff</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_spinor&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ca</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">+=</span> <span class="n">cb</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">s0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">6.66133814775e-16</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">sph_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">spheric_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is &#8220;%d%3s %s%-4s&#8221;.  if fmt is string, the string will
be used as the print format.</dd>
<dt>Returns:</dt>
<dd>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument &#8220;fmt&#8221;</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">spinor_labels</code><span class="sig-paren">(</span><em>mol</em>, <em>fmt=True</em>, <em>base=0</em><span class="sig-paren">)</span></dt>
<dd><p>Labels of spinor GTO functions</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">time_reversal_map</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have postive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">tmap</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have postive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">to_uncontracted_cartesian_basis</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span></dt>
<dd><p>Decontract the basis of a Mole or a Cell.  Returns a Mole (Cell) object
with the uncontracted basis environment and a list of coefficients that
transform the uncontracted cartesian basis to the original basis.  Each
element in the list corresponds to one shell of the original Mole (Cell).</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Ne&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pmol</span><span class="p">,</span> <span class="n">ctr_coeff</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">to_uncontracted_cartesian_basis</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">ctr_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pmol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">tofile</code><span class="sig-paren">(</span><em>mol</em>, <em>filename</em>, <em>format=None</em><span class="sig-paren">)</span></dt>
<dd><p>Write molecular geometry to a file of the required format.</p>
<dl class="docutils">
<dt>Supported output formats:</dt>
<dd><div class="first last line-block">
<div class="line">raw: Each line is  &lt;symobl&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;</div>
<div class="line">xyz: XYZ cartesian coordinates format</div>
<div class="line">zmat: Z-matrix format</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">tostring</code><span class="sig-paren">(</span><em>mol</em>, <em>format='raw'</em><span class="sig-paren">)</span></dt>
<dd><p>Convert molecular geometry to a string of the required format.</p>
<dl class="docutils">
<dt>Supported output formats:</dt>
<dd><div class="first last line-block">
<div class="line">raw: Each line is  &lt;symobl&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;</div>
<div class="line">xyz: XYZ cartesian coordinates format</div>
<div class="line">zmat: Z-matrix format</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">tot_electrons</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span></dt>
<dd><p>Total number of electrons for the given molecule</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>electron number in integer</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 1 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">tot_electrons</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">unpack</code><span class="sig-paren">(</span><em>moldic</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.unpack"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Unpack a dict which is packed by <a class="reference internal" href="#pyscf.gto.mole.pack" title="pyscf.gto.mole.pack"><code class="xref py py-func docutils literal"><span class="pre">pack()</span></code></a>, to generate the input
arguments for <a class="reference internal" href="#pyscf.gto.mole.Mole" title="pyscf.gto.mole.Mole"><code class="xref py py-class docutils literal"><span class="pre">Mole</span></code></a> object.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">with_common_orig</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span></dt>
<dd><p>Retuen a temporary mol context which has the rquired common origin.
The required common origin has no effects out of the temporary context.
See also <code class="xref py py-func docutils literal"><span class="pre">mol.set_common_origin()</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_r&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">with_common_origin</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.with_common_origin"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Retuen a temporary mol context which has the rquired common origin.
The required common origin has no effects out of the temporary context.
See also <code class="xref py py-func docutils literal"><span class="pre">mol.set_common_origin()</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_r&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">with_range_coulomb</code><span class="sig-paren">(</span><em>omega</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.with_range_coulomb"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Retuen a temporary mol context which has the required parameter
omega for long range part of range-separated Coulomb operator.
If omega = None, it will be treated as the regular Coulomb operator.
See also <code class="xref py py-func docutils literal"><span class="pre">mol.set_range_coulomb()</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_range_coulomb</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int2e&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">with_rinv_as_nucleus</code><span class="sig-paren">(</span><em>atm_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.with_rinv_as_nucleus"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Retuen a temporary mol context in which the rinv operator (1/r) is
treated like the Coulomb potential of a Gaussian charge distribution
rho(r) = Norm * exp(-zeta * r^2) at the place of the input atm_id.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_as_nucleus</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">with_rinv_orig</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span></dt>
<dd><p>Retuen a temporary mol context which has the rquired origin of 1/r
operator.  The required origin has no effects out of the temporary
context.  See also <code class="xref py py-func docutils literal"><span class="pre">mol.set_rinv_origin()</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">with_rinv_origin</code><span class="sig-paren">(</span><em>coord</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.with_rinv_origin"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Retuen a temporary mol context which has the rquired origin of 1/r
operator.  The required origin has no effects out of the temporary
context.  See also <code class="xref py py-func docutils literal"><span class="pre">mol.set_rinv_origin()</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">with_rinv_zeta</code><span class="sig-paren">(</span><em>zeta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/mole.html#Mole.with_rinv_zeta"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Retuen a temporary mol context which has the rquired Gaussian charge
distribution placed at &#8220;rinv_origin&#8221;: rho(r) = Norm * exp(-zeta * r^2).
See also <code class="xref py py-func docutils literal"><span class="pre">mol.set_rinv_zeta()</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_zeta</span><span class="p">(</span><span class="n">zeta</span><span class="o">=</span><span class="mf">1.5</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyscf.gto.moleintor">
<span id="moleintor"></span><span id="gto-moleintor"></span><h3>4.2.2. moleintor<a class="headerlink" href="#module-pyscf.gto.moleintor" title="Permalink to this headline">¶</a></h3>
<p>A low level interface to libcint library. It&#8217;s recommended to use the
Mole.intor method to drive the integral evaluation funcitons.</p>
<dl class="function">
<dt id="pyscf.gto.moleintor.ascint3">
<code class="descclassname">pyscf.gto.moleintor.</code><code class="descname">ascint3</code><span class="sig-paren">(</span><em>intor_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/moleintor.html#ascint3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.moleintor.ascint3" title="Permalink to this definition">¶</a></dt>
<dd><p>convert cint2 function name to cint3 function name</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.moleintor.getints">
<code class="descclassname">pyscf.gto.moleintor.</code><code class="descname">getints</code><span class="sig-paren">(</span><em>intor_name</em>, <em>atm</em>, <em>bas</em>, <em>env</em>, <em>shls_slice=None</em>, <em>comp=None</em>, <em>hermi=0</em>, <em>aosym='s1'</em>, <em>ao_loc=None</em>, <em>cintopt=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/moleintor.html#getints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.moleintor.getints" title="Permalink to this definition">¶</a></dt>
<dd><p>1e and 2e integral generator.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">intor_name : str</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function</th>
<th class="head">Expression</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8220;int1e_ovlp&#8221;</td>
<td>( | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_nuc&#8221;</td>
<td>( | nuc | )</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_kin&#8221;</td>
<td>(.5 | p dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_ia01p&#8221;</td>
<td>(#C(0 1) | nabla-rinv | cross p)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_giao_irjxp&#8221;</td>
<td>(#C(0 1) | r cross p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_cg_irxp&#8221;</td>
<td>(#C(0 1) | rc cross p)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_giao_a11part&#8221;</td>
<td>(-.5 | nabla-rinv | r)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_cg_a11part&#8221;</td>
<td>(-.5 | nabla-rinv | rc)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_a01gp&#8221;</td>
<td>(g | nabla-rinv cross p |)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_igkin&#8221;</td>
<td>(#C(0 .5) g | p dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_igovlp&#8221;</td>
<td>(#C(0 1) g |)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_ignuc&#8221;</td>
<td>(#C(0 1) g | nuc |)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_z&#8221;</td>
<td>( | zc | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_zz&#8221;</td>
<td>( | zc zc | )</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_r&#8221;</td>
<td>( | rc | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_r2&#8221;</td>
<td>( | rc dot rc | )</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_rr&#8221;</td>
<td>( | rc rc | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_rrr&#8221;</td>
<td>( | rc rc rc | )</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_rrrr&#8221;</td>
<td>( | rc rc rc rc | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_pnucp&#8221;</td>
<td>(p* | nuc dot p | )</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_prinvxp&#8221;</td>
<td>(p* | rinv cross p | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_ipovlp&#8221;</td>
<td>(nabla |)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_ipkin&#8221;</td>
<td>(.5 nabla | p dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_ipnuc&#8221;</td>
<td>(nabla | nuc |)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_iprinv&#8221;</td>
<td>(nabla | rinv |)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_rinv&#8221;</td>
<td>(| rinv |)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_pnucxp&#8221;</td>
<td>(p* | nuc cross p | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_irp&#8221;</td>
<td>( | rc nabla | )</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_irrp&#8221;</td>
<td>( | rc rc nabla | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_irpr&#8221;</td>
<td>( | rc nabla rc | )</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_ggovlp&#8221;</td>
<td>( | g g | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_ggkin&#8221;</td>
<td>(.5 | g g p dot p | )</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_ggnuc&#8221;</td>
<td>( | g g nuc | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_grjxp&#8221;</td>
<td>( | g r cross p | )</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_ovlp_spinor&#8221;</td>
<td>( | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_nuc_spinor&#8221;</td>
<td>( | nuc |)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_srsr_spinor&#8221;</td>
<td>(sigma dot r | sigma dot r)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_sr_spinor&#8221;</td>
<td>(sigma dot r |)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_srsp_spinor&#8221;</td>
<td>(sigma dot r | sigma dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_spsp_spinor&#8221;</td>
<td>(sigma dot p | sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_sp_spinor&#8221;</td>
<td>(sigma dot p |)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_spnucsp_spinor&#8221;</td>
<td>(sigma dot p | nuc | sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_srnucsr_spinor&#8221;</td>
<td>(sigma dot r | nuc | sigma dot r)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_govlp_spinor&#8221;</td>
<td>(g |)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_gnuc_spinor&#8221;</td>
<td>(g | nuc |)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_cg_sa10sa01_spinor&#8221;</td>
<td>(.5 sigma cross rc | sigma cross nabla-rinv |)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_cg_sa10sp_spinor&#8221;</td>
<td>(.5 rc cross sigma | sigma dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_cg_sa10nucsp_spinor&#8221;</td>
<td>(.5 rc cross sigma | nuc | sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_giao_sa10sa01_spinor&#8221;</td>
<td>(.5 sigma cross r | sigma cross nabla-rinv |)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_giao_sa10sp_spinor&#8221;</td>
<td>(.5 r cross sigma | sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_giao_sa10nucsp_spinor&#8221;</td>
<td>(.5 r cross sigma | nuc | sigma dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_sa01sp_spinor&#8221;</td>
<td>(| nabla-rinv cross sigma | sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_spgsp_spinor&#8221;</td>
<td>(g sigma dot p | sigma dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_spgnucsp_spinor&#8221;</td>
<td>(g sigma dot p | nuc | sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_spgsa01_spinor&#8221;</td>
<td>(g sigma dot p | nabla-rinv cross sigma |)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_spspsp_spinor&#8221;</td>
<td>(sigma dot p | sigma dot p sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_spnuc_spinor&#8221;</td>
<td>(sigma dot p | nuc |)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_ipovlp_spinor&#8221;</td>
<td>(nabla |)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_ipkin_spinor&#8221;</td>
<td>(.5 nabla | p dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_ipnuc_spinor&#8221;</td>
<td>(nabla | nuc |)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_iprinv_spinor&#8221;</td>
<td>(nabla | rinv |)</td>
</tr>
<tr class="row-odd"><td>&#8220;int1e_ipspnucsp_spinor&#8221;</td>
<td>(nabla sigma dot p | nuc | sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int1e_ipsprinvsp_spinor&#8221;</td>
<td>(nabla sigma dot p | rinv | sigma dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e&#8221;</td>
<td>( , | , )</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_ig1&#8221;</td>
<td>(#C(0 1) g , | , )</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_gg1&#8221;</td>
<td>(g g , | , )</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_g1g2&#8221;</td>
<td>(g , | g , )</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_p1vxp1&#8221;</td>
<td>( p* , cross p | , ) ; SSO</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_spinor&#8221;</td>
<td>(, | , )</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_spsp1_spinor&#8221;</td>
<td>(sigma dot p , sigma dot p | , )</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_spsp1spsp2_spinor&#8221;</td>
<td>(sigma dot p , sigma dot p | sigma dot p , sigma dot p )</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_srsr1_spinor&#8221;</td>
<td>(sigma dot r , sigma dot r | ,)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_srsr1srsr2_spinor&#8221;</td>
<td>(sigma dot r , sigma dot r | sigma dot r , sigma dot r)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_cg_sa10sp1_spinor&#8221;</td>
<td>(.5 rc cross sigma , sigma dot p | ,)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_cg_sa10sp1spsp2_spinor&#8221;</td>
<td>(.5 rc cross sigma , sigma dot p | sigma dot p , sigma dot p )</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_giao_sa10sp1_spinor&#8221;</td>
<td>(.5 r cross sigma , sigma dot p | ,)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_giao_sa10sp1spsp2_spinor&#8221;</td>
<td>(.5 r cross sigma , sigma dot p | sigma dot p , sigma dot p )</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_g1_spinor&#8221;</td>
<td>(g , | ,)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_spgsp1_spinor&#8221;</td>
<td>(g sigma dot p , sigma dot p | ,)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_g1spsp2_spinor&#8221;</td>
<td>(g , | sigma dot p , sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_spgsp1spsp2_spinor&#8221;</td>
<td>(g sigma dot p , sigma dot p | sigma dot p , sigma dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_spv1_spinor&#8221;</td>
<td>(sigma dot p , | ,)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_vsp1_spinor&#8221;</td>
<td>(, sigma dot p | ,)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_spsp2_spinor&#8221;</td>
<td>(, | sigma dot p , sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_spv1spv2_spinor&#8221;</td>
<td>(sigma dot p , | sigma dot p ,)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_vsp1spv2_spinor&#8221;</td>
<td>(, sigma dot p | sigma dot p ,)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_spv1vsp2_spinor&#8221;</td>
<td>(sigma dot p , | , sigma dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_vsp1vsp2_spinor&#8221;</td>
<td>(, sigma dot p | , sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_spv1spsp2_spinor&#8221;</td>
<td>(sigma dot p , | sigma dot p , sigma dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_vsp1spsp2_spinor&#8221;</td>
<td>(, sigma dot p | sigma dot p , sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_ig1&#8221;</td>
<td>(#C(0 1) g , | , )</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_ip1&#8221;</td>
<td>(nabla , | ,)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_ip1_spinor&#8221;</td>
<td>(nabla , | ,)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_ipspsp1_spinor&#8221;</td>
<td>(nabla sigma dot p , sigma dot p | ,)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_ip1spsp2_spinor&#8221;</td>
<td>(nabla , | sigma dot p , sigma dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_ipspsp1spsp2_spinor&#8221;</td>
<td>(nabla sigma dot p , sigma dot p | sigma dot p , sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_ipsrsr1_spinor&#8221;</td>
<td>(nabla sigma dot r , sigma dot r | ,)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_ip1srsr2_spinor&#8221;</td>
<td>(nabla , | sigma dot r , sigma dot r)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_ipsrsr1srsr2_spinor&#8221;</td>
<td>(nabla sigma dot r , sigma dot r | sigma dot r , sigma dot r)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_ip1&#8221;</td>
<td>(nabla , | ,)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_ssp1ssp2_spinor&#8221;</td>
<td>( , sigma dot p | gaunt | , sigma dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_cg_ssa10ssp2_spinor&#8221;</td>
<td>(rc cross sigma , | gaunt | , sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_giao_ssa10ssp2_spinor&#8221;</td>
<td>(r cross sigma  , | gaunt | , sigma dot p)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_gssp1ssp2_spinor&#8221;</td>
<td>(g , sigma dot p  | gaunt | , sigma dot p)</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_ipip1&#8221;</td>
<td>( nabla nabla , | , )</td>
</tr>
<tr class="row-odd"><td>&#8220;int2e_ipvip1&#8221;</td>
<td>( nabla , nabla | , )</td>
</tr>
<tr class="row-even"><td>&#8220;int2e_ip1ip2&#8221;</td>
<td>( nabla , | nabla , )</td>
</tr>
<tr class="row-odd"><td>&#8220;int3c2e_ip1&#8221;</td>
<td>(nabla , | )</td>
</tr>
<tr class="row-even"><td>&#8220;int3c2e_ip2&#8221;</td>
<td>( , | nabla)</td>
</tr>
<tr class="row-odd"><td>&#8220;int2c2e_ip1&#8221;</td>
<td>(nabla | r12 | )</td>
</tr>
<tr class="row-even"><td>&#8220;int3c2e_spinor&#8221;</td>
<td>(nabla , | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int3c2e_spsp1_spinor&#8221;</td>
<td>(nabla , | )</td>
</tr>
<tr class="row-even"><td>&#8220;int3c2e_ip1_spinor&#8221;</td>
<td>(nabla , | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int3c2e_ip2_spinor&#8221;</td>
<td>( , | nabla)</td>
</tr>
<tr class="row-even"><td>&#8220;int3c2e_ipspsp1_spinor&#8221;</td>
<td>(nabla sigma dot p , sigma dot p | )</td>
</tr>
<tr class="row-odd"><td>&#8220;int3c2e_spsp1ip2_spinor&#8221;</td>
<td>(sigma dot p , sigma dot p | nabla )</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="last docutils">
<dt>atm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>bas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>env</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float64 ndarray</span><dd>libcint integral function argument</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>shls_slice</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">8-element list</span><dd>(ish_start, ish_end, jsh_start, jsh_end, ksh_start, ksh_end, lsh_start, lsh_end)</dd>
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Components of the integrals, e.g. int1e_ipovlp has 3 components.</dd>
<dt>hermi</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int (1e integral only)</span><dd><p class="first">Symmetry of the 1e integrals</p>
<div class="last line-block">
<div class="line">0 : no symmetry assumed (default)</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>aosym</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str (2e integral only)</span><dd><p class="first">Symmetry of the 2e integrals</p>
<div class="last line-block">
<div class="line">4 or &#8216;4&#8217; or &#8216;s4&#8217;: 4-fold symmetry (default)</div>
<div class="line">&#8216;2ij&#8217; or &#8216;s2ij&#8217; : symmetry between i, j in (ij|kl)</div>
<div class="line">&#8216;2kl&#8217; or &#8216;s2kl&#8217; : symmetry between k, l in (ij|kl)</div>
<div class="line">1 or &#8216;1&#8217; or &#8216;s1&#8217;: no symmetry</div>
</div>
</dd>
<dt>out</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">ndarray (2e integral only)</span><dd>array to store the 2e AO integrals</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">getints</span><span class="p">(</span><span class="s1">&#39;int1e_ipnuc_sph&#39;</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># &lt;nabla i | V_nuc | j&gt;</span>
<span class="go">[[[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.10289944  0.48176097]</span>
<span class="go">  [-0.48176097 -0.10289944]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.moleintor.getints_by_shell">
<code class="descclassname">pyscf.gto.moleintor.</code><code class="descname">getints_by_shell</code><span class="sig-paren">(</span><em>intor_name</em>, <em>shls</em>, <em>atm</em>, <em>bas</em>, <em>env</em>, <em>comp=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/moleintor.html#getints_by_shell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.moleintor.getints_by_shell" title="Permalink to this definition">¶</a></dt>
<dd><p>For given 2, 3 or 4 shells, interface for libcint to get 1e, 2e,
2-center-2e or 3-center-2e integrals</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>intor_name</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>See also <a class="reference internal" href="#pyscf.gto.moleintor.getints" title="pyscf.gto.moleintor.getints"><code class="xref py py-func docutils literal"><span class="pre">getints()</span></code></a> for the supported intor_name</dd>
<dt>shls</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span><dd>The AO shell-ids of the integrals</dd>
<dt>atm</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>bas</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int32 ndarray</span><dd>libcint integral function argument</dd>
<dt>env</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">float64 ndarray</span><dd>libcint integral function argument</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>comp</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">int</span><dd>Components of the integrals, e.g. int1e_ipovlp has 3 components.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>ndarray of 2-dim to 5-dim, depending on the integral type (1e,
2e, 3c-2e, 2c2e) and the value of comp</dd>
<dt>Examples:</dt>
<dd>The gradients of the spherical 2e integrals</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">getints_by_shell</span><span class="p">(</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[[[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.08760462]]]]]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="basis">
<span id="gto-basis"></span><h3>4.2.3. basis<a class="headerlink" href="#basis" title="Permalink to this headline">¶</a></h3>
<div class="section" id="internal-format">
<h4>4.2.3.1. Internal format<a class="headerlink" href="#internal-format" title="Permalink to this headline">¶</a></h4>
<p>This module loads basis set and ECP data from basis database and parse the basis
(mostly in NWChem format) and finally convert to internal format.  The internal
format of basis set is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="n">atom_type1</span><span class="p">:[[</span><span class="n">angular_momentum</span>
                      <span class="p">(</span><span class="n">GTO</span><span class="o">-</span><span class="n">exp1</span><span class="p">,</span> <span class="n">contract</span><span class="o">-</span><span class="n">coeff11</span><span class="p">,</span> <span class="n">contract</span><span class="o">-</span><span class="n">coeff12</span><span class="p">),</span>
                      <span class="p">(</span><span class="n">GTO</span><span class="o">-</span><span class="n">exp2</span><span class="p">,</span> <span class="n">contract</span><span class="o">-</span><span class="n">coeff21</span><span class="p">,</span> <span class="n">contract</span><span class="o">-</span><span class="n">coeff22</span><span class="p">),</span>
                      <span class="p">(</span><span class="n">GTO</span><span class="o">-</span><span class="n">exp3</span><span class="p">,</span> <span class="n">contract</span><span class="o">-</span><span class="n">coeff31</span><span class="p">,</span> <span class="n">contract</span><span class="o">-</span><span class="n">coeff32</span><span class="p">),</span>
                      <span class="o">...</span><span class="p">],</span>
                     <span class="p">[</span><span class="n">angular_momentum</span>
                      <span class="p">(</span><span class="n">GTO</span><span class="o">-</span><span class="n">exp1</span><span class="p">,</span> <span class="n">contract</span><span class="o">-</span><span class="n">coeff11</span><span class="p">,</span> <span class="n">contract</span><span class="o">-</span><span class="n">coeff12</span><span class="p">),</span>
                      <span class="o">...</span><span class="p">],</span>
                     <span class="o">...</span><span class="p">],</span>
         <span class="n">atom_type2</span><span class="p">:[[</span><span class="n">angular_momentum</span><span class="p">,</span> <span class="p">(</span><span class="o">...</span><span class="p">),],</span>
                     <span class="o">...</span><span class="p">],</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span>
                    <span class="p">(</span><span class="mf">19.2406000</span><span class="p">,</span> <span class="mf">0.0328280</span><span class="p">),</span>
                    <span class="p">(</span><span class="mf">2.8992000</span><span class="p">,</span> <span class="mf">0.2312080</span><span class="p">),</span>
                    <span class="p">(</span><span class="mf">0.6534000</span><span class="p">,</span> <span class="mf">0.8172380</span><span class="p">),],</span>
                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span>
                    <span class="p">(</span><span class="mf">0.1776000</span><span class="p">,</span> <span class="mf">1.0000000</span><span class="p">),],</span>
                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">(</span><span class="mf">1.0000000</span><span class="p">,</span> <span class="mf">1.0000000</span><span class="p">),]],</span>
            <span class="p">}</span>
</pre></div>
</div>
<p>Some basis sets, e.g. <code class="file docutils literal"><span class="pre">pyscf/gto/basis/dzp_dunning.py</span></code>, are saved in the
internal format.</p>
<span class="target" id="module-pyscf.gto.basis"></span><dl class="function">
<dt id="pyscf.gto.basis.load">
<code class="descclassname">pyscf.gto.basis.</code><code class="descname">load</code><span class="sig-paren">(</span><em>filename_or_basisname</em>, <em>symb</em>, <em>optimize=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/basis.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.basis.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the basis of the given symbol to internal format</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>filename_or_basisname</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Case insensitive basis set name. Special characters will be removed.
or a string of &#8220;path/to/file&#8221; which stores the basis functions</dd>
<dt>symb</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str</span><dd>Atomic symbol, Special characters will be removed.</dd>
</dl>
</dd>
<dt>Examples:</dt>
<dd>Load STO 3G basis of carbon to oxygen atom</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="n">load</span><span class="p">(</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.basis.load_ecp">
<code class="descclassname">pyscf.gto.basis.</code><code class="descname">load_ecp</code><span class="sig-paren">(</span><em>filename_or_basisname</em>, <em>symb</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/basis.html#load_ecp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.basis.load_ecp" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the basis of the given symbol to internal format</p>
</dd></dl>

<dl class="function">
<dt id="pyscf.gto.basis.parse">
<code class="descclassname">pyscf.gto.basis.</code><code class="descname">parse</code><span class="sig-paren">(</span><em>string</em>, <em>symb=None</em>, <em>optimize=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyscf/gto/basis.html#parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.gto.basis.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the basis text which is in NWChem format. Return an internal
basis format which can be assigned to attribute <code class="xref py py-attr docutils literal"><span class="pre">Mole.basis</span></code>
Empty lines, or the lines started with #, or the lines of &#8220;BASIS SET&#8221; and
&#8220;END&#8221; will be ignored are ignored.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>string : A string in NWChem basis format. Empty links and the lines of
&#8220;BASIS SET&#8221; and &#8220;END&#8221; will be ignored</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>optimize</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">Optimize basis contraction.  Convert the segment contracted</span><dd>basis to the general contracted basis.</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="n">gto</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s2">#BASIS SET: (6s,3p) -&gt; [2s,1p]</span>
<span class="gp">... </span><span class="s2">C    S</span>
<span class="gp">... </span><span class="s2">     71.6168370              0.15432897</span>
<span class="gp">... </span><span class="s2">     13.0450960              0.53532814</span>
<span class="gp">... </span><span class="s2">      3.5305122              0.44463454</span>
<span class="gp">... </span><span class="s2">C    SP</span>
<span class="gp">... </span><span class="s2">      2.9412494             -0.09996723             0.15591627</span>
<span class="gp">... </span><span class="s2">      0.6834831              0.39951283             0.60768372</span>
<span class="gp">... </span><span class="s2">      0.2222899              0.70011547             0.39195739</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span><span class="p">)}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s2">He    S</span>
<span class="gp">... </span><span class="s2">     13.6267000              0.1752300</span>
<span class="gp">... </span><span class="s2">      1.9993500              0.8934830</span>
<span class="gp">... </span><span class="s2">      0.3829930              0.0000000</span>
<span class="gp">... </span><span class="s2">He    S</span>
<span class="gp">... </span><span class="s2">     13.6267000              0.0000000</span>
<span class="gp">... </span><span class="s2">      1.9993500              0.0000000</span>
<span class="gp">... </span><span class="s2">      0.3829930              1.0000000</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[[0, [13.6267, 0.17523, 0.0], [1.99935, 0.893483, 0.0], [0.382993, 0.0, 1.0]]]</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lib.html" class="btn btn-neutral float-right" title="5. lib — Helper functions, parameters, and C extensions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="install.html" class="btn btn-neutral" title="3. Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-, Qiming Sun &lt;osirpt.sun@gmail.com&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.7.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ''
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>